<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>螺旋矩阵总结</title>
      <link href="/2023/04/25/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/2023-4-25-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/25/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/2023-4-25-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h1><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>这类题目考察一些输入输出的技巧，通常记录上下左右的偏移位置达到想要的结果。</p><p>​        类似题目</p><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul>              </div>            </details><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        int i=0,j=0,cnt=1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int loop = n/2;//循环次数</span><br><span class="line">        int t = 0;</span><br><span class="line">        while(loop--)&#123;</span><br><span class="line">            for(j;j&lt;n-1-t;j++)</span><br><span class="line">                a[i][j] = cnt++;</span><br><span class="line">            for(i;i&lt;n-1-t;i++)</span><br><span class="line">                a[i][j] = cnt++;</span><br><span class="line">            for(j;j&gt;0+t;j--)</span><br><span class="line">                a[i][j] = cnt++;</span><br><span class="line">            for(i;i&gt;0+t;i--)</span><br><span class="line">                a[i][j] = cnt++;</span><br><span class="line">            //i = 0 j = 0</span><br><span class="line">            i++;j++;t++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n%2 == 1)&#123;</span><br><span class="line">            a[n/2][n/2] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">       vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector &lt;int&gt; res;</span><br><span class="line">        if(matrix.empty()) return res;</span><br><span class="line">        int rl = 0, rh = matrix.size()-1; //记录待打印的矩阵上下边缘</span><br><span class="line">        int cl = 0, ch = matrix[0].size()-1; //记录待打印的矩阵左右边缘</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            for(int i=cl; i&lt;=ch; i++) res.push_back(matrix[rl][i]);//从左往右</span><br><span class="line">            if(++rl &gt; rh) break; //往下走（rl++），若超出边界，退出</span><br><span class="line">            for(int i=rl; i&lt;=rh; i++) res.push_back(matrix[i][ch]);//从上往下</span><br><span class="line">            if(--ch &lt; cl) break;</span><br><span class="line">            for(int i=ch; i&gt;=cl; i--) res.push_back(matrix[rh][i]);//从右往左</span><br><span class="line">            if(--rh &lt; rl) break;</span><br><span class="line">            for(int i=rh; i&gt;=rl; i--) res.push_back(matrix[i][cl]);//从下往上</span><br><span class="line">            if(++cl &gt; ch) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下epoll_BS服务器开发</title>
      <link href="/2023/04/20/Linux/%E9%83%A8%E7%BD%B2epoll_BS/"/>
      <url>/2023/04/20/Linux/%E9%83%A8%E7%BD%B2epoll_BS/</url>
      
        <content type="html"><![CDATA[<h1 id="部署epoll-BS"><a href="#部署epoll-BS" class="headerlink" title="部署epoll_BS"></a>部署epoll_BS</h1><p>项目地址：<a href="https://github.com/jack8luo/epoll_BS">jack8luo/epoll_BS: linux下的一个基于epoll多路IO转发的本地文件传输服务器。没有做压力测试，没有使用线程池。 (github.com)</a></p><h2 id="远程操作服务器SSH："><a href="#远程操作服务器SSH：" class="headerlink" title="远程操作服务器SSH："></a>远程操作服务器SSH：</h2><p>下载一个连接服务器的软件——securecrx可以远程操作服务器。        需要在服务器上安装ssh服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开机自动启动ssh命令</span><br><span class="line">sudo systemctl enable ssh</span><br><span class="line"> </span><br><span class="line"># 关闭ssh开机自动启动命令</span><br><span class="line">sudo systemctl disable ssh</span><br><span class="line"> </span><br><span class="line"># 单次开启ssh</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line"> </span><br><span class="line"># 单次关闭ssh</span><br><span class="line">sudo systemctl stop ssh</span><br><span class="line"> </span><br><span class="line"># 设置好后重启系统</span><br><span class="line">reboot</span><br><span class="line"> </span><br><span class="line">#查看ssh是否启动，看到Active: active (running)即表示成功</span><br><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure><h2 id="远程复制服务器文件FTP"><a href="#远程复制服务器文件FTP" class="headerlink" title="远程复制服务器文件FTP"></a>远程复制服务器文件FTP</h2><p>使用 FileZilla 工具互传<br>FileZilla是一款免费的工具，是基于 FTP 协议进行文件互传的，在传输过程中我们的ubuntu是作为服务器， FileZilla 工具则是作为客户端。</p><p>2.1 ubuntu安装 FTP服务<br>在ubuntu终端下输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><p>安装完之后检查 /etc/vsftpd.conf 配置文件</p><p>输入如下命令打开配置文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi  /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>然后检查下图 28 和 31 行的内容是否有被注释掉，如果前面有 “#” 号注释起来的话，就去掉即可。</p><p>修改完之后，重启FTP服务，如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure><p>2.2 windows安装和配置FileZilla<br>FileZilla 客户端下载和安装</p><p>FileZilla工具可以去官网下载即可，<a href="https://www.filezilla.cn/download">https://www.filezilla.cn/download</a></p><p>我们要安装的是客户端，选择对应版本的客户端下载，然后一路 next 安装即可。</p><p>FileZilla 软件配置和连接ubuntu</p><p>打开 FileZilla 软件，然后选择：文件 -&gt; 站点管理器 -&gt; 点击新增站点，然后配置连接参数，如下图：</p><p>点击连接之后，就可以看到ubuntu下的文件了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/325c85dc4a7b438cbd55469772cc863f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbHVvYmVpaGFp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>我们要把windows的文件拷贝到ubuntu中，直接在左侧把windows下的目录文件拖到右侧ubuntu中指定的目录即可。</p><h2 id="push代码中遇到的问题"><a href="#push代码中遇到的问题" class="headerlink" title="push代码中遇到的问题"></a>push代码中遇到的问题</h2><p><a href="https://blog.csdn.net/gongdamrgao/article/details/115032436">关于git的问题：error: src refspec main does not match any_TripleGold.的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程Day9</title>
      <link href="/2023/04/06/Linux/Linux%E7%BA%BF%E7%A8%8BDay9/"/>
      <url>/2023/04/06/Linux/Linux%E7%BA%BF%E7%A8%8BDay9/</url>
      
        <content type="html"><![CDATA[<p>守护进程：</p><pre><code>daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。不受用户登录注销影响。通常采用以d结尾的命名方式。</code></pre><p>守护进程创建步骤：</p><pre><code>1. fork子进程，让父进程终止。2. 子进程调用 setsid() 创建新会话3. 通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。4. 通常根据需要，重设umask文件权限掩码，影响新文件的创建权限。  022 -- 755    0345 --- 432   r---wx-w-   4225. 通常根据需要，关闭/重定向 文件描述符6. 守护进程 业务逻辑。while（）</code></pre><p>=============================================================</p><p>线程概念：</p><pre><code>进程：有独立的 进程地址空间。有独立的pcb。    分配资源的最小单位。线程：有独立的pcb。没有独立的进程地址空间。    最小单位的执行。ps -Lf 进程id     ---&gt; 线程号。LWP  --》cpu 执行的最小单位。</code></pre><p>线程共享：</p><pre><code>独享 栈空间（内核栈、用户栈）共享 ./text./data ./rodataa ./bsss heap  ---&gt; 共享【全局变量】（errno）</code></pre><p>线程控制原语：</p><pre><code>pthread_t pthread_self(void);    获取线程id。 线程id是在进程地址空间内部，用来标识线程身份的id号。    返回值：本线程id检查出错返回：  线程中。    fprintf(stderr, &quot;xxx error: %s\n&quot;, strerror(ret));int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg); 创建子线程。    参1：传出参数，表新创建的子线程 id    参2：线程属性。传NULL表使用默认属性。    参3：子线程回调函数。创建成功，ptherad_create函数返回时，该函数会被自动调用。    参4：参3的参数。没有的话，传NULL    返回值：成功：0        失败：errno循环创建N个子线程：    for （i = 0； i &lt; 5; i++）        pthread_create(&amp;tid, NULL, tfn, (void *)i);   // 将 int 类型 i， 强转成 void *， 传参。    void pthread_exit(void *retval);  退出当前线程。    retval：退出值。 无退出值时，NULL    exit();    退出当前进程。    return: 返回到调用者那里去。    pthread_exit(): 退出当前线程。int pthread_join(pthread_t thread, void **retval);    阻塞 回收线程。    thread: 待回收的线程id    retval：传出参数。 回收的那个线程的退出值。        线程异常借助，值为 -1。    返回值：成功：0        失败：errnoint pthread_detach(pthread_t thread);        设置线程分离    thread: 待分离的线程id</code></pre><p>​<br>        返回值：成功：0</p><pre><code>        失败：errno    int pthread_cancel(pthread_t thread);        杀死一个线程。  需要到达取消点（保存点）    thread: 待杀死的线程id    返回值：成功：0        失败：errno    如果，子线程没有到达取消点， 那么 pthread_cancel 无效。    我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();    成功被 pthread_cancel() 杀死的线程，返回 -1.使用pthead_join 回收。线程控制原语                    进程控制原语pthread_create()                fork();pthread_self()                    getpid();pthread_exit()                    exit();         / return pthread_join()                    wait()/waitpid()pthread_cancel()                kill()pthread_detach()</code></pre><p>线程属性：</p><pre><code>设置分离属性。pthread_attr_t attr      创建一个线程属性结构体变量pthread_attr_init(&amp;attr);    初始化线程属性pthread_attr_setdetachstate(&amp;attr,  PTHREAD_CREATE_DETACHED);        设置线程属性为 分离态pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程pthread_attr_destroy(&amp;attr);    销毁线程属性</code></pre><p>不要在程序中同时用线程和信号。</p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号Day8</title>
      <link href="/2023/04/05/Linux/Linux%E4%BF%A1%E5%8F%B7Day8/"/>
      <url>/2023/04/05/Linux/Linux%E4%BF%A1%E5%8F%B7Day8/</url>
      
        <content type="html"><![CDATA[<p>信号共性：</p><pre><code>简单、不能携带大量信息、满足条件才发送。</code></pre><p>信号的特质：</p><pre><code>信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。所有信号的产生及处理全部都是由【内核】完成的。</code></pre><p>信号相关的概念：</p><blockquote><p>产生信号：</p><pre><code> 1. 按键产生 2. 系统调用产生 3. 软件条件产生 4. 硬件异常产生 5. 命令产生</code></pre><p>概念：<br>    未决：产生与递达之间状态。  </p><p>​    递达：产生并且送达到进程。直接被内核处理掉。</p><p>​    信号处理方式： 执行默认处理动作、忽略、捕捉（自定义）</p><p>​    阻塞信号集（信号屏蔽字）： 本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。</p><p>​    未决信号集：本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。</p></blockquote><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230406101059515.png" alt="阻塞和未决"></p><p>kill库函数 kill（pid_t ，int ）：给某个进程发送一个信号</p><p>kill命令 和 kill函数：</p><pre><code>int kill（pid_t pid, int signum）参数：    pid:     &gt; 0:发送信号给指定进程        = 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。        &lt; -1: 取绝对值，发送信号给该绝对值所对应的进程组的所有组员。        = -1：发送信号给，有权限发送的所有进程。    signum：待发送的信号返回值：    成功： 0    失败： -1 errno</code></pre><p>alarm 函数：使用自然计时法。</p><pre><code>定时发送SIGALRM给当前进程。unsigned int alarm(unsigned int seconds);    seconds：定时秒数    返回值：上次定时剩余时间。        无错误现象。    alarm（0）； 取消闹钟。time 命令 ： 查看程序执行时间。   实际时间 = 用户时间 + 内核时间 + 等待时间。  --》 优化瓶颈 IO</code></pre><p>setitimer函数：</p><pre><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);参数：    which：    ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM        ITIMER_VIRTUAL: 采用用户空间计时  ---&gt; SIGVTALRM        ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF    new_value：定时秒数               类型：struct itimerval &#123;                           struct timeval &#123;                               time_t      tv_sec;         /* seconds */                               suseconds_t tv_usec;        /* microseconds */                       &#125;it_interval;---&gt; 周期定时秒数                            struct timeval &#123;                               time_t      tv_sec;                                        suseconds_t tv_usec;                               &#125;it_value;  ---&gt; 第一次定时秒数                      &#125;;    old_value：传出参数，上次定时剩余时间。    e.g.        struct itimerval new_t;            struct itimerval old_t;            new_t.it_interval.tv_sec = 0;        new_t.it_interval.tv_usec = 0;        new_t.it_value.tv_sec = 1;        new_t.it_value.tv_usec = 0;        int ret = setitimer(&amp;new_t, &amp;old_t);  定时1秒返回值：    成功： 0    失败： -1 errno</code></pre><p>其他几个发信号函数：</p><pre><code>int raise(int sig);void abort(void);</code></pre><p>信号集操作函数：内核不允许操作未决信号集，但是可以操作阻塞信号集影响未决信号集</p><pre><code>sigset_t set;  自定义信号集。sigemptyset(sigset_t *set);    清空信号集sigfillset(sigset_t *set);    全部置1sigaddset(sigset_t *set, int signum);    将一个信号添加到集合中sigdelset(sigset_t *set, int signum);    将一个信号从集合中移除sigismember（const sigset_t *set，int signum); 判断一个信号是否在集合中。 在--》1， 不在--》0</code></pre><p>设置信号屏蔽字和解除屏蔽：</p><pre><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    how:    SIG_BLOCK:    设置阻塞        SIG_UNBLOCK:    取消阻塞        SIG_SETMASK:    用自定义set替换mask。    set：    自定义set    oldset：旧有的 mask。</code></pre><p>查看未决信号集：</p><pre><code>int sigpending(sigset_t *set);    set： 传出的 未决信号集。</code></pre><p>【信号捕捉】：</p><pre><code>signal();【sigaction();】 重点！！！</code></pre><p>​        </p><p>信号捕捉特性：</p><pre><code>1. 捕捉函数执行期间，信号屏蔽字 由 mask --&gt; sa_mask , 捕捉函数执行结束。 恢复回mask2. 捕捉函数执行期间，本信号自动被屏蔽(sa_flgs = 0).3. 捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</code></pre><p>借助信号完成 子进程回收。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程Day7</title>
      <link href="/2023/04/04/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day7/"/>
      <url>/2023/04/04/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day7/</url>
      
        <content type="html"><![CDATA[<h2 id="pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l"><a href="#pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l" class="headerlink" title="pipe管道： 用于有血缘关系的进程间通信。  ps aux | grep         ls | wc -l"></a>pipe管道： 用于有血缘关系的进程间通信。  ps aux | grep         ls | wc -l</h2><pre><code>父子进程间通信：兄弟进程间通信：</code></pre><h2 id="fifo管道：可以用于无血缘关系的进程间通信。"><a href="#fifo管道：可以用于无血缘关系的进程间通信。" class="headerlink" title="fifo管道：可以用于无血缘关系的进程间通信。"></a>fifo管道：可以用于无血缘关系的进程间通信。</h2><pre><code>命名管道：  mkfifo 无血缘关系进程间通信：    读端，open fifo O_RDONLY    写端，open fifo O_WRONLY</code></pre><h2 id="文件实现进程间通信-很早以前的东西，过时了-："><a href="#文件实现进程间通信-很早以前的东西，过时了-：" class="headerlink" title="文件实现进程间通信(很早以前的东西，过时了)："></a>文件实现进程间通信(很早以前的东西，过时了)：</h2><p><strong>打开的文件是内核中的一块缓冲区</strong>。<strong>多个</strong>无血缘关系的进程，可以<strong>同时</strong>访问该文件。</p><h2 id="★共享内存映射"><a href="#★共享内存映射" class="headerlink" title="★共享内存映射:"></a>★共享内存映射:</h2><p>void <em>mmap(void </em>addr, size_t length, int prot, int flags, int fd, off_t offset);        创建共享内存映射</p><blockquote><p>参数：<br>    addr：     指定映射区的首地址。通常传NULL，表示让系统自动分配</p><p>​    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</p><p>​    prot：    共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p><p>​    flags：    标注共享内存的共享属性。MAP_SHARED：会<strong>同步内存到磁盘上</strong>、MAP_PRIVATE</p><p>​    fd:    用于创建共享内存映射区的那个文件的 文件描述符。</p><p>​    offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</p><p>返回值：</p><p>​    成功：映射区的首地址。</p><p>​    失败：MAP_FAILED 宏实质是：(void*(-1))， errno</p></blockquote><p>int munmap(void *addr, size_t length);        释放映射区。</p><pre><code>addr：mmap 的返回值length：大小</code></pre><h2 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a>使用注意事项：</h2><blockquote><ol><li><p>用于创建映射区的文件大小为 0，实际指定非0大小创建映射区，出 “总线错误”。</p></li><li><p>用于创建映射区的文件大小为 0，实际制定0大小创建映射区， 出 “无效参数”。</p></li><li><p>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</p></li><li><p>创建映射区，需要read权限。当访问权限指定为 “共享”MAP_SHARED时， mmap的读写权限，应该 &lt;=文件的open权限。    只写不行。 私有MAP_PRIVATE可以改，见第10点。</p></li><li><p>文件描述符fd，在mmap创建映射区完成即可关闭。后续访问文件，用 地址访问。</p></li><li><p>offset 必须是 4096的整数倍。（MMU 映射的最小单位 4k ）</p></li><li><p>对申请的映射区内存，不能越界访问。 </p></li><li><p>munmap用于释放的 地址，必须是mmap申请返回的地址。</p></li><li><p>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</p></li><li><p>映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</p></li></ol></blockquote><p>mmap函数的保险调用方式：</p><pre><code>1. fd = open（&quot;文件名&quot;， O_RDWR）;2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</code></pre><p>父子进程使用 mmap 进程间通信：</p><pre><code>父进程 先 创建映射区。 open（ O_RDWR） mmap( MAP_SHARED );指定 MAP_SHARED 权限fork() 创建子进程。一个进程读， 另外一个进程写。</code></pre><p>无血缘关系进程间 mmap 通信：                  【会写】</p><pre><code>两个进程 打开同一个文件，创建映射区。指定flags 为 MAP_SHARED。一个进程写入，另外一个进程读出。【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。                fifo：数据只能一次读取。</code></pre><p>匿名映射：只能用于 血缘关系进程间通信。</p><pre><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
      <url>/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="209-长度最小的子数组（滑动窗口）"><a href="#209-长度最小的子数组（滑动窗口）" class="headerlink" title="209. 长度最小的子数组（滑动窗口）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>（滑动窗口）</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        cout&lt;&lt;INT_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; j-i+<span class="number">1</span>)</span><br><span class="line">                    min = j-i+<span class="number">1</span>;</span><br><span class="line">                temp -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == nums.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口，当不好判断移动的条件时，可以借助map判断 i 到 j 数组中是否种类为两种，使用函数判断种类是否大于2的话，复杂度就起来了。所以只能用map</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            ++cnt[fruits[right]];</span><br><span class="line">            <span class="keyword">while</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;<span class="comment">//left移动至erase一个</span></span><br><span class="line">                <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[left]);</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-1"><a href="#类似题目-1" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        //移动窗口</span><br><span class="line">        map&lt;char,int&gt;  hash;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int m = t.size();</span><br><span class="line">        for(char ch : t) hash[ch]--;</span><br><span class="line"></span><br><span class="line">        int min = INT_MAX;</span><br><span class="line">        int start;</span><br><span class="line">        for (int i = 0,j = 0, cnt = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 双指针移动 */</span><br><span class="line">            hash[s[i]]++;</span><br><span class="line">            if(hash[s[i]] &lt;= 0) cnt++;//s[i]是t中元素</span><br><span class="line">            while(cnt == m &amp;&amp; hash[s[j]] &gt; 0) hash[s[j++]]--;//j右移</span><br><span class="line">            if(cnt == m &amp;&amp; min &gt; i - j + 1)&#123;</span><br><span class="line">                min = i - j + 1;</span><br><span class="line">                start = j;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        if(min == INT_MAX) //若没有覆盖子串</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        return s.substr(start,min);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>滑动窗口通常要判断左移右移的边界条件，通常用map进行判断</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针总结</title>
      <link href="/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/"/>
      <url>/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>这里使用双指针是因为我们暴力求解问题时，需要循环遍历两遍数组。</p><p>所以在这里可以<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>暴力过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif" alt="27.移除元素-暴力解法"></p><p>双指针过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>使用双指针，指针i指向想要结果的数组尾。j指针用于判断我们i和j元素是否相等时进行以下操作：1、i=j，i不动，j++；2、i！=j，i++，j++。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-1"><a href="#类似题目-1" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h4><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>不借用其他数组，原地实现很容易就想到双指针。</p><p>双指针i，j<strong>同向</strong>且<strong>同时</strong>跑，如果i元素=0，j就找个不为零的数和i替换，最后结束判断是j跑到了数组尾部。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i,j;i,j&lt;nums.<span class="built_in">size</span>();i++,j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j] == <span class="number">0</span> &amp;&amp; j &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-2"><a href="#类似题目-2" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="844-比较含退格的字符串（快慢指针）"><a href="#844-比较含退格的字符串（快慢指针）" class="headerlink" title="844. 比较含退格的字符串（快慢指针）"></a><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a>（快慢指针）</h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;ac&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;&quot;。</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>因为学会了双指针，结果在这道题倒了。</p><p>这道题使用双指针的<strong>快慢指针</strong>，low指向字符串的有效字符尾部，fast遍历字符串就可以。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function">string <span class="title">result</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span> ;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(fast;fast&lt;a.<span class="built_in">length</span>();fast++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[fast] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; low != <span class="number">0</span>)</span><br><span class="line">                    low--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[fast] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    a[low++] = a[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">substr</span>(<span class="number">0</span>,low);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">result</span>(s) == <span class="built_in">result</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-3"><a href="#类似题目-3" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="977-有序数组的平方（首尾指针）"><a href="#977-有序数组的平方（首尾指针）" class="headerlink" title="977. 有序数组的平方（首尾指针）"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>（首尾指针）</h4><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>认真观察知道数组最左边和最右边的数一定有最大的一个数。可以在首尾设置两个指针，这样比较首尾值的大小，就可以依次确定最大的数。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> pos = j;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]*nums[i] &lt;= nums[j]*nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[pos--] = nums[j]*nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]*nums[i] &gt; nums[j]*nums[j])&#123;</span><br><span class="line">                nums1[pos--] = nums[i]*nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>1、双指针有首尾指针和快慢指针</p><p>2、</p><p>if 、else if 中有比如上面的</p><p>if(a[fast] == ‘#’ &amp;&amp; low != 0)<br>                    low—;<br>else if(a[fast] != ‘#’)<br>                    a[low++] = a[fast];</p><p>a[fast] == ‘#’</p><p>a[fast] != ‘#’</p><p><strong>这两个互斥的，可以考虑换一个顺序：</strong></p><p>if(a[fast] != ‘#’)</p><p>​          a[low++] = a[fast];</p><p>else if(low &gt; 0)</p><p>​          low—;</p><p>这样代码更容易理解一些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Q:看到log（n）就能想到二分查找，但是二分查找里面怎么找到第一个重复元素呢？</p><p>A:我们之前总结过：可以查找到一个元素的最左最右元素，因此，我们只需要查找这个元素的最左元素，再去查找这个元素数值+1的最左元素位置-1即可得到这个元素的最右元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;<span class="comment">//空数组直接返回</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">search</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找要仔细判断。</p><h2 id="扩展：是否可以用最左最右元素找呢"><a href="#扩展：是否可以用最左最右元素找呢" class="headerlink" title="扩展：是否可以用最左最右元素找呢?"></a>扩展：是否可以用最左最右元素找呢?</h2><p>明显是可以的，但是遇到个问题：</p><p>1、找最右元素的时候，需要判断数组越界的情况。（因为r=nums.size()  这是有可能访问到nums【r】的）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//空数组直接返回</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchl</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchr</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchl</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> lside;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">               &#123; r = mid;</span><br><span class="line">               lside=mid;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="type">int</span> lside;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) <span class="comment">// 因为l已经累加了，如果l等于r的情况不能进行判断，那么l=r-1 且 两个数都是target时，mid只会=l，lside也是，我们要的结果是右边的，即r</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;=nums.<span class="built_in">size</span>()) <span class="comment">//杜绝数组越界的情况</span></span><br><span class="line">                <span class="keyword">return</span> lside;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">                lside = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程通信Day6</title>
      <link href="/2023/04/03/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day6/"/>
      <url>/2023/04/03/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day6/</url>
      
        <content type="html"><![CDATA[<h1 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h1><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程 : 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为 init进程，称为 init 进程领养孤儿进程。<br>【 orphan.c 】杀死孤儿进程  kill -9 pid</p><p>僵尸进程<br>僵尸进程: 进程终止 ，父进程 尚未 回收 子进程 残留 资源（ PCB ）存放于内核中 变成僵尸 Zombie 进程 。</p><p>【zoom.c】</p><p><strong>特别注意</strong>，僵尸进程是不能使用kill 命令清除掉的。因为 kill 命令只是用来终止进程的，<br>而僵尸进程已经终止。只能杀死父进程让僵尸进程变为孤儿进程，再由init进程领养，init发现他是僵尸就会自动回收进程。</p><h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>回收子进程退出资源， <strong>阻塞回收任意一个</strong>。</p><pre><code>pid_t wait(int *status)参数：（传出） 回收进程的状态。返回值：成功： 回收进程的pid    失败： -1， errno</code></pre><p>wait 函数可以回收子进程终止信息 。 该函数有三个功能<br>①阻塞等待子进程退出<br>②回收子进程残留资源<br>③获取子进程结束状态 退出原因 。<br>pid_t wait(int *status); 成功：清理掉的子进程 ID ；失败 1 ( 没有子进程）</p><h2 id="waitpid函数：-指定某一个进程进行回收。可以设置非阻塞。-waitpid-1-amp-status-0-wait-amp-status"><a href="#waitpid函数：-指定某一个进程进行回收。可以设置非阻塞。-waitpid-1-amp-status-0-wait-amp-status" class="headerlink" title="waitpid函数：    指定某一个进程进行回收。可以设置非阻塞。            waitpid(-1, &amp;status, 0) == wait(&amp;status);"></a>waitpid函数：    指定某一个进程进行回收。可以设置非阻塞。            waitpid(-1, &amp;status, 0) == wait(&amp;status);</h2><blockquote><p>pid_t waitpid(pid_t pid, int *status, int options)</p><p>参数：<br>    pid：指定回收某一个子进程pid</p><p>​        &gt; 0: 待回收的子进程pid</p><p>​        -1：任意子进程</p><p>​        0：同组的子进程。</p><p>​    status：（传出） 回收进程的状态。</p><p>​    options：WNOHANG 指定回收方式为，非阻塞。</p><p>返回值：</p><p>​    &gt; 0 : 表成功回收的子进程 pid</p><p>​    0 : 函数调用时， 参3 指定了WNOHANG， 并且，没有子进程结束。</p><p>​    -1: 失败。errno</p></blockquote><p>进程退出，只是内存地址空间释放，精准一点就是用户内存地址释放，<strong>内核pcb残留</strong>，所以才需要回收。</p><p>总结：</p><blockquote><p>wait、waitpid    一次调用，回收一个子进程。</p><p>​        想回收多个。while </p></blockquote><h2 id="进程间通信的常用方式，特征："><a href="#进程间通信的常用方式，特征：" class="headerlink" title="进程间通信的常用方式，特征："></a>进程间通信的常用方式，特征：</h2><blockquote><p>管道：简单</p><p>信号：开销小</p><p>mmap映射：非血缘关系进程间</p><p>socket（本地套接字）：稳定</p></blockquote><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>实现原理： 内核借助环形队列机制，使用内核缓冲区实现（4K）。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E7%AE%A1%E9%81%93%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="管道原理图"></p><blockquote><p>特质；    </p><ol><li><p>伪文件 （实质就是内存的一片空间）</p><ol><li>管道中的数据只能一次读取。</li><li>数据在管道中，只能单向流动。</li></ol></li></ol><p>局限性：</p><ol><li>自己写，不能自己读。</li><li><p>数据不可以反复读。</p></li><li><p>半双工通信。</p></li><li><p>血缘关系进程间可用。</p></li></ol></blockquote><h2 id="pipe函数：-创建，并打开管道。"><a href="#pipe函数：-创建，并打开管道。" class="headerlink" title="pipe函数：    创建，并打开管道。"></a>pipe函数：    创建，并打开管道。</h2><blockquote><p>int pipe(int fd[2]);</p><p>参数：    fd[0]: 读端。</p><p>​    fd[1]: 写端。</p><p>返回值： 成功： 0</p><p>​     失败： -1 errno</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="管道通信"></p></blockquote><p>管道的读写行为：</p><blockquote><p>读管道：</p><pre><code>1. 管道有数据，read返回实际读到的字节数。1. 管道无数据：    ​    1）无写端，read返回0 （类似读到文件尾）​    2）有写端，read阻塞等待。</code></pre><p>写管道：</p><pre><code>1. 无读端， 异常终止。 （SIGPIPE导致的）1. 有读端：    ​    1） 管道已满， 阻塞等待​    2） 管道未满， 返回写出的字节个数。</code></pre><p>优点：简单，相比信号，套接字实现进程间通信，简单很多。<br>缺点： 1. 只能单向通信，双向通信需建立 两个管道。</p><ol><li>只能用于<strong>父子、兄弟进程 有共同祖先</strong> 间通信。该问题后来使用 fifo 有名管道解决。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下安装C++编译环境</title>
      <link href="/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/windows%E4%B8%8B%E5%AE%89%E8%A3%85C++%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/windows%E4%B8%8B%E5%AE%89%E8%A3%85C++%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>之前也安装过，但是并没有多明白，现在才知道，学习就是要知道为什么才能知道怎么做。</p><p>1、根据vscode推荐的MSYS2</p><p><em>MSYS2是一个工具和库的集合，为您提供了一个易于使用的环境，用于构建、安装和运行本机Windows软件。</em></p><p>使用这个软件，可以方便管理我们的环境。</p><p>2、使用MSYS2安装Mingw-w64</p><p>安装Mingw-w64工具链（pacman -S —needed base-devel mingw-w64-x86_64-toolchain）。在MSYS2终端中运行pacman命令。<strong>接受默认设置以安装工具链组中的所有成员</strong>。</p><p>3、检查环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line">gdb --version</span><br></pre></td></tr></table></figure><p>4、安装VS代码的<strong>C/C++扩展</strong></p><p>C++是一种已编译的语言，这意味着程序的源代码必须经过翻译（编译）才能在计算机上运行。VSCode首先是一个编辑器，它依赖于命令行工具来完成大部分开发工作流程。C/C++扩展不包括C++编译器或调试器。您需要安装这些工具或使用计算机上已安装的工具。（<strong>意思就是要本地有C++的环境</strong>）</p><ul><li>C++ compiler pre-installed</li><li>C++ debugger pre-installed</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置</title>
      <link href="/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>long（n），二分查找。但是要搞清楚返回的位置</p><p>对于左闭右开的区间：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效</span></span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        ??????</span><br><span class="line">        <span class="comment">// 分别处理如下四种情况</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之前  [0, -1]</span></span><br><span class="line">        <span class="comment">// 目标值等于数组中某一个元素  return middle;</span></span><br><span class="line">        <span class="comment">// 目标值插入数组中的位置 [left, right]，return  right + 1</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1</span></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n; <span class="comment">// 定义target在左闭右开的区间里，[left, right)  target</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在 [middle+1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值的情况，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别处理如下四种情况</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之前 [0,0)</span></span><br><span class="line">        <span class="comment">// 目标值等于数组中某一个元素 return middle</span></span><br><span class="line">        <span class="comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里肯定有很多人犯迷糊，为什么左闭右闭就返回right+1。而左闭右开就返回right？？？？</p><p>鄙人认为：</p><p>左闭右闭二分查找下，最后的结果肯定是【right，left】，而要插入的target在right+1,也就是left的位置。</p><p>相反，左闭右开二分查找下，最后的结果肯定是【left，right】，而且<strong>left==right</strong>，而要插入的target在left,也就是right的位置。</p><p><strong>可以这样理解记忆：</strong></p><p>左闭右开相当于多了一个元素进去，最后要查找过程中left和right肯定在它本该在的元素上。</p><p>左闭右闭就是本来的元素排序，最后结果【right，left】，right在小于targrt位置上，left在大于target上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程Day5</title>
      <link href="/2023/04/02/Linux/Linux%E8%BF%9B%E7%A8%8BDay5/"/>
      <url>/2023/04/02/Linux/Linux%E8%BF%9B%E7%A8%8BDay5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230402100505828.png" alt="内存管理单元MMU"></p><blockquote><p>fork函数：</p><p>pid_t fork(void)</p><p>创建子进程。父子进程各自返回。父进程返回子进程pid。 子进程返回 0.</p><p>getpid();getppid();</p><p>循环创建N个子进程模型。 每个子进程标识自己的身份。<br><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230402102858975.png" alt="循环fork"></p></blockquote><p>父子进程相同：</p><blockquote><p>刚fork后。 data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p></blockquote><p>父子进程不同：</p><blockquote><p>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p></blockquote><p>父子进程共享：</p><blockquote><p><strong>读时共享、写时复制</strong>。———————— 不共享全局变量。</p><p>父子进程共享：1. 文件描述符 2. mmap映射区。</p></blockquote><p>父子进程调式</p><blockquote><p>set follow-fork-mode child 命令设置 gdb 在 fork 之后跟踪子进程。<br>set follow-fork-mode parent 设置跟踪父进程。</p></blockquote><h2 id="execl函数族"><a href="#execl函数族" class="headerlink" title="execl函数族"></a>execl函数族</h2><p>将当前进程的.text 、 .data 替换为所要加载的程序的 .text 、 .data ，然后让进程从新的 .text<br>第一条指令开始执行，但进程 ID 不变，<strong>换核不换壳。</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/exec%E5%87%BD%E6%95%B0.png" alt="exec函数"></p><blockquote><p>int execl(const char <em>path, const char </em>arg, …);<br>int execlp(const char <em>file, const char </em>arg, …);</p><p>execl和execlp的区别就在于execl指定的是执行路径，execlp指定环境变量中的函数名：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230403154604154.png" alt="execl和execlp"></p></blockquote><p>l( 命令行参数列表<br>p( 搜素 file 时使用 path 变量<br>v( 使用命令行参数数组<br>e( 使用环境变量数组 不使用进程原有的环境变量，设置新加载程序运</p><p>小练习：练习：将当前系统中的进程信息，打印到文件中。 exec_ps.c</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件IO-Day4</title>
      <link href="/2023/04/01/Linux/Linux%E6%96%87%E4%BB%B6IO-Day4/"/>
      <url>/2023/04/01/Linux/Linux%E6%96%87%E4%BB%B6IO-Day4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系统调用（内核提供的函数| 内核=操作系统=系统的核心代码）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331193102158.png" alt="系统调用"></p></blockquote><h2 id="open函数："><a href="#open函数：" class="headerlink" title="open函数："></a>open函数：</h2><blockquote><p>int open(char *pathname, int flags)    #include <unistd.h></p><p>参数：<br>    pathname: 欲打开的文件路径名</p><p>​    flags：文件打开方式：    #include <fcntl.h></p><p>​        O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ….</p><p>返回值：<br>    成功： 打开文件所得到对应的 文件描述符（整数）</p><p>​    失败： -1， 设置errno    </p><p>int open(char *pathname, int flags， mode_t mode)        123  775    </p><p>参数：<br>    pathname: 欲打开的文件路径名</p><p>​    flags：文件打开方式：    O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ….</p><p>​    mode: 参数3使用的<strong>前提</strong>， 参2指定了 O_CREAT。    取值8进制数，用来描述文件的 访问权限。 rwx    0664 </p><p>​        创建文件最终权限 = mode &amp; ~umask （<strong>umask是默认文件权限取反</strong>）</p><p>返回值：<br>    成功： 打开文件所得到对应的 文件描述符（整数）</p><p>​    失败： -1， 设置errno    </p></blockquote><h2 id="close函数："><a href="#close函数：" class="headerlink" title="close函数："></a>close函数：</h2><pre><code>int close(int fd);</code></pre><h2 id="错误处理函数：-与-errno-相关。"><a href="#错误处理函数：-与-errno-相关。" class="headerlink" title="错误处理函数：        与 errno 相关。"></a>错误处理函数：        与 errno 相关。</h2><pre><code>printf(&quot;xxx error: %d\n&quot;, errno);char *strerror(int errnum);    printf(&quot;xxx error: %s\n&quot;, strerror(errno));void perror(const char *s);    perror(&quot;open error&quot;);</code></pre><hr><h2 id="read函数："><a href="#read函数：" class="headerlink" title="read函数："></a>read函数：</h2><blockquote><p>ssize_t read(int fd, void *buf, size_t count);</p><p>参数：<br>    fd：文件描述符</p><p>​    buf：存数据的缓冲区</p><p>​    count：缓冲区大小</p><p>返回值：</p><p>​    0：读到文件末尾。</p><p>​    成功；    &gt; 0 读到的字节数。</p><p>​    失败：    -1， 设置 errno</p><p>​    -1： 并且 errno = EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以<strong>非阻塞方式</strong>读一个设备文件（网络文件），并且文件无数据。</p></blockquote><h2 id="write函数："><a href="#write函数：" class="headerlink" title="write函数："></a><strong>write函数：</strong></h2><pre><code>ssize_t write(int fd, const void *buf, size_t count);参数：    fd：文件描述符    buf：待写出数据的缓冲区    count：数据大小返回值：    成功；    写入的字节数。    失败：    -1， 设置 errno</code></pre><h2 id="系统调用和库函数的比较"><a href="#系统调用和库函数的比较" class="headerlink" title="系统调用和库函数的比较"></a>系统调用和库函数的比较</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401111355517.png" alt="系统调用和库函数"></p><p><strong>误区</strong>：系统调用比库函数效率高。</p><p><strong>前提条件</strong>：假如分别用库函数fputc一次写一个字节，和用系统调用一次写一个字节。<strong>结果</strong>：使用库函数会快一些，因为库函数有自己的缓冲区，当缓冲区满再切换到内核区。而系统调用，每次都切换内核区。</p><p><strong>使用环境</strong>：系统调用立刻写入<strong>内核区</strong>，库函数等缓冲区满再写入<strong>内核区</strong>。</p><hr><h2 id="文件描述符："><a href="#文件描述符：" class="headerlink" title="文件描述符："></a>文件描述符：</h2><blockquote><p>PCB进程控制块：本质 <strong>结构体</strong>。</p><p>成员：文件描述符表。</p><p>文件描述符：0/1/2/3/4。。。。/1023     表中可用的最小的。</p><p>0 - STDIN_FILENO</p><p>1 - STDOUT_FILENO</p><p>2 - STDERR_FILENO</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401112552458.png" alt="PCB进程控制块"></p></blockquote><h2 id="阻塞、非阻塞：-是设备文件、网络文件的属性。"><a href="#阻塞、非阻塞：-是设备文件、网络文件的属性。" class="headerlink" title="阻塞、非阻塞：  是设备文件、网络文件的属性。"></a>阻塞、非阻塞：  是<strong>设备文件</strong>、<strong>网络文件</strong>的属性。</h2><blockquote><p>产生阻塞的场景： 读<strong>设备文件</strong>。读网络文件。（读常规文件无阻塞概念：<strong>总有读完的时候</strong>）</p><p>/dev/tty — <strong>终端文件</strong>。</p><p>open(“/dev/tty”, O_RDWR|O_NONBLOCK)    —- 设置 /dev/tty 非阻塞状态。(默认为阻塞状态)</p><p>eg（在file_IO_test下）：</p><p>case1:block_readtty.c | 阻塞读终端</p><p>case2:nonblock_readtty.c | 非阻塞读终端</p><p>case3:nonblock_timeout.c | 非阻塞读终端和等待超时 </p></blockquote><h2 id="fcntl："><a href="#fcntl：" class="headerlink" title="fcntl："></a><strong>fcntl：</strong></h2><p>描述：获取文件状态和设置文件状态</p><p>​    int (int fd, int cmd, …)</p><blockquote><p>int flgs = fcntl(fd,  F_GETFL);</p><p>返回的int类型flgs的位图：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/fcntl%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt="fcntl设置文件属性"></p><p>flgs |= O_NONBLOCK</p><p>fcntl(fd,  F_SETFL, flgs);</p><p>获取文件状态： F_GETFL</p><p>设置文件状态： F_SETFL</p></blockquote><h2 id="lseek函数："><a href="#lseek函数：" class="headerlink" title="lseek函数："></a>lseek函数：</h2><p>描述：设置读写文件偏移量</p><blockquote><p>off_t lseek(int fd, off_t offset, int whence);</p><p>参数：<br>    fd：文件描述符</p><p>​    offset： 偏移量</p><p>​    whence：起始偏移位置： SEEK_SET/SEEK_CUR/SEEK_END</p><p>返回值：</p><p>​    成功：较起始位置偏移量 = <strong>offset+whence</strong></p><p>​    失败：-1 errno</p><p><strong>应用场景：</strong>    </p><blockquote><ol><li><p><strong>文件的“读”、“写”使用同一偏移位置。</strong></p></li><li><p>使用lseek获取文件大小</p></li><li><p>1）使用lseek拓展文件大小：要想使文件大小真正拓展，<strong>必须引起IO操作</strong>：int ret = write(fd, “a”, 1);</p></li></ol><p>2）使用 truncate 函数，直接拓展文件。    int ret = truncate(“dict.cp”, 250);</p></blockquote></blockquote><h3 id="传入参数："><a href="#传入参数：" class="headerlink" title="传入参数："></a>传入参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>同常有const关键字修饰。</p></li><li><p>指针指向有效区域， 在函数内部做读操作。</p></li></ol></blockquote><h3 id="传出参数："><a href="#传出参数：" class="headerlink" title="传出参数："></a>传出参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>在函数调用之前，指针指向的空间可以无意义，但必须有效。</p></li><li><p>在函数内部，做写操作。</p></li><li><p>函数调用结束后，充当函数返回值。</p></li></ol></blockquote><h3 id="传入传出参数："><a href="#传入传出参数：" class="headerlink" title="传入传出参数："></a>传入传出参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>在函数调用之前，指针指向的空间有实际意义。</p></li><li><p>在函数内部，先做读操作，后做写操作。</p></li><li><p>函数调用结束后，<strong>充当</strong>函数返回值。比如int aaa(int <em>p, struct stat </em>p2, strcut student *p3);函数参数都可以充当函数返回值。</p></li></ol></blockquote><h2 id="目录项和Inode"><a href="#目录项和Inode" class="headerlink" title="目录项和Inode"></a>目录项和Inode</h2><p>一个文件对应一个FCB，FCB就是目录项。多个FCB组成一个目录。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401135720597.png" alt="目录项和Inode"></p><h2 id="stat-lstat-函数："><a href="#stat-lstat-函数：" class="headerlink" title="stat/lstat 函数："></a>stat/lstat 函数：</h2><p>描述：查看文件信息</p><blockquote><p>int stat(const char <em>path, struct stat </em>buf);</p><p>参数：<br>    path： 文件路径</p><p>​    buf：（传出参数） 存放文件属性。</p><p>返回值：</p><p>​    成功： 0</p><p>​    失败： -1 errno</p><p>获取文件大小： buf.st_size</p><p>获取文件类型： buf.st_mode</p><p>获取文件权限： buf.st_mode</p><p>符号穿透：stat会。lstat不会。</p><p>符号穿透：指我创建的软链接指向哪个文件，在stat查看文件类型时，会显示那个文件的信息而不是软连接文件的信息。 </p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>使用stat获取文件类型或者权限时，参考下面位图</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%BD%8D%E5%9B%BE.png" alt="文件权限位图"></p></blockquote><h2 id="link-unlink"><a href="#link-unlink" class="headerlink" title="link/unlink:"></a>link/unlink:</h2><blockquote><p>描述：link就是创建一个FCB，unlink就是删除一个FCB（文件目录项）</p><p>unlink需要注意的是：尽管unlink了文件，但要等到<strong>所有</strong>打开该文件的进程关闭了该文件，系统才会挑时间将文件释放。俗话就是还没删掉inode，等打开文件进程关闭才等时机删。</p></blockquote><p>隐式回收。</p><blockquote><p>当进程结束运行时，系统会自动关闭内存空间。</p><p>一个进程的文件描述符表最多也就能打开1024个文件，如果是服务器一直不关掉进程，系统就不会隐式回收。<strong>这就是我们说要及时free的原因。</strong></p></blockquote><h2 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h2><p>描述：查看符号链接文件本身的内容。</p><h2 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h2><p>描述：重命名文件。</p><hr><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h2><p>根据传入的目录名打开一个目录（库函数）</p><h2 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h2><p>关闭打开的目录（库函数）</p><h2 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h2><p>读取目录（库函数）</p><hr><p>dup 和 dup2：</p><blockquote><p>int dup(int oldfd);        文件描述符复制。</p><p>​    oldfd: 已有文件描述符</p><p>​    返回：新文件描述符。</p><p>int dup2(int oldfd, int newfd); 文件描述符复制。重定向。</p><p>将oldfd文件描述符拷贝给newfd，所以它们指向同一个文件。</p></blockquote><p>fcntl 函数实现 dup：</p><blockquote><p>int fcntl(int fd, int cmd, ….)</p><p>cmd: F_DUPFD</p><p>参3:      被占用的，返回最小可用的文件描述符。</p><p>​    未被占用的， 返回=该值的文件描述符。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习路线</title>
      <link href="/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>个人推荐一个java框架路线。</p><p> 1、首先了解一下javaweb（servlet）</p><p> 2、入门ssm </p><p>3、了解springboot </p><p>4、了解常见组件springcloud或者dubbo&amp;;zk </p><p>5、中间件等 redis和消息队列  </p><p>6、上手项目，在项目中巩固技术栈 </p><p>更多java面试干货和实战项目推荐，可以关注我的公众号：代码界的小白，希望对你有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程Day3</title>
      <link href="/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/"/>
      <url>/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/</url>
      
        <content type="html"><![CDATA[<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>gdb调试工具：   大前提：程序是你自己写的。  —-逻辑错误</p><p>基础指令：<br>    -g：使用该参数编译可以执行文件，得到调试表。</p><pre><code>gdb ./a.outlist： list 1  列出源码。根据源码指定 行号设置断点。b：    b 20    在20行位置设置断点。run/r:    运行程序n/next: 下一条指令（会越过函数）s/step: 下一条指令（会进入函数） |  进入系统函数会找不到文件，使用until+行号回到调试点 | 或者finish结束函数调用p/print：p i  查看变量的值。continue：继续执行断点后续指令。finish：结束当前函数调用。 quit：退出gdb当前调试。</code></pre><p>其他指令：</p><pre><code>run：使用run查找段错误出现位置。set args： 设置main函数命令行参数 （在 start、run 之前）run 字串1 字串2 ...: 设置main函数命令行参数info b: 查看断点信息表b 20 if i = 5：    设置条件断点。ptype：查看变量类型。display：设置跟踪变量undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</code></pre><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt：列出当前程序正存活着的栈帧。</span><br><span class="line"></span><br><span class="line">frame： 根据栈帧编号，切换栈帧。</span><br></pre></td></tr></table></figure><p>切换栈帧即可访问函数调用栈帧中的数据</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331112614337.png" alt="栈帧"></p></blockquote><hr><blockquote><p>makefile： 管理项目。</p><blockquote><p>命名：makefile     Makefile  —- make 命令</p><p>1 个规则：</p><p>​    目标：依赖条件<br>​    （一个tab缩进）命令</p><pre><code> 1. **目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标** 2. **依赖条件如果不存在，找寻新的规则去产生依赖条件。**</code></pre><p>（make会把makefile的第一行规则作为终极目标）</p><p>ALL：指定 makefile 的终极目标。</p><p><strong>小细节</strong>：为什么要把makefile写的复杂？</p><p>例如：我修改了一个add的源码，而导致我所有的源文件都要跟着编译一遍，这是非常耗时的。如果写成如下的样式，make会根据<strong>目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标</strong>原则，只执行<code>gcc -v add.c -o hello.o 和 gcc hello.o add.o sub.o div1.o -o a.out.</code></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331164549575.png" alt="image-20230331164549575"></p><p>2 个函数：</p><p>​    src = $(wildcard ./*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。  src = add.c sub.c div1.c </p><p>​    obj = $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj = add.o sub.o div1.o</p><p>clean:    (没有依赖)</p><pre><code>make clean -n | -n表示提示不执行-rm -rf $(obj) a.out    “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</code></pre><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331172250751.png" alt="使用2个函数"></p><p>3 个自动变量：</p><p>​    $@: 在规则的<strong>命令中</strong>，表示<strong>规则中的目标</strong>。</p><p>​    $^: 在规则的<strong>命令中</strong>，表示<strong>所有依赖条件</strong>。</p><p>​    $&lt;: 在规则的<strong>命令中，</strong>表示<strong>第一个依赖条件</strong>。如果将该变量应用在<strong>模式规则</strong>中，它可将依赖条件列表中的依赖<strong>依次</strong>取出，套用模式规则。</p><p>模式规则：</p><p>​    %.o:%.c<br>​       gcc -c $&lt; -o %@</p></blockquote><p>使用这么多函数和自动变量的原因是<strong>方便扩展</strong></p><p><strong>不需要修改makefile</strong>即可扩展程序功能函数。</p><blockquote><p>静态模式规则：（指定模式规则下使用的obj）（obj可以有多个，可有obj函数的特性看出）</p><p>​    $(obj):%.o:%.c<br>​       gcc -c $&lt; -o %@    </p><p>伪目标：（不管重名与否都执行）</p><p>​    .PHONY: clean ALL</p><p>参数：<br>    -n：模拟执行make、make clean 命令。</p><p>​    -f：指定文件执行 make 命令。                make -f filename  clean          (xxx.mk通常是makefile文件)</p></blockquote></blockquote><pre><code>作业：编写一个 makefile 可以将其所在目录下的所有独立 .c 文件编译生成同名可执行文件。</code></pre><p>tips：makefile中的%和*的区别：</p><p>%在*的基础上，多了一个匹配的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xmind激活亲测有效（23/3/30）</title>
      <link href="/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/"/>
      <url>/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Xmind激活亲测有效（23-3-30）"><a href="#Xmind激活亲测有效（23-3-30）" class="headerlink" title="Xmind激活亲测有效（23/3/30）"></a>Xmind激活亲测有效（23/3/30）</h1><p>下载资源</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330095543117.png" alt="image-20230330095543117"></p><p>双击安装包，程序自动安装在C:\Program Files\XMind下</p><p>替换</p><p>C:\Program Files\XMind\resources下的app.asar,打开xmind即可激活。</p>]]></content>
      
      
      <categories>
          
          <category> XMmid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XMind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程Day2</title>
      <link href="/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/"/>
      <url>/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>vim的三种工作模式</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330114045599.png" alt=""></p><p>vim的快捷键</p><blockquote><p>跳转到指定行：</p><pre><code> 1. 88G （命令模式） 2. :88  (末行模式)</code></pre><p>跳转文件首：</p><p>​    gg （命令模式）</p><p>跳转文件尾：</p><p>​    G（命令模式）</p><p>自动格式化程序：</p><p>​    gg=G（命令模式）</p><p>大括号对应：</p><p>​    % （命令模式）</p><p>光标移至行首：</p><p>​    0 （命令模式）执行结束，工作模式不变。</p><p>光标移至行尾：</p><p>​    $ （命令模式）执行结束，工作模式不变。</p><p>删除单个字符：</p><p>​    x （命令模式）执行结束，工作模式不变。</p><p>替换单个字符：</p><p>​    将待替换的字符用光标选中， r （命令模式），再按欲替换的字符</p><p>删除一个单词：</p><p>​    dw（命令模式）光标置于单词的首字母进行操作。</p><p>删除光标至行尾：</p><p>​    D 或者 d$（命令模式）</p><p>删除光标至行首：</p><p>​    d0 （命令模式）</p><p>删除指定区域：</p><p>​    按 V （命令模式）切换为 “可视模式”，使用 hjkl挪移光标来选中待删除区域。  按 d 删除该区域数据。</p><p>剪切指定1行：</p><p>​    在光标所在行，按 dd （命令模式）</p><p>剪切指定N行：</p><p>​    在光标所待删除首行，按 Ndd （命令模式）</p><p>复制一行：</p><p>​    yy</p><p>粘贴：<br>    p：向后、P：向前。</p><p>查找：</p><pre><code> 1. 找 设想 内容：命令模式下， 按 “/” 输入欲搜索关键字，回车。使用 n 检索下一个。 2. 找 看到的内容：命令模式下，将光标置于单词任意一个字符上，按 “*”/ “#” </code></pre><p>单行替换：</p><p>​    将光标置于待替换行上， 进入末行模式，输入 :s /原数据/新数据</p><p>通篇替换：</p><p>​    末行模式， :%s /原数据/新数据/g   g:不加，只替换每行首个。   </p><p>指定行的替换：</p><p>​    末行模式， :起始行号，终止行号s /原数据/新数据/g   g:不加，只替换每行首个。</p><p>​        :29,35s /printf/println/g</p><p>撤销、反撤销：</p><p>​    u、ctrl+r（命令模式）</p><p>分屏：（末行模式）<br>    sp：横屏分。 Ctrl+ww 切换。</p><p>​    vsp：竖屏分。Ctrl+ww 切换。</p><p>跳转至 man 手册：</p><p>​    将光标置于待查看函数单词上，使用 K（命令模式）跳转。 指定卷， nK</p><p>查看宏定义：</p><p>​    将光标置于待查看宏定义单词上，使用 [d 查看定义语句。（命令模式）</p><p>在末行模式执行shell命令：</p><p>​    :!命令        :! ls -l<br>​    :! gcc hello.c -o hello100  | !./hello100</p><p>​    <strong>gcc hello.c -o hello = gcc -c hello.c -o hello.o + gcc hello.o -o a.out</strong></p><p>​    :! g++ hello.cpp | !./a.out</p></blockquote><hr><p>gcc编译：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/gcc%E7%BC%96%E8%AF%914%E6%AD%A5%E9%AA%A4.png" alt="gcc编译4步骤"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4步骤： 预处理、编译、汇编、连接。</span><br><span class="line"></span><br><span class="line">-I：指定头文件所在目录位置。</span><br><span class="line"></span><br><span class="line">-c：只做预处理、编译、汇编。得到 二进制 文件！！！</span><br><span class="line"></span><br><span class="line">-g：编译时添加调试语句。 主要支持 gdb 调试。</span><br><span class="line"></span><br><span class="line">-Wall： 显示所有警告信息。</span><br><span class="line"></span><br><span class="line">-D：向程序中“动态”注册宏定义。   ifdef ... #define NAME VALUE</span><br><span class="line"></span><br><span class="line">-l: 指定动态库名</span><br><span class="line"></span><br><span class="line">-L: 指定动态库路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.png" alt="动态库和静态库"></p><blockquote><blockquote><p>静态库制作及使用步骤：</p><p><strong>（-o 取名）</strong></p><pre><code>1. 将 .c 生成 .o 文件​    gcc -c add.c -o add.o2. 使用 ar 工具制作静态库    ar rcs  lib库名.a  add.o sub.o div.o3. 编译静态库到可执行文件中：    gcc test.c lib库名.a -o a.out</code></pre><p>头文件守卫：<strong>防止头文件被重复包含</strong> </p><p> implicit declaration<strong>隐式声明</strong>，这是c语言自己会声明的东西，只会做int add（int ,int）之类的声明，如果库里面有类似viod就会报错。<br>解决办法：自己在源代码中声明函数，为了复用性，我们通常用下面的头文件守卫：</p><pre><code>#ifndef _HEAD_H_#define _HEAD_H_......#endif</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后在.c中引入.h</span><br><span class="line">项目发布：</span><br><span class="line">gcc test.c ./lib/libmylib.a -o a.out -I ./inc</span><br></pre></td></tr></table></figure><p>动态库制作及使用：</p></blockquote><ol><li>将 .c 生成 .o 文件， （<strong>生成与位置无关的代码 -fPIC</strong>）</li></ol><p>​    gcc -c add.c -o add.o -fPIC         （<strong>在动态库函数后生成PIC，程序运行时再链接</strong>）</p><ol><li><p>使用 gcc -shared 制作动态库</p><p> gcc -shared -o lib库名.so    add.o sub.o div.o</p></li><li><p>编译可执行程序时，指定所使用的动态库。  -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。</p><p> gcc test.c -o a.out -lmymath -L./lib -I./inc</p></li><li><p>运行可以执行程序 ./a.out <strong>出错</strong>！！！！ —- ldd a.out —&gt; “not found” （<strong>ldd 查看程序链接信息</strong>）</p><p> error while loading shared libraries: libxxx.so: cannot open shared object file: No such file or directory</p><p> 原因：</p><pre><code> 链接器：    工作于链接阶段， 工作时需要 -l 和 -L （**执行数据段合并和地址回填**）| </code></pre><p> ​    动态链接器：    工作于程序运行阶段，工作时需要提供动态库所在固定目录位置。</p><p> 解决方式：</p><p> ​    【1】 通过环境变量：  export LD_LIBRARY_PATH=动态库路径</p><p> ​        ./a.out 成功！！！  （临时生效， 终端重启环境变量失效）改变的是进程的环境变量</p><p> ​    【2】 永久生效： 写入 终端配置文件。  .bashrc  建议使用绝对路径。eg:/home/luo/file/dynamicLab/lib</p><p> ​                1.vi ~/.bashrc</p><p> ​                2.写入 export LD_LIBRARY_PATH=动态库路径  保存</p><p> 3）. .bashrc/  source .bashrc / 重启 终端  —-&gt; 让修改后的.bashrc生效</p><p> 4）./a.out 成功！！！ </p><p> 【3】 拷贝自定义动态库 到 /lib (标准C库所在目录位置)</p><p> 【4】 配置文件法</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）sudo vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">2）写入 动态库绝对路径  保存</span><br><span class="line"></span><br><span class="line">3）sudo ldconfig -v  使配置文件生效。</span><br><span class="line"></span><br><span class="line">4）./a.out 成功！！！--- 使用 ldd  a.out 查看程序链接情况</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>数据段合并</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331103821681.png" alt="数据段合并"></p><p>其他：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi显示readonly</span><br><span class="line">退出两个办法</span><br><span class="line">1：wq！</span><br><span class="line">2：w !sudo tee %</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04 中Drag and drop is not supported问题</title>
      <link href="/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu22-04-中Drag-and-drop-is-not-supported问题"><a href="#Ubuntu22-04-中Drag-and-drop-is-not-supported问题" class="headerlink" title="Ubuntu22.04 中Drag and drop is not supported问题"></a>Ubuntu22.04 中Drag and drop is not supported问题</h1><p>解决方法<br>先在terminal中安装这两个程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-prefs</span><br><span class="line">sudo apt install nemo</span><br></pre></td></tr></table></figure><p>左下角的application中选择extension， 将Desktop icons NG 选项关闭</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330202439439.png" alt="image-20230330202439439"></p><p>左下角的application中选择startup application preference， 添加如下命令</p><p><img src="https://img-blog.csdnimg.cn/1df319278b124816a90579738f0c6995.png" alt="img"></p><p>将程序重启后即可在host和vm间进行拖动传输</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu22.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo：更换电脑，如何继续写博客</title>
      <link href="/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo：更换电脑，如何继续写博客"><a href="#hexo：更换电脑，如何继续写博客" class="headerlink" title="hexo：更换电脑，如何继续写博客"></a>hexo：更换电脑，如何继续写博客</h1><details green><summary> 哔哔 </summary>              <div class='content'>              <p>先提一句：</p><p>如果想要在百度收录，需要在百度站长验证一下，最后卡在验证环境如下：明显是访问不到外网。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330190044308.png" alt="image-20230330190044308"></p>              </div>            </details><p>1.将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>将这些目录放到一个目录下，如：hexo／</p><p>2.在你的新电脑上首先配置hexo环境：安装Node.js<br>3.安装hexo，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>4.安装好之后，进入hexo／目录<br>5.模块安装，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>6.部署，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程Day1</title>
      <link href="/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/"/>
      <url>/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>学习了一些命令，这些命令记住常用的，备份难记的。</p><p>常用的比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径中，cd ..、cd .、 cd、 cd - 的使用。</span><br><span class="line">./ 本级目录 ../上一级目录</span><br><span class="line"></span><br><span class="line">删除文件rm</span><br><span class="line">rm -rf 递归强制删除</span><br><span class="line">mv 文件重命名|移动文件</span><br><span class="line">mv和cp的区别</span><br><span class="line">1、功能上的区别</span><br><span class="line">mv：用户可以使用该命令为文件或目录重命名或将文件由一个目录移入另一个目录中（该文件从原来的文件夹中消失）。</span><br><span class="line"></span><br><span class="line">cp: 该命令的功能是将给出的文件或目录拷贝到另一文件或目录中（该文件仍保存在原文件夹中）。</span><br><span class="line"></span><br><span class="line">2、从inode角度来区分</span><br><span class="line">mv：会将存储于indoe索引节点上的文件元信息也移动到新文件中。</span><br><span class="line"></span><br><span class="line">cp : 只会复制文件数据，不会复制inode索引节点上的文件元信息。</span><br><span class="line"></span><br><span class="line">创建用户sudo adduser 新用户名--- useradd</span><br><span class="line">删除用户sudo deluser 用户名</span><br><span class="line">find找文件</span><br><span class="line">ln创建软链接和硬链接的方式和属性</span><br><span class="line">chmod修改权限的两种方式</span><br><span class="line">grep查找文件内容</span><br><span class="line">压缩文件tar、rar、zip等命令---gzip and bzip with tar:因为gzip和bzip不能打包文件夹多个文件。</span><br><span class="line">tar zcvf filename file1 file2</span><br><span class="line">z:gzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">tar jcvf filename file1 file2</span><br><span class="line">z:bzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">解压</span><br><span class="line">tar zxvf filename</span><br><span class="line">tar jxvf filename</span><br><span class="line"></span><br><span class="line">rar a -r filename file</span><br><span class="line">unrar x filename</span><br><span class="line"></span><br><span class="line">zip -r filename file</span><br><span class="line">unzip filename</span><br><span class="line"></span><br><span class="line">安装软件卸载软件的方法。</span><br><span class="line">sudo aptitude show softname 查看软件安装信息</span><br></pre></td></tr></table></figure><p>文件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件。</span><br></pre></td></tr></table></figure><p>系统目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin：存放二进制可执行文件</span><br><span class="line">boot：存放开机启动程序</span><br><span class="line">dev：存放设备文件： 字符设备、块设备</span><br><span class="line">home：存放普通用户</span><br><span class="line">etc：用户信息和系统配置文件 passwd、group</span><br><span class="line">lib：库文件：libc.so.6</span><br><span class="line">root：管理员宿主目录（家目录）</span><br><span class="line">usr：用户资源管理目录 unix software resource</span><br></pre></td></tr></table></figure><p>简单的快捷键</p><p>tab显示提示、ctrl-a、ctrl-e、ctrl-u、ctrl-Alt-t。</p><p>细节的内容还请再看一遍视频讲解和讲义。</p><hr><p>学习完后写的五子棋游戏服务器，匹配游戏，断线重连，连接mysql数据库，欢迎大家一起学习 <a href="https://github.com/ChenVv-hong/Gobang">https://github.com/ChenVv-hong/Gobang</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作手册（给实验室同学）</title>
      <link href="/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/"/>
      <url>/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/</url>
      
        <content type="html"><![CDATA[<h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><p>1、安装GIT</p><p><a href="https://blog.csdn.net/adminsir0/article/details/126355313">(3条消息) git安装教程</a>（一直next就行）</p><p>2、注册远程仓库账号</p><p>打开<a href="https://github.com/">GitHub</a>，注册自己账号</p><p>不翻墙的话，注册<a href="https://gitee.com/">Gitee</a>（这个文档展示gitee）</p><p>3、本地创建任意文件夹，鼠标右键选择git bush</p><p>4、配置用户，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>5、生成SSH密钥        </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>进入C:\Users\Administrator.ssh目录下，查看生成的SSH密钥，</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181525633.jpeg" alt="img" style="zoom:50%;" /></p><p>复制id_ras.pub里面的字符串，在gitee设置中的SSH公钥中添加密钥。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181527256.png" alt="image-20221218152744139"></p><p>6、创建一个文件，在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>7、命令行输入：git init </p><p>8、命令行输入：git add .</p><p>9、命令行输入：git commit -m “123”</p><p>10、命令行输入：git remote add origin <strong>url</strong>  |  url选择你的远程仓库，比如<strong>gitee</strong>创建完仓库后，会有这个地址，我们选择SSH链接就行。</p><p>例如：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181520074.png" alt="image-20221218152045988"></p><p>11、命令行输入：git push -u origin “master”</p><p>显示成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小路径和</title>
      <link href="/2022/12/16/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2022/12/16/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212162305580.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是一道简单的动态规划问题，为什么我最开始的时候没有想到呢？最开始想到的是遍历每一种情况，求其最小值但是遍历不了每一种情况。因为没有经过系统的练习。</p><p>动态规划问题都需要有个中间数组dp。通常用于解决最大最小问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();<span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码还是需要经过系统的学习才行，下次学习的时候尽量把一个专题的东西学完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径</title>
      <link href="/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212121030018.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>这是一个高中的排列组合的一个数学题。</p><script type="math/tex; mode=display">C_{m+n-2}^{m-1}=\left(\begin{array}{c}m+n-2 \\m-1\end{array}\right)=\frac{(m+n-2)(m+n-3) \cdots n}{(m-1) !}=\frac{(m+n-2) !}{(m-1) !(n-1) !}</script><p>用算法实现这个等式就可以了。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>dfs递归暴力求解，具体实现还不熟练，直接贴代码，（超时）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h5><p>动态规划，每个答案都是前面两个答案的综总和。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划和dfs需要系统的学习，不然真的太模糊了。。。</p><p>就比如爬梯子这道题。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>动态规划方程就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2];</span><br></pre></td></tr></table></figure><p>需要注意的是：这种动态规划都可以用递归来做，但是递归的空间复杂度太高了， 通常是会超时的。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="/2022/12/11/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
      <url>/2022/12/11/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开始我是想直接遍历，依次比较两个数组是否合并，能合并就push到目标二维向量res中，这样操作就导致最多只有两个数组能合并，忽略了三个及以上的数组合并的情况，所以最好的做法就是先把第一个数组push到res中，再逐个遍历对比intervals中的数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//为什么不能放在pubilc中？</span></span><br><span class="line"><span class="comment">// 重载的排序函数不能放在 public 下，这是因为重载的排序函数本质上是一个类内部的函数，它的主要作用是为类的对象提供排序功能。而 public 下的函数是可以在类的内部和外部访问的，因此不能将重载的排序函数放在 public 下。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),compare1);</span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; intervals.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(res[j][<span class="number">0</span>]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(res[j][<span class="number">1</span>],intervals[i][<span class="number">1</span>]));</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>通过chatGPT它帮我优化了一下代码。</p><p>使用了拉姆达表达式，更熟练的使用向量vector，很精彩</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">// Use a deque to store the merged intervals</span></span><br><span class="line">        deque&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort the intervals by their start time</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the first interval to the deque</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate through the remaining intervals</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// If the end time of the last interval in the deque is greater than</span></span><br><span class="line">            <span class="comment">// or equal to the start time of the current interval, merge them</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp = &#123; res.<span class="built_in">back</span>()[<span class="number">0</span>], <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]) &#125;;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise, just add the current interval to the deque</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the merged intervals as a vector</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码前，先想好思路，不然改代码会改得头大，也会阻塞我们的思路。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃游戏</title>
      <link href="/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>目前想到两种方法，一种是贪心，就是一直走下去，看我最远能走多远，如果最远的距离大于数组长度，则必可达。</p><p>还有一种是找规律，我们可以发现，如果数组非0，那么必可达终点，所以我们只需要查看0的元素是否可以跳过去。逆向遍历，遇到0，再逆向遍历看看有没有元素能跳过这个0，如果不能则不可达，如果能继续逆向遍历到达终点，那么就是可达。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">// 判断我从开始位置能到的最远距离与数组的长度做对比，最远位置比数组长度长，则能到达。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlength = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=maxlength)</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength , i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找规律</span></span><br><span class="line"><span class="comment">// 发现如果数组元素都大于0，则必可达。</span></span><br><span class="line"><span class="comment">// 只需要判断元素中=0的元素之前是否有元素可以跳过这个0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+nums[j] &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和动态规划回溯（dfs）是重点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工作流</title>
      <link href="/2022/12/05/hexo/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
      <url>/2022/12/05/hexo/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="git工作流："><a href="#git工作流：" class="headerlink" title="git工作流："></a>git工作流：</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041100978.png" alt="image-20221204110021821"></p><p>出现的问题：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041409760.png" alt="image-20221204140937710"></p><p>遇到这种情况说明，是因为虽然使用的是git push命令，但是本质还是http。（github在21年为了安全，取消账号密码身份验证（http就需要账号密码登录验证），而使用令牌(Token)的身份验证）</p><p>我们来验证是否可以连接github显示没有问题。发现连接是没有问题的。</p><p>这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041401785.png" alt="image-20221204140109692"></p><p>原因&amp;解决<br>虽然是用 git 命令push，但本质上仍然是 https，所以不允许提交。<br>使用 git remote -v 查看现在的远程 url 地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/jack8luo/-.git (fetch)</span><br><span class="line">originhttps://github.com/jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>使用下面的改 url 链接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:jack8luo/-.git   </span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                                                 </span><br><span class="line">origingit@github.com:jack8luo/-.git (fetch)</span><br><span class="line">origingit@github.com:jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>已经改为 ssh 了。现在可以正常 push 了。</p><p>测试：github不与shell交互，这个shell指的就是我们的命令行窗口了。发现使用git的工具bash也出现http连接出错。</p><p>或许也可以尝试重新配置ssh密钥连接一下试试。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041434804.png" alt="img"></p><p>windows下创建文件使用echo ” text “ &gt; 1.txt</p><p>linux使用touch 1.txt</p><p>在windows下使用touch需安装touch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install touch-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遇见：</p><h2 id="spwan-failed问题"><a href="#spwan-failed问题" class="headerlink" title="spwan failed问题"></a>spwan failed问题</h2><h3 id="可以考虑连接手机热点解决，也可以修改自己的端口：443"><a href="#可以考虑连接手机热点解决，也可以修改自己的端口：443" class="headerlink" title="可以考虑连接手机热点解决，也可以修改自己的端口：443."></a>可以考虑连接手机热点解决，也可以修改自己的端口：443.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Push failed</span><br><span class="line">Kex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22</span><br><span class="line">Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>一般情况下是以上错误都是因为挂着VPN导致端口冲突</p><p>目前遇到两类情况，解决办法如下。</p><p>1 网络本身无vpn，使用ShadowsocksR等工具科学上网<br>退出ShadowsocksR即可<br>缺点：访问github会变慢，毕竟把vpn关掉了。如果开vpn本身就是为了更快速的访问github，那这样的操作就很费劲，每次和远程仓库交互都要关掉vpn，搞完再打开，推荐2.1。<br>2 网络本身挂载vpn，如openwrt上安装了ShadowsocksR<br>解决办法有两种（推荐第一种）<br>2.1 修改项目目录中隐藏文件夹 .git 内的 config 文件<br>将 Project/.git/config 文件中ssh格式的url，修改为github仓库中https格式的url。如：</p><p>url = <a href="https://github.com/username/SpringBootWebTest.git">https://github.com/username/SpringBootWebTest.git</a></p><p>因为开着vpn，代理端口走22；同时git的ssh一般也使用22端口，这样造成冲突；而git的https一般使用443端口，不会产生冲突。</p><p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用https可以很好地绕开安全限制使用git；但是对于ssh来说，企业防火墙很可能没打开22端口。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转图像</title>
      <link href="/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027984.png" alt="image-20221201202701906"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027198.png" alt="image-20221201202722150"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>顺时针旋转90°==先水平旋转，再主对角线旋转</p><p>这就类似于把一步旋转操作拆分成了两步操作，从而化简了算法的复杂性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="type">int</span> j = matrix.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][k],matrix[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>就是简单一数学题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2022/11/30/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/11/30/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>全排列的问题做过很多次，但是这次还是没写出来，在这里总结一下。</p><p>全排列就是深度搜索dfs，也叫做回溯算法，相同的题目还有<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>。回溯深搜都是暴力算法，不同于遍历，深搜可以更有效地暴力。</p>              </div>            </details><p>在这里介绍一下c++的next_permutation(nums.begin(), nums.end())函数。这个函数返回的是bool，在函数执行中会将nums的下一次排列换成nums。</p><p>比如这道题的解法一就用到了这个函数</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似的题可以看<a href="https://blog.luoxiaohei.co/2022/10/17/31. 下一个排列/">力扣hot100—031 下一个排列 | 骆小黑 (luoxiaohei.co)</a></p><hr><h2 id="暴力回溯"><a href="#暴力回溯" class="headerlink" title="暴力回溯"></a>暴力回溯</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;bool&gt; tag;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tag.resize(n, false);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (temp.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!tag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                tag[i] = true;</span><br><span class="line">                dfs(nums);</span><br><span class="line">                temp.pop_back();//递归完一个结果123之后清理temp和tag</span><br><span class="line">                tag[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似题可以看<a href="https://blog.luoxiaohei.co/2022/11/27/ 组合总和/">组合总和 | 骆小黑 (luoxiaohei.co)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油！未来可期！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找总结</title>
      <link href="/2022/11/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/"/>
      <url>/2022/11/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h1><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>​        最近做了很多二分查找的算法题，这里来整理一下学到了什么。</p><p>​        做到有关二分查找的题目</p><p>​    -     <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>​    -     <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>​    -     <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>              </div>            </details><p>针对34题总结了一下二分查找的一些细节。</p><p>普通的二分查找很简单。有左闭右闭<strong>两种写法</strong>。</p><p>区别在于r=size（）还是=size（）-1  |  【left，right】【left，right）</p><p>r=size（）左闭右开：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l=<span class="number">0</span>;</span><br><span class="line">r=size（）</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[mid] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; val)</span><br><span class="line">right = mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &lt; val)</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>r=size()-1左闭右闭：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l=0;</span><br><span class="line">r=size（）-1；</span><br><span class="line">while(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">int mid = (left+right)/2;</span><br><span class="line">if(A[mid] == val)</span><br><span class="line">            return mid;</span><br><span class="line">else if(A[mid] &gt; val)</span><br><span class="line">right = mid-1;</span><br><span class="line">else if(A[mid] &lt; val)</span><br><span class="line">left = mid+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="更细节的操作："><a href="#更细节的操作：" class="headerlink" title="更细节的操作："></a>更细节的操作：</h2><p>若数组中有很多个target，如何找到第一个和最后一个呢？</p><p>普通的二分就很随机了，会随机给你返回一个target。</p><p>所以我们做出如下更改：把a[mid] == target 和 a[mid] &gt; target 合并。就可以找到第一个，从a[mid] &gt; target 就能知道，我们在往左移。</p><p>同理 ：把a[mid] == target 和 a[mid] &lt; target 合并。就可以找到最后一个，从a[mid] &lt; target 就能知道，我们在往右移。</p><h2 id="找到-target的第一个数"><a href="#找到-target的第一个数" class="headerlink" title="找到=target的第一个数"></a>找到=target的第一个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的第一个数</span></span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = nums.<span class="built_in">size</span>();<span class="comment">//左闭右开</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的第一个数</span></span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="type">int</span> lside;</span><br><span class="line">      <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//左闭右闭</span></span><br><span class="line">      <span class="type">int</span> mid;</span><br><span class="line">      <span class="keyword">while</span> (l&lt;=r)<span class="comment">//左闭右闭</span></span><br><span class="line">      &#123;</span><br><span class="line">          mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">          <span class="keyword">if</span>(nums[mid]&gt;=target) </span><br><span class="line">          &#123; </span><br><span class="line">              r = mid<span class="number">-1</span>;</span><br><span class="line">              lside=mid;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              l = mid+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="找到-target的最后一个数"><a href="#找到-target的最后一个数" class="headerlink" title="找到=target的最后一个数"></a>找到=target的最后一个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//找到=target的最后一个数</span></span><br><span class="line">   <span class="comment">//左闭右闭</span></span><br><span class="line">   <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//左闭右闭</span></span><br><span class="line"><span class="type">int</span> lside;</span><br><span class="line">   <span class="keyword">while</span> (l &lt;= r) </span><br><span class="line">   &#123;</span><br><span class="line">       mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (a[mid] &lt;= target)</span><br><span class="line">       &#123;</span><br><span class="line">           l = mid+<span class="number">1</span>;  </span><br><span class="line">           lside = mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           r = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的最后一个数</span></span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> r = nums.<span class="built_in">size</span>();<span class="comment">//左闭右开</span></span><br><span class="line">      <span class="type">int</span> mid;</span><br><span class="line">      <span class="type">int</span> lside;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r)  <span class="comment">//左闭右开</span></span><br><span class="line">      &#123;</span><br><span class="line">          mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">          &#123;</span><br><span class="line">              l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">              lside = mid;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              r = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> lside;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/20230404142438.png" alt="总结"></p><p>好啦，我要去打怪兽了，掰掰</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合总和</title>
      <link href="/2022/11/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2022/11/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p>candidates 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这个题目和背包问题是一样的，采用的dfs的回溯算法。有张图就能很好理解了。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211272122380.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = candidates.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rside;</span><br><span class="line">        <span class="comment">// 先二分查找小于等于target值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                rside = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            rside = r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, <span class="number">0</span>, rside);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;combine, <span class="type">int</span> idx,<span class="type">int</span> rside)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; rside)  <span class="comment">//剪枝，当idx&gt;target时，就不用继续执行了。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, idx + <span class="number">1</span>,rside);</span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) <span class="comment">//剪枝 target是传参量</span></span><br><span class="line">        &#123; <span class="comment">// stop untifin dfs</span></span><br><span class="line">            combine.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], combine, idx,rside);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c = a.<span class="built_in">combinationSum</span>(b, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rowV : c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;el : rowV)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打印二维vector</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVecofVec1</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowV : res) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; el : rowV) &#123;</span><br><span class="line">      cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort采用的是什么排序？</p><p><strong>sort函数的底层用到的是内省式排序以及插入排序</strong>,内省排序首先从快速排序开始,当递归深度超过一定深度(深度为排序元素数量的对数值)后转为堆排序</p><p>回溯算法不剪枝就是暴力枚举，也可以理解为枚举没办法的办法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组</title>
      <link href="/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组 <strong>nums</strong> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 <strong>旋转</strong>，使数组变为 <strong>[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]</strong>（下标 <strong>从 0 开始</strong> 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><p>like this</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251152114.png" alt="img"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span>&#123;  <span class="comment">//二分查找升级版</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) <span class="comment">// 有=</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[mid])</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">search</span>(b,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：二分查找，快排之类的都是很重要的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长有效括号</title>
      <link href="/2022/11/23/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/11/23/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先会想到堆栈的符号匹配之类的算法，奈何不记得怎么写了。首先，我们试着用动态规划的思路来写，我们发现，给定一个动态规划的数组dp[]，dp中记录以每个符号结尾的最大有效数，可知以（结尾的为0，以）结尾的要分两种情况讨论即可。</p><p>1、（）型</p><p>这种情况只需要dp[i]=dp[i-2]+2即可</p><p>2、））型</p><p>这种情况需要判断一下</p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=（，则dp[i] = dp[i-1]+2</em></p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=），则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</em></p><p>这样我们也能发现，上面斜线部分有冗余部分，实则是：</p><p>如果dp[i-dp[i-1]-1]=（，则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</p><p><strong>最后就是注意数组不要越界</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span> , n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = ( i&gt;=<span class="number">2</span> ? dp[i<span class="number">-2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + ( (i-dp[i<span class="number">-1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i<span class="number">-1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="built_in">max</span>(length,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="堆实现符号匹配"><a href="#堆实现符号匹配" class="headerlink" title="堆实现符号匹配"></a>堆实现符号匹配</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>我记得是在编译原理这门课上，学习了编程实现加减乘除的算数表达式文法的正确性。找到实验代码，感叹之前学习的东西真的忘得太快啦。</p><p>如果想要快速捡起来，还是得做好收集工作啊！</p><p>展示：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251107751.png" alt="image-20221125110714653"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">                    a.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = <span class="built_in">max</span>(maxlen,i - a.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-STL-map"><a href="#C-STL-map" class="headerlink" title="C++ STL map"></a>C++ STL map</h2><p><strong>map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据**</strong>自动排序**的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><p><strong>map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</strong></p><p><strong>对于迭代器来说，</strong>可以修改实值，而不能修改key</p><p><strong>C++的标准库关联容器map是不允许有key</strong>相同的键值对存在的。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>map和vector差不多，map有自动排序的功能和定义key元素类型的特性</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法作业：来回拉人</title>
      <link href="/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/"/>
      <url>/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>人和摩托最快达到目的地题目描述：有n个人和一辆摩托车，摩托车可坐2个人（包括驾驶人），他们要到离他们距离D的目的地，可以利用摩托车来回运人，每个人都会开摩托车，人的速度为v1，摩托车的速度为v2，求他们最快达到目的地的时间。</p><p>输入格式：每行4个整数(n，v1，v2，D)，整数之间有一个空格，速度单位是千米每小时，距离的单位是千米，输入直至n=0数据范围：1&lt;=n&lt;=1000000, 1&lt;=v1,v2&lt;=1000000, 1000&lt;=D&lt;=1000000</p><p>输出格式：每行一个结果，精确到秒（不到1秒的小数舍去），3个整数分别代表小时、分、秒，整数之间有一个空格，最后一行也有回车</p><p>输入样例：</p><p>1 2 4 21</p><p>2 1 7 20</p><p>0</p><p>输出样例：</p><p>5 15 0</p><p>2 51 25</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分法：车的速度比人快，那么多长的时间就是总路程/人的速度，利用二分法，找到一个合适的时间，使得在这个时间内，车和人相遇n-2次，如果大于n-2次那么这个时间长了，需要减小时间，反之增加时间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">&#123;</span><br><span class="line">    ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">        R = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到遇见次数和时间之间的等式：</p><p>n=（(v2<em>t-D)\</em>(v1+v2)*(D-v1*t))/(2*v2)</p><p>这个公式我没有推导出来，希望大佬可以交流交流。</p><h2 id="最后代码"><a href="#最后代码" class="headerlink" title="最后代码"></a>最后代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//更现代</span></span><br><span class="line"><span class="comment">// using long long = ll;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">ll n, k, D;</span><br><span class="line"><span class="comment">//check this  time can finish all the people</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v2 * t &lt; D)</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">    cnt = ((v2 * t - D) * (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(v1) + v2) * (D - v1 * t)) / (<span class="number">2</span>*v2) + <span class="number">2</span>;<span class="comment">//find out this time can cross how many people</span></span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; D;</span><br><span class="line"></span><br><span class="line">        D *= <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">        ll L = <span class="number">0</span>, R = D / v1;<span class="comment">//R :the people road time</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">                R = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出时间</span></span><br><span class="line">        cout &lt;&lt; L / <span class="number">3600</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">3600</span> / <span class="number">60</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">60</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hot 23</title>
      <link href="/2022/11/12/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/hot%2023/"/>
      <url>/2022/11/12/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/hot%2023/</url>
      
        <content type="html"><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路巨简单，难得一次都不用调试！！!循环直接搞定，什么分治大法我不懂！</p><p>用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; qu;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;ListNode&gt;&amp; lists)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (ListNode  list : lists) <span class="comment">//只是加入链表头节点</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(list == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qu.<span class="built_in">push</span>(list);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ListNode head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       ListNode cur = head;</span><br><span class="line">       <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">            ListNode nex = qu.<span class="built_in">pop</span>();</span><br><span class="line">            cur.next = nex;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//链表没到尾，队列加入尾随节点</span></span><br><span class="line">            <span class="keyword">if</span>(nex-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(nex.next);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里面涉及优先队列的思想，第一次用到优先队列，很多都不清楚。还有就是判断指针是否指向空时的判断，比如qu.push(list);//list为nullptr不能进行插入操作。</p><p>priority_queue用法详情：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">C++ priority_QUEUE</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活小妙招</title>
      <link href="/2022/11/11/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
      <url>/2022/11/11/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%A6%99%E6%8B%9B/</url>
      
        <content type="html"><![CDATA[<p>windows:</p><p>在终端输入一下命令即可批量重命名文件后缀。</p><p>ren :rename。<em> 所有无后缀文件修改为</em>.jpg</p><p>ren <em> </em>.jpg</p><hr><p>2、如果英文好，不用csdn，用stackoverflow</p><p>3、自定义短语，减轻我们平时打字负担</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281100320.png" alt="image-20221128110048237"></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281101526.png" alt="image-20221128110115474"></p><p>4、github commit是提交到本地仓库</p><p>commit &amp; push是提交本地&amp;并推到本地</p><p>commit &amp; sync是提交本地&amp; 同步 —- 同步是 什么意思？</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281201119.png" alt="image-20221128120102985"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>terminal 美化历程</title>
      <link href="/2022/11/11/terminal%20%E7%BE%8E%E5%8C%96%E5%8E%86%E7%A8%8B/"/>
      <url>/2022/11/11/terminal%20%E7%BE%8E%E5%8C%96%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<details green><summary> 前言 </summary>              <div class='content'>              <p>今天呢，看见我的好室友坤坤，弄了一晚上的终端美化，看上去颇有一点意思，所以呢，我就模仿了一下，不算抄袭哈。哈哈哈。<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111135114.gif" alt=""></p><p>所以呢，今天我就来记录一下美化的步骤。</p><p>因为很多都不记得了。所以这算不上一篇合格的教程辣。<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111137459.gif" alt=""></p>              </div>            </details><p>首先呢，我们在微软software store下载的terminal。是一个黑不溜秋的黑框，很影响我们发现美的眼睛。</p><p>对比一下我们就能看出来美化后的terminal对我们眼睛非常友好了：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111416165.png" alt=""></th><th><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111112994.png" style="zoom:50%;" /></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>在software store下载terminal之后，就是安装我们的主题工具了——oh my posh，里面有很多主题：<a href="https://ohmyposh.dev/docs/themes">Themes | Oh My Posh</a></p><p>当然，官方文档都有了，这教程也是翻译翻译。官方文档：<a href="https://ohmyposh.dev/docs/installation/windows">Windows | Oh My Posh</a></p><h2 id="安装oh-my-posh"><a href="#安装oh-my-posh" class="headerlink" title="安装oh my posh"></a>安装oh my posh</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winget install JanDeDobbeleer.OhMyPosh <span class="literal">-s</span> winget</span><br></pre></td></tr></table></figure><details green><summary> 可能出现的问题 </summary>              <div class='content'>              <ul><li>如果提示无法识别winget，说明电脑系统中没有安装winget，先要去微软商店中搜索winget后下载<a href="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109110230464.png"><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111132478.png" alt=""></a>即可</li><li>如果出现冲突无法下载 <code>oh-my-posh</code> ，安装提示给的oh-my-posh的ID使用命令 <code>winget install --id xxxxx</code> 下载</li><li>找到配置文件，powershell中输入 <code>$Profile</code> 可以查看windows的配置文件，利用 <code>code $Profile</code> 打开文件，并且添加如下的一段代码</li></ul>              </div>            </details><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">BASH</span></span><br><span class="line"><span class="attr">oh-my-posh</span> <span class="string">init pwsh --config $env:POSH_THEMES_PATH\montys.omp.json | Invoke-Expression</span></span><br><span class="line"><span class="attr">cls</span></span><br><span class="line"><span class="comment"># Shows navigable menu of all options when hitting Tab</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key Tab -Function MenuComplete</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Autocompletion for arrow keys</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key UpArrow -Function HistorySearchBackward</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key DownArrow -Function HistorySearchForward</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># auto suggestions</span></span><br><span class="line"><span class="attr">Import-Module</span> <span class="string">PSReadLine</span></span><br><span class="line"><span class="attr">Set-PSReadLineOption</span> <span class="string">-PredictionSource History</span></span><br></pre></td></tr></table></figure><p>第一行为主题的设置，其中 <code>montys.omp.json</code>为主题配置文件，可以修改（可以通过上面的那个oh-my-posh的路径查看所有主题）</p><p>后面的几行都是针对于powershell的命令行提示提示补全的功能</p><blockquote><p>遇到的问题：</p><ul><li><code>$Profile</code>目录不存在，按照提示的路径新建即可，系统也会提示你新建这个文件</li><li>主题的图标出现乱码，使用Nerd字体，去网上下载Nerd字体，这里推荐 JetBrainsMono Nerd Font Mono 字体<strong>（一定要注意，设置字体时，一定要将配置文件中的list级下的所有局部配置的字体删掉，否则字体无法生效）</strong></li></ul></blockquote><p>最后附上：<strong><a href="https://mirclea.github.io/2022/11/09/windows-config/[Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher](https://www.nerdfonts.com/font-downloads">Nerd字体下载网站</a></strong></p><details green><summary> 结语 </summary>              <div class='content'>              <p>最后呢，最近想学习linux，但是不知道使用虚拟机学习还是服务器，亦或是双系统。最后我选择的是windows下的一个子系统ubuntu。如果有缘再更。</p>              </div>            </details>]]></content>
      
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程</title>
      <link href="/2022/11/06/%E7%A9%BF%E8%BF%87%E5%87%A0%E4%B8%AA%E7%82%B9%E7%9A%84%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1/"/>
      <url>/2022/11/06/%E7%A9%BF%E8%BF%87%E5%87%A0%E4%B8%AA%E7%82%B9%E7%9A%84%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="穿过几个点的线段统计"><a href="#穿过几个点的线段统计" class="headerlink" title="穿过几个点的线段统计"></a>穿过几个点的线段统计</h2><p>穿过几个点的线段统计</p><p>题目描述：平面上有N个点（N&lt;1600），有的线段会穿过多个点，请依据穿过点的个数，对线段进行统计。 </p><p>输入：每十个点一行，最后一行可能不足十个点；每行有20个整数（最后一行，可能不足），依次为第一个点的x坐标和y坐标，第二个点的x坐标和y坐标，，，等等。点的个数依据数据决定。</p><p> 输出：依据穿过点的数量升序输出：每行两个整数，点的数量k和正好穿过k个点的线段数量，最后一行也有回车。 </p><p>输入样例1：0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2</p><p> 输出样例2：</p><p>2 12</p><p>3 8 </p><p>输入样例2：</p><p>0 0 0 1 0 2 0 3 1 0 1 1 1 2 1 3 2 0 2 1</p><p>2 2 2 3 3 0 3 1 3 2 3 3 </p><p>输出样例2：</p><p>2 48</p><p>3 4</p><p>4 10</p><h2 id="思路：有一道题是求最长的线段长度，暴力即可解决，原题链接："><a href="#思路：有一道题是求最长的线段长度，暴力即可解决，原题链接：" class="headerlink" title="思路：有一道题是求最长的线段长度，暴力即可解决，原题链接："></a>思路：有一道题是求最长的线段长度，暴力即可解决，原题链接：</h2><p><a href="https://leetcode.cn/problems/max-points-on-a-line/solution/c-liang-chong-fang-fa-by-heroding-9gso/">C++ 两种方法！ - 直线上最多的点数 - 力扣（LeetCode）</a></p><p>有两种方法，一种3次方，一种二次方。</p><p>二次方方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;<span class="type">int</span> b[<span class="number">3600</span>][<span class="number">1000</span>];</span><br><span class="line">map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) b *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">1</span>; --i) c *= i;</span><br><span class="line">    <span class="keyword">return</span> a/(b*c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxPoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 点的数量不够</span></span><br><span class="line">    <span class="comment">// if(len &lt; 3) &#123;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="type">int</span> maxNum = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每两个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> dx = b[i][<span class="number">0</span>] - b[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> dy = b[i][<span class="number">1</span>] - b[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">double</span> gradient;</span><br><span class="line">                <span class="keyword">if</span>(dy==<span class="number">0</span>) </span><br><span class="line">                    gradient = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dx == <span class="number">0</span>)</span><br><span class="line">                    gradient = <span class="number">99999</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                     gradient = dy * <span class="number">1.0</span> / dx;</span><br><span class="line">                <span class="keyword">if</span>(count.<span class="built_in">count</span>(gradient)) &#123;  <span class="comment">// 经过i个点且斜率相同</span></span><br><span class="line">                    count[gradient] ++;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count[gradient] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = count.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            a[iter-&gt;second]++;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = a.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter != a.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            a[iter-&gt;first] = iter-&gt;second / iter-&gt;first;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;b[len][<span class="number">0</span>]&gt;&gt;b[len][<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">maxPoints</span>();</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    iter = a.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != a.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details red><summary> 哔哔 </summary>              <div class='content'>              <p>开始用暴力解法，一直出现timeout错误，借用map达到了O（n^2）.</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_TCP通信</title>
      <link href="/2022/10/27/2022-10-27-QT_TCP%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/10/27/2022-10-27-QT_TCP%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-TCP通信过程"><a href="#QT-TCP通信过程" class="headerlink" title="QT_TCP通信过程"></a>QT_TCP通信过程</h1><p>之前我们在计网中，也就是这篇文章：</p><p>介绍了TCP套接字编程，客户端可以输入小写字符给服务器转成大写字符再送回。</p><p>今天，学习了一个QT的TCP通信的例子，关于QT-network方面的知识，记录一下。</p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210271329175.gif" alt="TCP"></p><p>先介绍一下TCP的连接过程</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210271320243.png" alt="03_QtTCP通信过程"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serverwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_serverwidget.h&quot;</span></span></span><br><span class="line">ServerWidget::<span class="built_in">ServerWidget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ServerWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    tcpServer = <span class="literal">NULL</span>;</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    监听套接字,指定父对象</span></span><br><span class="line">    tcpServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tcpServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;服务器端口8888&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有连接建立就会触发newconnection信号</span></span><br><span class="line">    <span class="built_in">connect</span>(tcpServer, QTcpServer::newConnection,[=]()&#123;</span><br><span class="line">        <span class="comment">//取出建立好链接的套接字</span></span><br><span class="line">        tcpSocket = tcpServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对方的ip和端口</span></span><br><span class="line">        QString ip = tcpSocket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">        qint16 port = tcpSocket-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        QString temp = <span class="built_in">QString</span>(<span class="string">&quot;[%1:%2]:成功链接&quot;</span>).<span class="built_in">arg</span>(ip).<span class="built_in">arg</span>(port);</span><br><span class="line">        <span class="comment">//将数据显示在textEditRead上面</span></span><br><span class="line">        ui-&gt;textEditRead-&gt;<span class="built_in">setText</span>(temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//tcpSocket在创建后才能用</span></span><br><span class="line">        <span class="comment">//如果数据传送成功，对方的通信套接字会触发readyRead</span></span><br><span class="line">        <span class="built_in">connect</span>(tcpSocket,QTcpSocket::readyRead,[=]()&#123;</span><br><span class="line">            <span class="comment">//从通信套接字取出内容</span></span><br><span class="line">            QByteArray array = tcpSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">            ui-&gt;textEditRead-&gt;<span class="built_in">append</span>(array);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerWidget::~<span class="built_in">ServerWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerWidget::on_pushButtonSent_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//获取内容</span></span><br><span class="line">    QString str = ui-&gt;textEditWrite-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    <span class="comment">//给对方发送数据</span></span><br><span class="line">    tcpSocket-&gt;<span class="built_in">write</span>(str.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerWidget::on_pushButtonClose_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//主动断开链接</span></span><br><span class="line">    tcpSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    tcpSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clientwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_clientwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"></span><br><span class="line">ClientWidget::<span class="built_in">ClientWidget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ClientWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    tcpsocket = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;客户端&quot;</span>);</span><br><span class="line"><span class="comment">//    初始化socket并指定父对象</span></span><br><span class="line">    tcpsocket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tcpsocket, QTcpSocket::connected,[=]()&#123;</span><br><span class="line">        ui-&gt;textBrowserRead-&gt;<span class="built_in">setText</span>(<span class="string">&quot;成功连接!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//如果数据传送成功，对方的通信套接字会触发readyRead</span></span><br><span class="line">    <span class="built_in">connect</span>(tcpsocket,QTcpSocket::readyRead,[=]()&#123;</span><br><span class="line">        <span class="comment">//获取对方发送的内容</span></span><br><span class="line">        QByteArray array = tcpsocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="comment">//放入编辑区</span></span><br><span class="line">        ui-&gt;textBrowserRead-&gt;<span class="built_in">append</span>(array);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClientWidget::~<span class="built_in">ClientWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_pushButtonConnect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取服务器IP和端口</span></span><br><span class="line">    QString ip = ui-&gt;lineEditIp-&gt;<span class="built_in">text</span>();</span><br><span class="line">    qint16 port = ui-&gt;lineEditPort-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主动和服务器链接</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip),port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_close_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//主动断开与客户端链接</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    tcpsocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    tcpsocket == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_send_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//获取内容</span></span><br><span class="line">    QString str = ui-&gt;textBrowserWrite-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">write</span>(str.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>当然还有ui的设计，这里不做解释。如果你想复现,</p><p>还是找我要源码吧<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=768213856&amp;site=qq&amp;menu=yes">http://wpa.qq.com/msgrd?v=3&amp;uin=768213856&amp;site=qq&amp;menu=yes</a> </p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--031 下一个排列</title>
      <link href="/2022/10/17/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2022/10/17/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="1-调用STL的函数"><a href="#1-调用STL的函数" class="headerlink" title="#1 调用STL的函数"></a>#1 调用STL的函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// STL功能和题目描述一致</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-手动实现-时间复杂度O-n-空间复杂度O-1"><a href="#2-手动实现-时间复杂度O-n-空间复杂度O-1" class="headerlink" title="#2 手动实现 时间复杂度O(n),空间复杂度O(1)"></a>#2 手动实现 时间复杂度O(n),空间复杂度O(1)</h2><ul><li>从后往前找到第一个【相邻升序对】，即A[i]&lt;A[i+1]。此时A[i+1,end)为降序。</li><li>在区间[i+1,end)中，从后往前找到第一个大于A[i]的元素A[j]</li><li>交换A[i]和A[j]，此时A[i+1,end)一定还是降序，因为A[j]是从右侧起第一个大于A[i]的值</li><li>反转A[i+1,end)，变成升序</li></ul><p>应用场景：可兼容处理含有重复元素的全排列问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; -- i) &#123; <span class="comment">// 从后往前找到第一个相邻升序对</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 无相邻升序对，必定为非递减序列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= i+<span class="number">1</span>; -- j) &#123; <span class="comment">// 从后往前[i+1,end)找第一个大于a[i+1]的值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i],nums[j]); <span class="comment">// 交换二者</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>()); <span class="comment">// 反转[i+1,end)，变成升序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--022 括号生成</title>
      <link href="/2022/10/14/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-14-%E5%8A%9B%E6%89%A3hot100--022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2022/10/14/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-14-%E5%8A%9B%E6%89%A3hot100--022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><details green><summary> 哔哔 </summary>              <div class='content'>              <p>这道题目思路有很多，但是我一个都没想到… 看了天才们的解法，有以下两个：递归和动态规划。</p><p>好像递归转为非递归用的就是动态规划…</p><p>这两种解法真的好难掌握一看就懂一写就废…</p>              </div>            </details><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">res</span>(n + <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">0</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        res[<span class="number">1</span>] = &#123;<span class="string">&quot;()&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (string p : res[j])</span><br><span class="line">                    <span class="keyword">for</span> (string q : res[i - j - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        string str = <span class="string">&quot;(&quot;</span> + p + <span class="string">&quot;)&quot;</span> + q;</span><br><span class="line">                        res[i].<span class="built_in">push_back</span>(str);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    <span class="comment">// list&lt;string&gt; b;</span></span><br><span class="line">    vector&lt;string&gt; b;</span><br><span class="line">    b = a.<span class="built_in">generateParenthesis</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// for (string c : b)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    list&lt;string&gt; res;</span><br><span class="line">    <span class="function">list&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string str, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号=右括号时，只能加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="built_in">dfs</span>(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 左括号大于右括号时，当左括号取完前，取左括号，取完后取右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">            <span class="built_in">dfs</span>(str + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    list&lt;string&gt; b;</span><br><span class="line">    <span class="comment">// vector&lt;string&gt; b;</span></span><br><span class="line">    b = a.<span class="built_in">generateParenthesis</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// for (auto it = b.begin(); it != b.end(); it++)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (string c : b)</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details ><summary> green，递归哔哔 </summary>              <div class='content'>              <p>每种解法都有特定的思路。</p><p>递归来讲：剩余左括号总数要小于等于右括号。定义函数dfs(str,left,right)。str是生成的字符串，left表示剩下的“（”，right表示剩下的“）”。</p><p>1、定义递归出口：当左括号和右括号都填完了，return即可。</p><p>2、递归顺序：考虑左括号和右括号的性质，当左右括号数相同，先递归左括号（保证左括号数&lt;=n)，再递归右括号。</p>              </div>            </details><details green><summary> 动态规划哔哔 </summary>              <div class='content'>              <p>思路：求结果n时，我们可以从结果n-1中插入一个括号求解。（x）会有重复解的情况。</p><p>求结果n时，考虑 <code>i=n</code> 时相比 <code>n-1</code> 组括号增加的那一组括号的位置。括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p><p>规划方程：</p><p>“(“ + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】</p>              </div>            </details><p>tip:</p><p><strong>我想把三个常用的序列式放在一起对比一下是有必要的：</strong></p><p><strong>vector ：</strong> vector和built-in数组类似，拥有一段连续的内存空间，能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当插入较多的元素后，预留内存空间可能不够，需要重新申请一块足够大的内存并把原来的数据拷贝到新的内存空间。这些影响了vector的效率，但是实际上用的最多的还是vector容器，建议大多数时候使用vector效率一般是不错的。vector的用法解析可以参考本人的另一篇随笔：<a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/08/2627666.html">http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/08/2627666.html</a></p><p><strong>list：</strong>   list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p><p><strong>deque：</strong> deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上与list的效率也差不多。</p><p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，具体可以遵循下面的<strong><em>\</em>原则**</strong>：</p><ul><li><p>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p></li><li><p>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p></li><li><p>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p></li></ul><p>遍历:</p><p>对于三种容器:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> (string c : b)</span><br><span class="line">       cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--021 合并子串</title>
      <link href="/2022/10/14/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-14-%E5%8A%9B%E6%89%A3hot100--021-%E5%90%88%E5%B9%B6%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/10/14/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-14-%E5%8A%9B%E6%89%A3hot100--021-%E5%90%88%E5%B9%B6%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210131816011.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><details green><summary> 哔哔 </summary>              <div class='content'>              <p>之前写过这道题目用的是迭代的思路，所以实现起来还是很熟练的。但是我在解题中看到了递归的解法，最递归害怕者的我有很好的帮助。</p>              </div>            </details><h2 id="迭代代码实现"><a href="#迭代代码实现" class="headerlink" title="迭代代码实现"></a>迭代代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x,ListNode *next):<span class="built_in">val</span>(x),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode  result = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* r = result;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">nullptr</span> &amp;&amp; list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&gt;list2-&gt;val)&#123;</span><br><span class="line">                result-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            result = result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span>)</span><br><span class="line">            result-&gt;next = list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">nullptr</span>)</span><br><span class="line">            result-&gt;next = list1;</span><br><span class="line">        <span class="keyword">return</span> r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ListNode* a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--020 符号匹配</title>
      <link href="/2022/10/13/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-13-%E5%8A%9B%E6%89%A3hot100--020/"/>
      <url>/2022/10/13/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-13-%E5%8A%9B%E6%89%A3hot100--020/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><details green><summary> 哔哔 </summary>              <div class='content'>              <p>这就是编译原理学的符号匹配，话说编译原理也忘得差不多了，里面正则表达式的计算之类的东西，忘了以后再捡起来吧，对了感谢肖建老师教授的编译原理，个人感觉非常的好。（有一次把肖建老师叫成了肖战，哈哈哈。。。）</p>              </div>            </details><p>算法执行过程：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210131055496.gif" alt="20.gif"></p><h2 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVaild</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution tex;</span><br><span class="line">    string str = <span class="string">&quot;(&#123;[)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(tex.<span class="built_in">isVaild</span>(str))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目比较简单，就是一个符号匹配，利用栈即可解决问题，但是我又看了一位大佬的代码，里面用map映射了符号与数字之间的关系，再用简单的一行命令判断即可求解，很巧妙，代码贴下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;[&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;&#123;&#x27;</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&#x27;]&#x27;</span>,<span class="number">5</span>&#125;,&#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">bool</span> istrue=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="type">int</span> flag=m[c];</span><br><span class="line">            <span class="keyword">if</span>(flag&gt;=<span class="number">1</span>&amp;&amp;flag&lt;=<span class="number">3</span>) st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()&amp;&amp;m[st.<span class="built_in">top</span>()]==flag<span class="number">-3</span>) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;istrue=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) istrue=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> istrue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优化</title>
      <link href="/2022/10/09/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/"/>
      <url>/2022/10/09/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h1><p>1.极点<br>极点的定义及理解<br>Definition 2.6 Let P be a polyhedron. A vector x ∈ P is an extreme point of P if we cannot find two vectors y, z ∈ P, both different from x, and a scalar λ ∈ (0,1), such that x = λy + (1 - λ)z.</p><p>定义中给出了一种严格证明极点 (extreme point) 的方法，即：极点无法被另外两个点的线性组合表示出。若我们想用概括性的图像思维来描述极点的话，请先看下图（所有的极点都已用字母标出）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091540298.jpeg" alt="在这里插入图片描述">通过观察不难发现，所有的极点都是凸集的“角(corner)”，即：你无法找到相异的两点，使得这些“角”在这两点的连线上。这就是我对于极点的直观几何理解。<br>当然，这是在二维平面上的，这里希望读者自己去思考在3,4,…,n维情况下，极点究竟如何定义。</p>]]></content>
      
      
      <categories>
          
          <category> 最优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--0019 删除链表倒数第N位</title>
      <link href="/2022/10/09/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-9-%E5%8A%9B%E6%89%A3hot100--0019/"/>
      <url>/2022/10/09/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-10-9-%E5%8A%9B%E6%89%A3hot100--0019/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091306235.jpeg" alt="img"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><details green><summary> 哔哔 </summary>              <div class='content'>              <p>这是道简单的链表题，对我们熟悉链表操作有很好的帮助。</p><p>链表最重要的操作就是创增删改查。我们熟悉这些操作就行了。还有另外的双链表，循环链表大同小异，可以放在以后再看。</p><hr><p>思路就是先获取链表的长度，然后由倒数第几个转化为第几个的问题。</p>              </div>            </details><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">         ListNode* p = head;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (p-&gt;next != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        n = i-n;</span><br><span class="line">        p = head;</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            n-=1;</span><br><span class="line">            while(n--)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ListNode* hea = new ListNode(1);</span><br><span class="line">    ListNode* he = hea;</span><br><span class="line">    int i;</span><br><span class="line">    while (cin&gt;&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        he-&gt;next = new ListNode(i);</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution a;</span><br><span class="line">    ListNode* b = a.removeNthFromEnd(hea,1);</span><br><span class="line">    while (b != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">        b=b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进阶：你能尝试使用一趟扫描实现吗？"><a href="#进阶：你能尝试使用一趟扫描实现吗？" class="headerlink" title="进阶：你能尝试使用一趟扫描实现吗？"></a><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</h1><p>扫描一遍就得出答案可以使用双指针，思路如下：</p><p>设置两个头指针p、q，移动q使得两指针相距n位，然后同时移动两个指针，当q到尾部时，p指的自然是倒数n位。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091320311.gif" alt="img"></p><p>实现代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">     ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* p = dummyHead;</span><br><span class="line">        ListNode* q = dummyHead;</span><br><span class="line">        for( int i = 0 ; i &lt; n + 1 ; i ++ )&#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(q)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* delNode = p-&gt;next;</span><br><span class="line">        p-&gt;next = delNode-&gt;next;</span><br><span class="line">        delete delNode;</span><br><span class="line"></span><br><span class="line">        ListNode* retNode = dummyHead-&gt;next;</span><br><span class="line">        delete dummyHead;</span><br><span class="line"></span><br><span class="line">        return retNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP套接字编程</title>
      <link href="/2022/10/07/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/10/07/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h1><p>先介绍两个主要的结构体。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址和port捆绑关系的数据结构（标示进程的端节点）：作用是存放本地应用进程ip和端口</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">short sin_family; //AF_INET  地址</span><br><span class="line">u_short sin_port; // port端口</span><br><span class="line">struct in_addr sin_addr ; ip地址</span><br><span class="line">// IP address, unsigned long</span><br><span class="line">char sin_zero[8]; // align 对齐</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构 hostent</span><br><span class="line">域名和IP地址的数据结构：作为域名解析的一个函数调用。</span><br><span class="line">struct hostent</span><br><span class="line">&#123; char *h_name;  主机域名</span><br><span class="line">char **h_aliases;  域名别名</span><br><span class="line">int h_addrtype; </span><br><span class="line">int h_length; /*地址长度*/ </span><br><span class="line">char **h_addr_list;  ip地址</span><br><span class="line">#define h_addr h_addr_list[0];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>再介绍socket API里面的几个函数：</p><p>主要的用到的 Socket API 函数和方法有下面这些：</p><ul><li><p><code>socket()</code></p></li><li><p><code>bind()</code></p></li><li><p><code>listen()</code></p></li><li><p><code>accept()</code></p></li><li><p><code>connect()</code></p></li><li><p><code>connect_ex()</code></p></li><li><p><code>send()</code></p></li><li><p><code>recv()</code></p></li><li><p><code>close()</code></p><p>更详细的API说明请看官方文档：<a href="https://docs.python.org/3/library/socket.html#module-socket">socket — Low-level networking interface — Python 3.10.7 documentation</a></p></li></ul><p>TCP运行过程：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210071711591.png" alt="TCP.drawio"></p><p>server.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># 创建TCP欢迎套接字，使用IPv4协议</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))  <span class="comment"># 将TCP欢迎套接字绑定到指定端口</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)  <span class="comment"># 最大连接数为1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server in ready to receive&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()  <span class="comment"># 接收到客户连接请求后，建立新的TCP连接套接字</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accept new connection from %s:%s...&#x27;</span> % addr)</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>)  <span class="comment"># 获取客户发送的字符串</span></span><br><span class="line">    capitalizedSentence = sentence.upper()  <span class="comment"># 将字符串改为大写</span></span><br><span class="line">    connectionSocket.send(capitalizedSentence)  <span class="comment"># 向用户发送修改后的字符串</span></span><br><span class="line">    connectionSocket.close()  <span class="comment"># 关闭TCP连接套接字</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *  <span class="comment"># 导入socket这个模块API</span></span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;192.168.70.1&#x27;</span>  <span class="comment"># 指定服务器地址</span></span><br><span class="line">serverPort = <span class="number">12000</span>  <span class="comment"># 指定服务器的端口</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># 建立TCP套接字，使用IPv4协议 | 返回一个TCP的socket，是一个整数 | 操作系统会给你绑定，绑定什么呢？让你客户端的IP地址、端口号与创建的TCP socket捆绑在一起</span></span><br><span class="line">clientSocket.connect((serverName, serverPort))  <span class="comment"># 向服务器发起连接</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>).encode()  <span class="comment"># 用户输入信息，并编码为bytes以便发送</span></span><br><span class="line">clientSocket.send(sentence)  <span class="comment"># 将信息发送到服务器</span></span><br><span class="line">modifiedSentence = clientSocket.recvfrom(<span class="number">1024</span>)  <span class="comment"># 从服务器接收信息</span></span><br><span class="line"><span class="built_in">print</span>(modifiedSentence[<span class="number">0</span>].decode())  <span class="comment"># 显示信息</span></span><br><span class="line">clientSocket.close()  <span class="comment"># 关闭套接字</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex+vscode</title>
      <link href="/2022/09/27/2022-9-27-latex+vscode/"/>
      <url>/2022/09/27/2022-9-27-latex+vscode/</url>
      
        <content type="html"><![CDATA[<p>copy这位大佬：</p><p><a href="https://mirclea.github.io/2022/09/18/Latex/#latex的vscode配置">Latex入门 | Mirclea’s blog</a></p><hr><h2 id="Latex的下载："><a href="#Latex的下载：" class="headerlink" title="Latex的下载："></a>Latex的下载：</h2><ul><li>下载latex镜像文件，下载地址点击<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">这里</a>可以进入</li></ul><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209271802542.png" alt="image-20220927180227455"></p><p>对于这种.iso文件直接利用win10自带的虚拟光驱打开即可，不需要再额外下载其他虚拟光驱软件</p><h2 id="配置vscode-setting文件"><a href="#配置vscode-setting文件" class="headerlink" title="配置vscode setting文件"></a>配置vscode setting文件</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;workbench.startupEditor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Visual Studio Dark&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;backgroundCover.imagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d:\\photo\\wallper\\68048370_p0.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;backgroundCover.opacity&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;java.home&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Program Files\\Java\\jre8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gbk&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XeLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PDFLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BibTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFailed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double-click&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tab&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="string">&quot;D:/xunleidownload/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="string">&quot;D:/xunleidownload/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%PDF%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;[latex]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    </span><br><span class="line">        <span class="attr">&quot;editor.formatOnPaste&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.suggestSelection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;recentlyUsedByPrefix&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中latex中的setting.json</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209272329865.png" alt="image-20220927232946787"></p><h2 id="打开SumatraPDF设置中高级选项，替换如下代码（路径改成自己的）"><a href="#打开SumatraPDF设置中高级选项，替换如下代码（路径改成自己的）" class="headerlink" title="打开SumatraPDF设置中高级选项，替换如下代码（路径改成自己的）"></a>打开SumatraPDF设置中高级选项，替换如下代码（路径改成自己的）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># For documentation, see https://www.sumatrapdfreader.org/settings/settings3-4-6.html</span><br><span class="line">FixedPageUI [</span><br><span class="line">TextColor = #000000</span><br><span class="line">BackgroundColor = #ffffff</span><br><span class="line">SelectionColor = #f5fc0c</span><br><span class="line">WindowMargin = 2 4 2 4</span><br><span class="line">PageSpacing = 4 4</span><br><span class="line">HideScrollbars = false</span><br><span class="line">]</span><br><span class="line">ComicBookUI [</span><br><span class="line">WindowMargin = 0 0 0 0</span><br><span class="line">PageSpacing = 4 4</span><br><span class="line">CbxMangaMode = false</span><br><span class="line">]</span><br><span class="line">ChmUI [</span><br><span class="line">UseFixedPageUI = false</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">SelectionHandlers [</span><br><span class="line">]</span><br><span class="line">ExternalViewers [</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ZoomLevels = 8.33 12.5 18 25 33.33 50 66.67 75 100 125 150 200 300 400 600 800 1000 1200 1600 2000 2400 3200 4800 6400</span><br><span class="line">ZoomIncrement = 0</span><br><span class="line"></span><br><span class="line">PrinterDefaults [</span><br><span class="line">PrintScale = shrink</span><br><span class="line">]</span><br><span class="line">ForwardSearch [</span><br><span class="line">HighlightOffset = 0</span><br><span class="line">HighlightWidth = 15</span><br><span class="line">HighlightColor = #6581ff</span><br><span class="line">HighlightPermanent = false</span><br><span class="line">]</span><br><span class="line">Annotations [</span><br><span class="line">HighlightColor = #ffff00</span><br><span class="line">UnderlineColor = #00ff00</span><br><span class="line">TextIconColor = #ffff00</span><br><span class="line">TextIconType = </span><br><span class="line">DefaultAuthor = </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">RememberOpenedFiles = true</span><br><span class="line">RememberStatePerDocument = true</span><br><span class="line">RestoreSession = true</span><br><span class="line">UiLanguage = cn</span><br><span class="line">InverseSearchCmdLine = &quot;F:\vscode\Microsoft VS Code\Code.exe&quot; &quot;F:\vscode\Microsoft VS Code\resources\app\out\cli.js&quot;  --ms-enable-electron-run-as-node -r -g &quot;%f:%l&quot;</span><br><span class="line">EnableTeXEnhancements = true</span><br><span class="line">DefaultDisplayMode = automatic</span><br><span class="line">DefaultZoom = fit page</span><br><span class="line">Shortcuts [</span><br><span class="line">]</span><br><span class="line">EscToExit = false</span><br><span class="line">ReuseInstance = false</span><br><span class="line">ReloadModifiedDocuments = true</span><br><span class="line"></span><br><span class="line">MainWindowBackground = #80fff200</span><br><span class="line">FullPathInTitle = false</span><br><span class="line">ShowMenubar = true</span><br><span class="line">ShowToolbar = true</span><br><span class="line">ShowFavorites = false</span><br><span class="line">ShowToc = true</span><br><span class="line">TocDy = 0</span><br><span class="line">SidebarDx = 0</span><br><span class="line">ToolbarSize = 18</span><br><span class="line">TabWidth = 300</span><br><span class="line">TreeFontSize = 0</span><br><span class="line">SmoothScroll = false</span><br><span class="line">ShowStartPage = true</span><br><span class="line">CheckForUpdates = true</span><br><span class="line">WindowState = 1</span><br><span class="line">WindowPos = 0 0 1921 1030</span><br><span class="line">UseTabs = true</span><br><span class="line">UseSysColors = false</span><br><span class="line">CustomScreenDPI = 0</span><br><span class="line"></span><br><span class="line">FileStates [</span><br><span class="line">[</span><br><span class="line">FilePath = c:\Users\29133\Desktop\latex\test.pdf</span><br><span class="line">Favorites [</span><br><span class="line">]</span><br><span class="line">IsPinned = false</span><br><span class="line">IsMissing = false</span><br><span class="line">OpenCount = 1</span><br><span class="line">UseDefaultState = false</span><br><span class="line">DisplayMode = continuous</span><br><span class="line">ScrollPos = -1 53.8129</span><br><span class="line">PageNo = 8</span><br><span class="line">Zoom = 200</span><br><span class="line">Rotation = 0</span><br><span class="line">WindowState = 1</span><br><span class="line">WindowPos = 0 0 1921 1030</span><br><span class="line">ShowToc = false</span><br><span class="line">SidebarDx = 0</span><br><span class="line">DisplayR2L = false</span><br><span class="line">ReparseIdx = 0</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">FilePath = d:\Projcets\latex\Home1\conference_101719.pdf</span><br><span class="line">Favorites [</span><br><span class="line">]</span><br><span class="line">IsPinned = false</span><br><span class="line">IsMissing = true</span><br><span class="line">OpenCount = 0</span><br><span class="line">UseDefaultState = false</span><br><span class="line">DisplayMode = continuous</span><br><span class="line">ScrollPos = -1 624.14</span><br><span class="line">PageNo = 1</span><br><span class="line">Zoom = fit page</span><br><span class="line">Rotation = 0</span><br><span class="line">WindowState = 1</span><br><span class="line">WindowPos = 197 46 803 1026</span><br><span class="line">ShowToc = false</span><br><span class="line">SidebarDx = 0</span><br><span class="line">DisplayR2L = false</span><br><span class="line">ReparseIdx = 0</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">FilePath = d:\downloader\压缩文件\latex-templates\ieee\bare_jrnl.pdf</span><br><span class="line">Favorites [</span><br><span class="line">]</span><br><span class="line">IsPinned = false</span><br><span class="line">IsMissing = true</span><br><span class="line">OpenCount = 0</span><br><span class="line">UseDefaultState = false</span><br><span class="line">DisplayMode = continuous</span><br><span class="line">ScrollPos = -1 -1</span><br><span class="line">PageNo = 1</span><br><span class="line">Zoom = fit page</span><br><span class="line">Rotation = 0</span><br><span class="line">WindowState = 1</span><br><span class="line">WindowPos = 197 46 803 1026</span><br><span class="line">ShowToc = false</span><br><span class="line">SidebarDx = 0</span><br><span class="line">DisplayR2L = false</span><br><span class="line">ReparseIdx = 0</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line">SessionData [</span><br><span class="line">]</span><br><span class="line">TimeOfLastUpdateCheck = 0 0</span><br><span class="line">OpenCountWeek = 612</span><br><span class="line"></span><br><span class="line"># Settings below are not recognized by the current version</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="latex语法"><a href="#latex语法" class="headerlink" title="latex语法"></a>latex语法</h3><p>由于latex语法比较多且有点乱(本人学的也不太明白)，</p><p>我们可以通过<a href="https://github.com/CTeX-org/lshort-zh-cn">这里</a>找到latex手册进行学习</p><p>一些简单的常用的语法建议看一下这个<a href="https://www.bilibili.com/video/BV11h41127FD?from=search&amp;seid=12274189218691696421&amp;spm_id_from=333.337.0.0&amp;vd_source=57e5130c3375ea877ab660ca10500f21">视频</a></p>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1发sci</title>
      <link href="/2022/09/27/SCI%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2022/09/27/SCI%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SCI是什么"><a href="#SCI是什么" class="headerlink" title="SCI是什么"></a>SCI是什么</h1><p>SCI全称：science citation index中文名：科学论文索引。是一个可以检索文献的数据库。</p><p>期刊：cell、nature</p><p>影响因子：期刊品牌前两年期刊售出数量/  总生产数量。</p><p>美国科学情报所ISI对期刊品牌每两周进行一次评估（比如影响因子）</p><p>我们所说的发SCI指的就是发了某个期刊，然后被某个数据库收录（比如sci）</p><hr><p>这些数据库都有他的特点和优势。对于科研人员的我，应该了解每个数据库的特点，检索到全面并且正确的文献信息。</p><h1 id="文献检索的三个要点："><a href="#文献检索的三个要点：" class="headerlink" title="文献检索的三个要点："></a>文献检索的三个要点：</h1><ol><li>数据库的选择<br>a)    确定所在学科的数据库<br>b)    中文论文数据库有知网，万方和维普，知网可以绝大部分中文论文<br>c)    英文论文和中文论文最大区别：英文论文没有像知网一样一统天下的数据库，由各大不同数据库分散收录<br>d)    确定自己学科有哪些数据库:<br>问老师，研究生学长学姐，图书馆学科服务部门人员<br>e)    学校图书馆网站<br>f)    跨学科，单一学科和学科方向数据库：如Web of science，各学科ssci论文<br>g)    数据库贵，学校的数据库采购实力影响检索途径<br>h)    几个免费的检索渠道：SSRN，X-MOL学术平台（中国人做的外文文献检索平台），Google,Bing等搜索引擎（检索外文文献的准确性更高，特别是已经知道文献名称时）</li><li>检索词的确定<br>a)    检索词要规范正确：用一个词在数据库里搜索，看看搜出来的大部分结果的表述和用词是否一致<br>b)    检索词要尽可能全面，不能只用一个关键词检索，把同义词，近义词，上下位概念都去检索，确保文献的完整性，扎实的基础知识和对前沿问题的了解能够帮助准确，全面地检索关键词</li><li>多轮检索的过程<br>一轮检索后，在文献阅读的过程中，要注意：<br>a)    这些文献所引用的文献，可以按图索骥补充<br>b)    发现文献所提出的有价值的新问题，补充新的关键词去检索</li></ol><hr><h1 id="从0-1发sci"><a href="#从0-1发sci" class="headerlink" title="从0-1发sci"></a>从0-1发sci</h1><h2 id="1、明白自己想要发的期刊品牌"><a href="#1、明白自己想要发的期刊品牌" class="headerlink" title="1、明白自己想要发的期刊品牌"></a>1、明白自己想要发的期刊品牌</h2><p>了解中期刊的难度，选择合适自己的。途径：1、IF差与投：输入水刊，出现容易投的水刊。2、问学长学姐3、上小木虫、letpub网站，看论坛。</p><h2 id="2、定好题目"><a href="#2、定好题目" class="headerlink" title="2、定好题目"></a>2、定好题目</h2><p>1、如果是为了最快投中，那么就要追热点话题。</p><p>2、在自己论文那方面看50篇论文， 了解行情，衍生出自己的idea，清楚自己应该去怎么改，哪些是别人还没做过的东西。</p><p>50篇不多。不用每篇都细读啊，只需要看介绍introduction和总结，清楚这篇论文在讲什么，中间证明、原理之类的东西没必要看，很浪费时间。</p><p>3、开始写论文，论文的模板在期刊的官网上可以找到。按照这个格式去写。版面费1k-2k。</p><p>4、sci是分区的。1区到4区，论文长度把握好，4区短一些，1区长一些。</p><p>5、英语能力不好的，先用中文写，然后翻译，最后润色。 </p><p>6、注意作者名次，第一作者认可度比第二作者高一倍。</p><p>7、投稿是很复杂的，上传很多相关文件，注意期刊投稿相对<strong>领域</strong>。</p><p>8、cover letter就是给编辑人的一封信，整体内容就是告诉编辑人一定要把我这边论文投出去</p><p>9、第一次投稿之后到收到第一条修改意见之间有1-2个月的时间。小修是1个月之内，大修是3个月左右。第二次要重新写cover letter。按经验会修两轮。两轮之后就会接收。</p><p>10、接收之后，编辑人会发你proof的文稿，让你确定是否还有要修改的东西。再发给你相应的版面费。</p><p>11、找审稿人：引用了谁的文章，就选谁作为审稿人。</p><p>12、确认期刊的收稿率、投稿周期，不要太长的时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--017--电话号码的字母组合</title>
      <link href="/2022/09/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-27-%E5%8A%9B%E6%89%A3hot100--017--%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>/2022/09/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-27-%E5%8A%9B%E6%89%A3hot100--017--%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209270900591.png" alt="img"></p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><details green><summary> 哔哔 </summary>              <div class='content'>              <p>开始做这道题脑子里面想到的就是<p class='p red'>DFS</p>（深度优先遍历）奈何<p class='p red'>DFS</p>我只在树中学过，在这种一一映射的遍历中还是第一次见。题解说：<p class='p red'>回溯算法</p>用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><p>可惜了，我回溯代码也不会写。回溯算法的文字描述如下（我还是看的一知半解）</p><hr><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><hr><p>代码是我一边借鉴一边动脑写出来的，但是下次遇到相同的题目，我还是不会写吧！哎</p>              </div>            </details><h2 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res; </span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; a = &#123;</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;def&quot;</span>&#125;,&#123;<span class="number">4</span>,<span class="string">&quot;ghi&quot;</span>&#125;,&#123;<span class="number">5</span>,<span class="string">&quot;jkl&quot;</span>&#125;,&#123;<span class="number">6</span>,<span class="string">&quot;mno&quot;</span>&#125;,&#123;<span class="number">7</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="number">8</span>,<span class="string">&quot;tuv&quot;</span>&#125;,&#123;<span class="number">9</span>,<span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    string temp;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> depth,string digits)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth == digits.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> sum = digits[depth] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a[sum].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(a[sum][i]);</span><br><span class="line">                <span class="built_in">DFS</span>(depth+<span class="number">1</span>,digits);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">lettercombinations</span><span class="params">(string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>,digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    string b =  <span class="string">&quot;23&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    s = a.<span class="built_in">lettercombinations</span>(b);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::iterator  itr = s.<span class="built_in">begin</span>(); itr != s.<span class="built_in">end</span>(); itr++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*itr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回溯方法大有用处，应该好好吸收！</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然数与有理数的双射函数</title>
      <link href="/2022/09/23/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-23-%E8%87%AA%E7%84%B6%E6%95%B0%E4%B8%8E%E6%9C%89%E7%90%86%E6%95%B0%E7%9A%84%E5%8F%8C%E5%B0%84%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/23/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-23-%E8%87%AA%E7%84%B6%E6%95%B0%E4%B8%8E%E6%9C%89%E7%90%86%E6%95%B0%E7%9A%84%E5%8F%8C%E5%B0%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="算法题：自然数与有理数的双射函数"><a href="#算法题：自然数与有理数的双射函数" class="headerlink" title="算法题：自然数与有理数的双射函数"></a>算法题：自然数与有理数的双射函数</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231123258.png" alt="21d9a97ee2e018e313bc7947b0740658.png"></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231124462.png" alt="e2b706093c148938a0762b0d415a8116.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：多行，每行两个整数a和b，中间有一个空格，表示一个有理数a/b</span><br><span class="line"></span><br><span class="line">输出：对应的多行，每行一个整数，有理数a/b的双射函数对应的自然数，结果&lt;500000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"></span><br><span class="line">-2 1</span><br><span class="line"></span><br><span class="line">-4 1</span><br><span class="line"></span><br><span class="line">-1 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出样例：</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>思路：最开始的想法就是找规律了，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1/2 -1/2 -1 -2 -2/3 -1/3 1/3 2/3 2 3 3/2 3/4 1/4 -1/4 -3/4 -3/2 -3 -4 -4/3 -4/5 -3/5 -2/5 -1/5 1/5 2/5 3/5 4/5 4/3</span><br></pre></td></tr></table></figure><p>发现规律并不明显，很难模拟它的拟合方程（就是没有公式，没有规律）。</p><p>没有数字规律那就从图像中找规律，我发现图像是一个个凹字的嵌套，如图：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231128750.png" alt="image-20220923112831656"></p><p>我们只需要模拟出凹字的笔画就好啦（最小的凹字长宽分别为2：1。画完一个凹字之后接下来的凹字由图像可知长宽分别加4：2）</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">double</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>,y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    p[x/y] = count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        map&lt;<span class="type">double</span>,<span class="type">int</span>&gt;::iterator it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">        <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;a;j++)&#123;</span><br><span class="line">            y++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; b; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            x--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; a; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            y--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        x--;</span><br><span class="line">        it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">        <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            y++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b+<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            x++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            y--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        a+=<span class="number">2</span>;</span><br><span class="line">        b+=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> Q1,Q2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     for(auto it : p)&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; it.first &lt;&lt;&quot; &quot;&lt;&lt; it.second &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;Q1&gt;&gt;Q2)</span><br><span class="line">        cout&lt;&lt;p[Q1/Q2]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：N 空间复杂度：N</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly全局字体</title>
      <link href="/2022/09/22/hexo/butterfly%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/"/>
      <url>/2022/09/22/hexo/butterfly%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="butterfly全局字体"><a href="#butterfly全局字体" class="headerlink" title="butterfly全局字体"></a>butterfly全局字体</h1><p>1、新建custom.css</p><p>2、去<a href="https://www.diyiziti.com/Download/330">圆润字体下载-第一字体网 (diyiziti.com)</a>下载一款喜欢的字体。</p><p>3、css中设置字体格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">  font-family:&#x27;qinfeng&#x27; ;  /* 字体名自定义即可 */</span><br><span class="line">  src:url(&#x27;/font/nainao.ttf&#x27;); /* 字体文件路径 */</span><br><span class="line">  font-display : swap;</span><br><span class="line">&#125;</span><br><span class="line">h1#site-title &#123;</span><br><span class="line">  font-family: &#x27;qinfeng&#x27;, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">h2#site-title &#123;</span><br><span class="line">  font-family: &#x27;qinfeng&#x27;, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">h3#site-title &#123;</span><br><span class="line">  font-family: &#x27;qinfeng&#x27;, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、hexo s查看效果</p>]]></content>
      
      
      <categories>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章加密</title>
      <link href="/2022/09/19/hexo/%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/"/>
      <url>/2022/09/19/hexo/%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>今天看到了一个很有趣的Hexo插件，可以轻松实现文章加密功能😋。<br>下面是添加加密功能的操作：</p><h2 id="安装hexo-blog-encrypt插件"><a href="#安装hexo-blog-encrypt插件" class="headerlink" title="安装hexo-blog-encrypt插件"></a>安装hexo-blog-encrypt插件</h2><ul><li>​    在hexo目录下npm install hexo-blog-encrypt</li><li>​    在/Hexo/_config.yml文件中添加内容:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">enable:true</span><br></pre></td></tr></table></figure><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><ul><li>在想要使用加密功能的Blog头部加上对应文字：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo加密功能</span><br><span class="line">date: 2019-09-04 23:20:00   </span><br><span class="line">tags: [学习笔记,Hexo]</span><br><span class="line">categories: Hexo      </span><br><span class="line">password: smile   </span><br><span class="line">abstract: Welcome to my blog, enter password to read. </span><br><span class="line">message: 密码输入框上描述性内容</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>其中：<ul><li>password: 该Blog使用的密码</li><li>abstract: Blog摘要文字（少量）</li><li>message: 密码框上的描述性文字</li></ul></li></ul><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传项目到github</title>
      <link href="/2022/09/18/hexo/Git%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
      <url>/2022/09/18/hexo/Git%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用之如何将本地项目上传到github"><a href="#Git使用之如何将本地项目上传到github" class="headerlink" title="Git使用之如何将本地项目上传到github"></a>Git使用之如何将本地项目上传到github</h1><details green><summary> 哔哔 </summary>              <div class='content'>              <p>因为自己想远程下载操作自己电脑上的项目，怕电脑不在身边，就想出来了部署到github上面。好像还可以管理版本更新，很方便的样子。</p><hr><p>教程是借鉴<a href="https://cloud.tencent.com/developer/article/1504684">Git的使用(tencent.com)</a>这个，侵删。</p><p>选择了我认为最简单的第三种方法。</p>              </div>            </details><ul><li><p>第一步：Git客户端安装好</p></li><li><p>第二步：github注册好账号</p></li><li><p>第三步：本地电脑随便建立一个文件夹，如：github，进入此文件夹，在地址栏中输入cmd</p></li><li><p>第四步：回到之前的github界面，下面几个指令告诉你如何将代码上传</p></li></ul><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209281506734.png" alt="img"></p><ul><li>第六步：在上面创建的github文件中，放入要上传的代码，然后按照上面的指令开始操作，执行指令<ul><li>1、git init      （建立本地仓库）</li><li>2、git add  <em>  (将代码添加到本地仓库，《</em>是添加全部代码，代码全部更新》)</li><li>3、git commit -m “first commit”  (提交到本地缓冲，《引号里说明提交了什么东西，说白了就是注释》）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209281507537.png" alt="img"></p><ul><li><p>4、git remote add origin <a href="https://github.com/hongduhong/test.git">https://github.com/hongduhong/test.git</a>   （将本地仓库的代码提交远程github的仓库，《后面的地址就是之前创建github的远程仓库地址》）</p></li><li><p>5、git push -u origin master    （将远程仓库的代码 push到master分支上）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209281507772.png" alt="img"></p></li><li><p>6、代码上传成功如下图所示：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209281507477.png" alt="img"></p></li></ul><hr><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>补充说明Git命令：</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是我们日常工作中使用频率极高的工具，各种指令让人眼花缭乱，今天，我们就在这里总结一下它的一些基本指令，算是做一份操作笔记吧。</p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><p>它通常将现有路径的当前内容作为一个整体添加，但是通过一些选项，它也可以用于添加内容，只对所应用的工作树文件进行一些更改，或删除工作树中不存在的路径了。</p><p>“索引”保存工作树内容的快照，并且将该快照作为下一个提交的内容。 因此，在对工作树进行任何更改之后，并且在运行 <code>git commit</code> 命令之前，必须使用 <code>git add</code> 命令将任何新的或修改的文件添加到索引。</p><p>该命令可以在提交之前多次执行。它只在运行 <code>git add</code> 命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行 <code>git add</code> 将新的内容添加到索引。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>操作 Git 的分支命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径 - <code>git checkout</code> 还会更新 <code>HEAD</code> ，将指定的分支设置为当前分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p><code>git checkout</code> 是 git 最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。</p></blockquote><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>将存储库克隆到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支(使用 <code>git branch -r</code> 可见)，并从克隆检出的存储库作为当前活动分支的初始分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>主要是用来配置 Git 的相关参数，其主要操作有：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line">$ git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line">$ git config --global credential.helper store</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>Git 一共有3个配置文件：</p><ol><li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li><li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li></ol></blockquote><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>用于显示提交和工作树等之间的更改。</p><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>显示提交的记录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>用于将两个或两个以上的开发历史加入(合并)一起。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，并自动进行新的提交</span></span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，不进行新的提交</span></span><br><span class="line">$ git merge --no-commit &lt;分支名称&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>重命名文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line">$ git <span class="built_in">mv</span> &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。 首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>操作远程库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>还原提交记录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</span></span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>删除文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git <span class="built_in">rm</span> &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git <span class="built_in">rm</span> -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被 Git tracked 到。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p><code>git status</code> 不显示已经 <code>commit</code> 到项目历史中去的信息。</p><p>看项目历史的信息要使用 <code>git log</code>。</p></blockquote><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>操作标签的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在菜单栏使用阿里彩色图标</title>
      <link href="/2022/09/17/hexo/%E5%9C%A8%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E5%BD%A9%E8%89%B2%E5%9B%BE%E6%A0%87/"/>
      <url>/2022/09/17/hexo/%E5%9C%A8%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E5%BD%A9%E8%89%B2%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="在菜单栏使用阿里彩色图标"><a href="#在菜单栏使用阿里彩色图标" class="headerlink" title="在菜单栏使用阿里彩色图标"></a>在菜单栏使用阿里彩色图标</h1><h1 id="在文章中使用symbol写法来引入iconfont图标"><a href="#在文章中使用symbol写法来引入iconfont图标" class="headerlink" title="在文章中使用symbol写法来引入iconfont图标"></a>在文章中使用<code>symbol</code>写法来引入<code>iconfont</code>图标</h1><p>复制symbol的js链接，在butterfly中引入js链接。</p><p>在[Blogroot]\themes\butterfly\layout\includes\header\menu_item.pug,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if theme.menu</span><br><span class="line">  //- for mobile sidebar</span><br><span class="line">  - let sidebarChildHide = theme.hide_sidebar_menu_child ? &#x27;hide&#x27; : &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">  .menus_items</span><br><span class="line">    each value, label in theme.menu</span><br><span class="line">      if typeof value !== &#x27;object&#x27;</span><br><span class="line">        .menus_item</span><br><span class="line">          a.site-page(href=url_for(trim(value.split(&#x27;||&#x27;)[0])))</span><br><span class="line">            if value.split(&#x27;||&#x27;)[1]</span><br><span class="line">              - var icon_value = trim(value.split(&#x27;||&#x27;)[1])</span><br><span class="line">              if icon_value.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                i.fa-fw(class=icon_value)</span><br><span class="line">              else if icon_value.substring(0,4)==&quot;icon&quot;          </span><br><span class="line">                svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                  use(xlink:href=`#`+ icon_value)</span><br><span class="line">            span=&#x27; &#x27;+label</span><br><span class="line">      else</span><br><span class="line">        .menus_item</span><br><span class="line">          a.site-page(href=&#x27;javascript:void(0);&#x27;)</span><br><span class="line">            if label.split(&#x27;||&#x27;)[1]</span><br><span class="line">              - var icon_label = trim(label.split(&#x27;||&#x27;)[1])</span><br><span class="line">              if icon_label.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                i.fa-fw(class=icon_label)</span><br><span class="line">              else if icon_label.substring(0,4)==&quot;icon&quot;    </span><br><span class="line">                svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                  use(xlink:href=`#`+ icon_label)</span><br><span class="line">            span=&#x27; &#x27;+ trim(label.split(&#x27;||&#x27;)[0])</span><br><span class="line">            i.fas.fa-chevron-down.expand(class=sidebarChildHide)</span><br><span class="line">          ul.menus_item_child</span><br><span class="line">            each val,lab in value</span><br><span class="line">              li</span><br><span class="line">                a.site-page.child(href=url_for(trim(val.split(&#x27;||&#x27;)[0])))</span><br><span class="line">                  if val.split(&#x27;||&#x27;)[1]</span><br><span class="line">                    - var icon_val = trim(val.split(&#x27;||&#x27;)[1])</span><br><span class="line">                    if icon_val.substring(0,2)==&quot;fa&quot;      </span><br><span class="line">                      i.fa-fw(class=icon_val)</span><br><span class="line">                    else if icon_val.substring(0,4)==&quot;icon&quot;</span><br><span class="line">                      svg.icon(aria-hidden=&quot;true&quot;)</span><br><span class="line">                        use(xlink:href=`#`+ icon_val)</span><br><span class="line">                  span=&#x27; &#x27;+ lab</span><br></pre></td></tr></table></figure><p>最后使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: https://blog.akilar.top/ || fas fa-tasks</span><br><span class="line">  博客: / || icon-rat</span><br><span class="line">  生活 || icon-tiger :</span><br><span class="line">    相册: /gallery/ || fa fa-camera</span><br><span class="line">    追番: /bangumis/ || icon-snake</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外挂标签的使用</title>
      <link href="/2022/09/17/hexo/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/09/17/hexo/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>前言：今天把博客部署到gitee上面了，详情看： 。</p><p>后面写这篇文章觉得样式太简单了，所以我找了一下外挂标签来提高我的B格。具体操作太多了。让我写肯定要累死了，所以备份到我的博客吧，以便我写博客的时候查找，在此感谢</p><p>[Hexo Butterfly 的标签外挂（一） | MaraPython (gitee.io)</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209171728217.jpeg" style="zoom: 25%;" /></th><th><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209171728217.jpeg" style="zoom: 25%;" /></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署到gitee出现js和css文件丢失</title>
      <link href="/2022/09/17/hexo/2022-9-17-hexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%87%BA%E7%8E%B0js%E5%92%8Ccss%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1/"/>
      <url>/2022/09/17/hexo/2022-9-17-hexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%87%BA%E7%8E%B0js%E5%92%8Ccss%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo部署到gitee出现js和css文件丢失"><a href="#hexo部署到gitee出现js和css文件丢失" class="headerlink" title="hexo部署到gitee出现js和css文件丢失"></a>hexo部署到gitee出现js和css文件丢失</h1><p>前言：</p><p>因为国内能访问的代码部署平台只有gitee了，然而gitee审核太严格了，有时候好看的（涩）图片会被挂掉，都有点不敢用了。但是为了让不能上外网的小伙伴们看到我的blog，我还是研究了一下gitee，并成功部署了（庆祝）。虽然过程很头大，其中url和deploy的配置很烦，经常出错。所以总结一下同时部署gitee和github，实现大家同时访问。（对了， gitee现在不支持自定义域名，哎，无语。你们只能记住又长又臭的网址了：<a href="https://icebress.gitee.io/jack8luo/">骆小黑的一亩三分地 - 阿妮亚 (gitee.io)</a></p><details cyan><summary> github绑定了我喜欢的域名，部署配置如下 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">#url: https://blog.luoxiaohei.co</span><br><span class="line">#root: /</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">#  repo: git@gitee.com:icebress/jack8luo.git</span><br><span class="line">#  branch: master</span><br><span class="line">    github: git@github.com:jack8luo/jack8luo.github.io.git,master</span><br></pre></td></tr></table></figure>              </div>            </details><details cyan><summary> gitee个人版不能绑定自定义域名，配置如下 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Gitee URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: https://icebress.gitee.io/jack8luo</span><br><span class="line">root: /jack8luo</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@gitee.com:icebress/jack8luo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>              </div>            </details><p>掰掰! <svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--015</title>
      <link href="/2022/09/12/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-12-%E5%8A%9B%E6%89%A3hot100--015/"/>
      <url>/2022/09/12/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-12-%E5%8A%9B%E6%89%A3hot100--015/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><div class="note success"><p>📚更新于5.18</p></div><hr><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>转换为二数之和问题，为了排除重复元素，开始想到的是用hash来去重，但是三元组的map不知道能不能去重复。我来试一下：实验表明，map只有key不能重复，value是可以重复的。</p><p>1、排序2、转化为二数之和问题3、注意重复问题</p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">     <span class="type">int</span> n  = nums.<span class="built_in">size</span>();</span><br><span class="line">     <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; first++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 不能有重复出现的三元组，if语句完美规避了0处越界和first重复问题★</span></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">0</span>&amp;&amp;nums[first] == nums[first - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> third = n <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> target = -nums[first];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> second = first +<span class="number">1</span> ; second &lt; n; second++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不能有重复出现的三元组，if语句完美从first下一个元素开始和second重复问题★</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[second]+nums[third] &gt; target)&#123;</span><br><span class="line">            --third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(second == third)</span><br><span class="line">           &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[second] + nums[third]  == target)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;nums[first],nums[second],nums[third]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>&#125;;</span><br><span class="line">    Solution n;</span><br><span class="line">    <span class="keyword">auto</span> b = n.<span class="built_in">threeSum</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b[i][<span class="number">0</span>]&lt;&lt;b[i][<span class="number">1</span>]&lt;&lt;b[i][<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;b.size();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多看看STL吧。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--011</title>
      <link href="/2022/09/09/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-5-29-%E5%8A%9B%E6%89%A3hot100--011/"/>
      <url>/2022/09/09/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-5-29-%E5%8A%9B%E6%89%A3hot100--011/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><div class="note success"><p>📚更新于5.18</p></div><h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209091318849.jpeg" alt="img"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例 2：</p><p>输入：height = [1,1]<br>输出：1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>1、暴力法</p><p>两个for循环遍历所有可能的解，比较最大值即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; height.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = j-i;</span><br><span class="line">                <span class="keyword">if</span>(len*<span class="built_in">min</span>(height[i],height[j])&gt;maxArea)</span><br><span class="line">                    maxArea = len*<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    Solution b;</span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">MaxArea</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、双指针法</p><p>两个边界的问题，用双指针法最为合适，每次舍去两边界中最小的边，因为容量=最小边界*宽度。如果这个容量不是最大值，那么移动最大边界不可能再有最大值出现了，所以只能移动最小边界。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((end - begin) * <span class="built_in">min</span>(height[begin], height[end]) &gt; maxArea)</span><br><span class="line">                maxArea = (end - begin) * <span class="built_in">min</span>(height[begin], height[end]);</span><br><span class="line">            <span class="keyword">if</span> (height[begin] &gt; height[end])</span><br><span class="line">                end--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                begin++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Solution b;</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">MaxArea</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：vector真好用，比传统数组好用！</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--005</title>
      <link href="/2022/09/06/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-5-29-%E5%8A%9B%E6%89%A3hot100--005/"/>
      <url>/2022/09/06/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-5-29-%E5%8A%9B%E6%89%A3hot100--005/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><div class="note success"><p>📚更新于5.18</p></div><h1 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串"></a>5、最长回文子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有两种方法，一种是中心扩展法，比较好理解，遍历、若左边的或者右边的元素和当前元素相等则回文长度+1，若左边的和右边的相等，则回文长度+2.</p><p>第二种是动态规划，我们用 P(i,j)<em>P</em>(<em>i</em>,<em>j</em>) 表示字符串 s<em>s</em> 的第 <em>i</em> 到 <em>j</em> 个字母组成的串是否为回文串。状态转移方程：<em>P</em>(<em>i</em>,<em>j</em>)=<em>P</em>(<em>i</em>+1,<em>j</em>−1)∧(S[i]==S[j])。边界条件：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209061451886.png" alt="image-20220906145111850"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; s.<span class="built_in">size</span>(); mid++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == s[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt;= s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; s[right] == s[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; s[left] == s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                len += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; maxLen)&#123;</span><br><span class="line">                maxLeft = left;</span><br><span class="line">                maxRight = right;</span><br><span class="line">                maxLen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxLeft + <span class="number">1</span>,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中心扩展法</span></span><br><span class="line">    string S = <span class="string">&quot;abcdcba&quot;</span>;</span><br><span class="line">    Solution a;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">longestPalindrome</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">if</span> (n&lt;<span class="number">2</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; j - i &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    Solution a;</span><br><span class="line">    string s = <span class="string">&quot;dd&quot;</span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">longestPalindrome</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vector用法不是很熟练，动态规划的边界条件和状态转移方程使用不熟练。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--004</title>
      <link href="/2022/09/06/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-6-%E5%8A%9B%E6%89%A3hot100--004/"/>
      <url>/2022/09/06/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/2022-9-6-%E5%8A%9B%E6%89%A3hot100--004/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><h2 id=""><a href="#" class="headerlink" title=""></a><div class="note success"><p>📚更新于5.18</p></div></h2><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4.寻找两个有序数组的中位数"></a>4.寻找两个有序数组的中位数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我只能想到归并排序了，答案中的二分查找理解不了，所以总结一下归并排序吧。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1[<span class="number">2</span>]=&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> num2[<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">    num1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    num1[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    num2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num3[<span class="number">3</span>]=&#123;&#125;;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">1</span>)&#123;</span><br><span class="line">            num3[count++]=num2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=<span class="number">2</span>)&#123;</span><br><span class="line">                num3[count++] = num1[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1[i]&lt;num2[j])&#123;</span><br><span class="line">            num3[count++] = num1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            num3[count++] = num2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断中位数</span></span><br><span class="line">    <span class="keyword">if</span>(count%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;num3[(count/<span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;num3[count/<span class="number">2</span>]+num3[(count/<span class="number">2</span>)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多排序算法，比如快排，归并排序，二分查找算法，这些稍微复杂一点的算法都不能手撕代码。很是头疼。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word论文格式</title>
      <link href="/2022/05/31/word%E8%AE%BA%E6%96%87%E6%A0%BC%E5%BC%8F/word%E8%AE%BA%E6%96%87%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/05/31/word%E8%AE%BA%E6%96%87%E6%A0%BC%E5%BC%8F/word%E8%AE%BA%E6%96%87%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="优雅搞定word论文模板"><a href="#优雅搞定word论文模板" class="headerlink" title="优雅搞定word论文模板"></a>优雅搞定word论文模板</h1><h3 id="Q：怎么修改默认标题字体"><a href="#Q：怎么修改默认标题字体" class="headerlink" title="Q：怎么修改默认标题字体"></a>Q：怎么修改默认标题字体</h3><h3 id="A：右键点击修改。"><a href="#A：右键点击修改。" class="headerlink" title="A：右键点击修改。"></a>A：右键点击修改。</h3><p><img src="https://s2.loli.net/2022/05/24/6TN9RorpljU15uM.png" alt="image-20220524213950373"></p><h3 id="点击修改字体"><a href="#点击修改字体" class="headerlink" title="点击修改字体"></a>点击修改字体</h3><p><img src="https://s2.loli.net/2022/05/24/fmxbRcoUyikV21D.png" alt="image-20220524214048455"></p><h3 id="修改成一级标题三号中文宋体黑体居中，英文字体times-new-roman。"><a href="#修改成一级标题三号中文宋体黑体居中，英文字体times-new-roman。" class="headerlink" title="修改成一级标题三号中文宋体黑体居中，英文字体times new roman。"></a>修改成一级标题三号中文宋体黑体居中，英文字体times new roman。</h3><p><img src="https://s2.loli.net/2022/05/24/VxncEFvARZ7tzPq.png" alt="image-20220524214244871"></p><p>设置行距在段落中有，设置两倍行距。</p><p>同样地设置正文字体：宋体小四times new roman，行间距1.25。二级三级标题设置方法一样。</p><h2 id="标号如何自动生成："><a href="#标号如何自动生成：" class="headerlink" title="标号如何自动生成："></a>标号如何自动生成：</h2><h3 id="Q-如何设置自己想要的标号，比如：第一章、第1章这种。"><a href="#Q-如何设置自己想要的标号，比如：第一章、第1章这种。" class="headerlink" title="Q:如何设置自己想要的标号，比如：第一章、第1章这种。"></a>Q:如何设置自己想要的标号，比如：第一章、第1章这种。</h3><h3 id="A-点击开始选项栏中的定义新的多级列表"><a href="#A-点击开始选项栏中的定义新的多级列表" class="headerlink" title="A:点击开始选项栏中的定义新的多级列表"></a>A:点击开始选项栏中的定义新的多级列表</h3><p><img src="https://s2.loli.net/2022/05/24/CDUyq4IovX3NfSz.png" alt="image-20220524214850349"></p><p><img src="https://s2.loli.net/2022/05/24/Vsvq47aibjGlrfD.png" alt="image-20220524215407245"></p><h3 id="Q-如何设置成第一章1-1、1-2这样子"><a href="#Q-如何设置成第一章1-1、1-2这样子" class="headerlink" title="Q:如何设置成第一章1.1、1.2这样子"></a>Q:如何设置成第一章1.1、1.2这样子</h3><h3 id="A"><a href="#A" class="headerlink" title="A:"></a>A:<img src="https://s2.loli.net/2022/05/24/gbUqj3WoXRlsHVQ.png" alt="image-20220524215617233"></h3><p><img src="https://s2.loli.net/2022/05/24/MyIELQmtcxAnjdT.png" alt="image-20220524220420629"></p><h1 id="优雅搞定word论文图片-amp-表格"><a href="#优雅搞定word论文图片-amp-表格" class="headerlink" title="优雅搞定word论文图片&amp;表格"></a>优雅搞定word论文图片&amp;表格</h1><p>图片样式选择嵌入型</p><p><img src="https://s2.loli.net/2022/05/24/2OdfhGF3YaocMrA.png" alt="image-20220524220740210"></p><p><img src="https://s2.loli.net/2022/05/24/1pOgrnemJPUki7z.png" alt="image-20220524220840289"></p><p>点击引用选项中的交叉引用，可以插入引用，但是会遇见如下情况：</p><p><img src="https://s2.loli.net/2022/05/24/TSg1xhmIKn3Ajqd.png" alt="image-20220524221112075"></p><p>解决办法：ctrl + A全选，按F9刷新即可解决。</p><p>tips：两张图片并排放可以用表格实现，插入两列表格，然后插入图片，最后在表格设计中隐藏框框。</p><p>tips：两张图片组合成一张图片：1、设置图片为四周型。2、选中两张图片，点击组合。最后设置为嵌入型就可以。</p><p>Q:如果我们标题是汉字一，图片编号会变成一-1这样子，怎么办？</p><p>A:按Alt+F9，在每章标题上按ctrl+F9进入域，输入SEQ seq \h</p><p><img src="https://s2.loli.net/2022/05/24/RVdipzncq6MJOPD.png" alt="image-20220524221835190"></p><p>在空白处按ctrl+F9，输入SEQ seq \c。剪切这部分，点击ctrl+h，进入替换页面。把^d STYLEREF 1\s替换为剪切的部分。</p><p><img src="https://s2.loli.net/2022/05/24/iQblfeqks2tZV3D.png" alt="image-20220524222056969"></p><p>按Alt + F9退出域，ctrl+A全选，按F9刷新即可完成。</p><p>Tips：建议写完所有论文之后再设置这个图注。</p><p>表格和图片引用是一样的，这里不赘诉了。</p><p>设计一个好看的表结构：</p><p>插入表格，进入表格设计，右击表格点击新建表格样式，选择古典型1</p><p><img src="https://s2.loli.net/2022/05/24/nRat5yObDC6HAWp.png" alt="image-20220524222645757"></p><p>设置字体：和正文一样。</p><p>设置格式：首先在将格式应用于首列，在框线出取消右框线，再选择应用于首行，把字体改成不倾斜即可。</p><p><img src="https://s2.loli.net/2022/05/24/lBqOwHpQmbuxjFr.png" alt="image-20220524223029002"></p>]]></content>
      
      
      <categories>
          
          <category> 论文模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--003</title>
      <link href="/2022/05/29/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/05/29/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><h2 id=""><a href="#" class="headerlink" title=""></a><div class="note success"><p>📚更新于5.18</p></div></h2><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>查找子串首先想到<strong>移动窗口</strong>，设置开始和结束指针，在字符串中，随着结束指针往后移动，若一直不出现相同的字符，则字符串的长度就是最长子串，但遇到相同的字符，则需要将开始指针指向相同字符所在位置的下一个字符，更新最大子串的长度。更新最长子串的长度要保留被淘汰掉的子串，所以用max（）函数进行比较，保留最长的子串长度。如图所示：</p><p><strong>时间空间复杂度</strong>：O（n^2)、O(1)</p><p><img src="https://s2.loli.net/2022/05/29/FTylHzDCAmrBkbQ.png" alt="image-20220529135837645"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">result</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">end</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmpChar=s[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index = start; index &lt; end; index++)<span class="comment">//查找可以用hashmap优化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpChar == s[index])</span><br><span class="line">            &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">                length = end - start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result=<span class="built_in">max</span>(result,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为遍历字符串过程中，都需要用for语句判断子串中是否有相同字符出现，所以时间复杂度到了n^2。用hash表的快速查找方法，可以降低一个数量级的时间复杂度。</p><h2 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">result</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">end</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmpChar=s[end];</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">find</span>(tmpChar) != p.<span class="built_in">end</span>() &amp;&amp; p[tmpChar] &gt;=start)&#123; <span class="comment">//返回迭代器--是一个对象，作用是是遍历选择序列中的对象</span></span><br><span class="line">            <span class="comment">//p.find(tmpChar) != p.end()表示返回的两个迭代器不相等子串中找到了重复的元素。</span></span><br><span class="line">            <span class="comment">//p[tmpChar] &gt;=start 用于避免查到到之前匹配的子串，因为hash不会表中的内容一直在。想象一个hash表，里面存了（a，1）但是start已经因为其他元素更新到2了，这时候通过 int tmpChar=s[end]--p[tmpChar]匹配到的元素确实（a，1）,这是不正确的。</span></span><br><span class="line">            start = p[tmpChar]+<span class="number">1</span>;</span><br><span class="line">            length = end-start;</span><br><span class="line">        &#125;</span><br><span class="line">        p[tmpChar]=end;</span><br><span class="line">        <span class="comment">//p.insert(Mymap::value_type(&#x27;tmpChar&#x27;, end));</span></span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result=<span class="built_in">max</span>(result,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>还有一个用数捅的方法代替hash，本文不做深究。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅搞定word论文模板&amp;图片&amp;表格</title>
      <link href="/2022/05/24/%E4%BC%98%E9%9B%85%E6%90%9E%E5%AE%9Aword%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/05/24/%E4%BC%98%E9%9B%85%E6%90%9E%E5%AE%9Aword%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="优雅搞定word论文模板"><a href="#优雅搞定word论文模板" class="headerlink" title="优雅搞定word论文模板"></a>优雅搞定word论文模板</h1><h3 id="Q：怎么修改默认标题字体"><a href="#Q：怎么修改默认标题字体" class="headerlink" title="Q：怎么修改默认标题字体"></a>Q：怎么修改默认标题字体</h3><h3 id="A：右键点击修改。"><a href="#A：右键点击修改。" class="headerlink" title="A：右键点击修改。"></a>A：右键点击修改。</h3><p><img src="https://s2.loli.net/2022/05/24/6TN9RorpljU15uM.png" alt="image-20220524213950373"></p><h3 id="点击修改字体"><a href="#点击修改字体" class="headerlink" title="点击修改字体"></a>点击修改字体</h3><p><img src="https://s2.loli.net/2022/05/24/fmxbRcoUyikV21D.png" alt="image-20220524214048455"></p><h3 id="修改成一级标题三号中文宋体黑体居中，英文字体times-new-roman。"><a href="#修改成一级标题三号中文宋体黑体居中，英文字体times-new-roman。" class="headerlink" title="修改成一级标题三号中文宋体黑体居中，英文字体times new roman。"></a>修改成一级标题三号中文宋体黑体居中，英文字体times new roman。</h3><p><img src="https://s2.loli.net/2022/05/24/VxncEFvARZ7tzPq.png" alt="image-20220524214244871"></p><p>设置行距在段落中有，设置两倍行距。</p><p>同样地设置正文字体：宋体小四times new roman，行间距1.25。二级三级标题设置方法一样。</p><h2 id="标号如何自动生成："><a href="#标号如何自动生成：" class="headerlink" title="标号如何自动生成："></a>标号如何自动生成：</h2><h3 id="Q-如何设置自己想要的标号，比如：第一章、第1章这种。"><a href="#Q-如何设置自己想要的标号，比如：第一章、第1章这种。" class="headerlink" title="Q:如何设置自己想要的标号，比如：第一章、第1章这种。"></a>Q:如何设置自己想要的标号，比如：第一章、第1章这种。</h3><h3 id="A-点击开始选项栏中的定义新的多级列表"><a href="#A-点击开始选项栏中的定义新的多级列表" class="headerlink" title="A:点击开始选项栏中的定义新的多级列表"></a>A:点击开始选项栏中的定义新的多级列表</h3><p><img src="https://s2.loli.net/2022/05/24/CDUyq4IovX3NfSz.png" alt="image-20220524214850349"></p><p><img src="https://s2.loli.net/2022/05/24/Vsvq47aibjGlrfD.png" alt="image-20220524215407245"></p><h3 id="Q-如何设置成第一章1-1、1-2这样子"><a href="#Q-如何设置成第一章1-1、1-2这样子" class="headerlink" title="Q:如何设置成第一章1.1、1.2这样子"></a>Q:如何设置成第一章1.1、1.2这样子</h3><h3 id="A"><a href="#A" class="headerlink" title="A:"></a>A:<img src="https://s2.loli.net/2022/05/24/gbUqj3WoXRlsHVQ.png" alt="image-20220524215617233"></h3><p><img src="https://s2.loli.net/2022/05/24/MyIELQmtcxAnjdT.png" alt="image-20220524220420629"></p><h1 id="优雅搞定word论文图片-amp-表格"><a href="#优雅搞定word论文图片-amp-表格" class="headerlink" title="优雅搞定word论文图片&amp;表格"></a>优雅搞定word论文图片&amp;表格</h1><p>图片样式选择嵌入型</p><p><img src="https://s2.loli.net/2022/05/24/2OdfhGF3YaocMrA.png" alt="image-20220524220740210"></p><p><img src="https://s2.loli.net/2022/05/24/1pOgrnemJPUki7z.png" alt="image-20220524220840289"></p><p>点击引用选项中的交叉引用，可以插入引用，但是会遇见如下情况：</p><p><img src="https://s2.loli.net/2022/05/24/TSg1xhmIKn3Ajqd.png" alt="image-20220524221112075"></p><p>解决办法：ctrl + A全选，按F9刷新即可解决。</p><p>tips：两张图片并排放可以用表格实现，插入两列表格，然后插入图片，最后在表格设计中隐藏框框。</p><p>tips：两张图片组合成一张图片：1、设置图片为四周型。2、选中两张图片，点击组合。最后设置为嵌入型就可以。</p><p>Q:如果我们标题是汉字一，图片编号会变成一-1这样子，怎么办？</p><p>A:按Alt+F9，在每章标题上按ctrl+F9进入域，输入SEQ seq \h</p><p><img src="https://s2.loli.net/2022/05/24/RVdipzncq6MJOPD.png" alt="image-20220524221835190"></p><p>在空白处按ctrl+F9，输入SEQ seq \c。剪切这部分，点击ctrl+h，进入替换页面。把^d STYLEREF 1\s替换为剪切的部分。</p><p><img src="https://s2.loli.net/2022/05/24/iQblfeqks2tZV3D.png" alt="image-20220524222056969"></p><p>按Alt + F9退出域，ctrl+A全选，按F9刷新即可完成。</p><p>Tips：建议写完所有论文之后再设置这个图注。</p><p>表格和图片引用是一样的，这里不赘诉了。</p><p>设计一个好看的表结构：</p><p>插入表格，进入表格设计，右击表格点击新建表格样式，选择古典型1</p><p><img src="https://s2.loli.net/2022/05/24/nRat5yObDC6HAWp.png" alt="image-20220524222645757"></p><p>设置字体：和正文一样。</p><p>设置格式：首先在将格式应用于首列，在框线出取消右框线，再选择应用于首行，把字体改成不倾斜即可。</p><p><img src="https://s2.loli.net/2022/05/24/lBqOwHpQmbuxjFr.png" alt="image-20220524223029002"></p>]]></content>
      
      
      <categories>
          
          <category> 论文模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion如何创建并运行C/C++文件</title>
      <link href="/2022/05/24/Clion%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CC-C-%E6%96%87%E4%BB%B6/"/>
      <url>/2022/05/24/Clion%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CC-C-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Clion如何创建并运行C-C-文件"><a href="#Clion如何创建并运行C-C-文件" class="headerlink" title="Clion如何创建并运行C/C++文件"></a>Clion如何创建并运行C/C++文件</h1><p>主要步骤如下：</p><p>第一步： 新建一个project</p><p><img src="https://img-blog.csdnimg.cn/202002282029161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzY2NTcx,size_16,color_FFFFFF,t_70" alt=""></p><p>第二步： 新建一个C/C++文件</p><p><img src="https://img-blog.csdnimg.cn/20200228203510712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzY2NTcx,size_16,color_FFFFFF,t_70" alt=""></p><p>第三步： 进入界面</p><p><img src="https://img-blog.csdnimg.cn/20200228203545167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzY2NTcx,size_16,color_FFFFFF,t_70" alt=""></p><p>第四步：</p><pre><code>    默认生成了main.c文件，但是我们不能运行。我们缺少编译环境，点击Setting打开设置，搜索Toolchains，发现Clion提供的编译环境有几种MinGW，CygWin，Visual studio等。我此处选择的时MinGW，因为我的安装了MinGW，默认选择了MinGW，如果你没有下载的话，后面的位置原先有个download，点击就可以下载了。安装好之后，然后再Environment右侧选择mingw-w64的位置即可。</code></pre><p><img src="https://img-blog.csdnimg.cn/20200228203631876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzY2NTcx,size_16,color_FFFFFF,t_70" alt=""></p><p>第五步： 运行main.c文件即可</p><p><img src="https://img-blog.csdnimg.cn/20200228203650243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzY2NTcx,size_16,color_FFFFFF,t_70" alt=""></p><p>以上： 就是如何创建并运行一个C/C++文件的步骤。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++、clion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--002</title>
      <link href="/2022/05/19/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2022/05/19/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>📖每日更新一道力扣hot100</p></div><div class="note success"><p>📚更新于5.18</p></div><hr><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><mark class="hl-label red">eg：</mark> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，比如 <code>987 + 23 = 987 + 023 = 1010</code></p><p>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个<mark class="hl-label blue">预先指针pre</mark> ，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</p><p><strong>过程如图所示：</strong></p><mark class="hl-label pink">1、初始化</mark> <p><img src="https://s2.loli.net/2022/05/19/xaudLjwIZAX1DOU.png" style="zoom:50%;" /></p><mark class="hl-label pink">2、过程</mark> <p><img src="https://s2.loli.net/2022/05/19/SOIz7tjnEhuqxXg.png" style="zoom:50%;" /></p><mark class="hl-label pink">3、结果</mark> <p><img src="https://s2.loli.net/2022/05/19/28JXya1KdxwNUec.png" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//初始化预先指针</span></span><br><span class="line">        ListNode* nex = pre; <span class="comment">//设置移动指针</span></span><br><span class="line">        <span class="type">int</span> tag = <span class="number">0</span>; <span class="comment">//进位标志位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            <span class="type">int</span> y = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            <span class="type">int</span> sum = x + y + tag;</span><br><span class="line">            tag = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            nex-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            nex = nex-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>)</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(tag == <span class="number">1</span>)&#123;  <span class="comment">// 考虑最后的进位1</span></span><br><span class="line">            nex-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(tag);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="c-结构体"><a href="#c-结构体" class="headerlink" title="c++结构体"></a>c++结构体</h2><p>相关操作及注意事项：</p><h5 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">My</span>&#123;</span><br><span class="line">    My *left;</span><br><span class="line">    My *right;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">My</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">My</span>(<span class="type">int</span> val):<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="访问结构体元素"><a href="#访问结构体元素" class="headerlink" title="访问结构体元素"></a>访问结构体元素</h5><p>结构体中的变量，可以直接通过<mark class="hl-label pink">点操作符</mark> 来访问。</p><p>而对于结构体指针而言：必须通过<mark class="hl-label pink">->符号</mark> 来访问指针所指结构体的变量。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My m;</span><br><span class="line">    m.val = <span class="number">1</span>;</span><br><span class="line">    My *mm;</span><br><span class="line">    mm = &amp;m;</span><br><span class="line">    cout&lt;&lt;mm-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>声明一个结构体指针记得初始化，一定要初始化，不初始化会出事（重要的事情说三遍）下面代码就会报错，没有初始化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My *m;</span><br><span class="line">    m-&gt;val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用new申请了内存空间。问题即可解决。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My *m;</span><br><span class="line">    m = <span class="keyword">new</span> <span class="built_in">My</span>(<span class="number">3</span>);</span><br><span class="line">    m-&gt;val = <span class="number">4</span>;</span><br><span class="line">    cout&lt;&lt;m-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100--001</title>
      <link href="/2022/05/18/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/05/18/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>题目表述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出<mark class="hl-label pink">和</mark> 为目标值 target  的那两个整数，并返回它们的数组下标。</p><p>1、你可以假设每种输入只会对应<mark class="hl-label pink">一个答案</mark> 。但是，数组中同一个元素在答案里不能重复出现。</p><p>2、你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：两数相加=9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目要求时间复杂度在<mark class="hl-label red">O(n2)</mark> 以下，所以暴力法是不可行的。</p><p>哈希表中查找的时间复杂度是<mark class="hl-label red">O（1）</mark> 。可以用哈希表对数组进行存储。例如：</p><p><img src="https://s2.loli.net/2022/05/18/Bh48vJZVN3lYXmy.png" alt=""></p><p><img src="https://s2.loli.net/2022/05/18/SlHEw2LkaxXW5BI.png" alt=""></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            a.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(nums[i],i));  <span class="comment">//初始化哈希表a</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">count</span>(target-nums[i]) &gt; <span class="number">0</span> &amp;&amp; (a[target-nums[i]] != i)) <span class="comment">//a.count(target-nums[i]) &gt; 0:判断哈希表中是否有两个相加等于target的数；a[target-nums[i]] != i：排除两个相同的数相加=target//a.count(i)查找到返回1，否则返回0；以为数组不含相同整数</span></span><br><span class="line">            &#123;</span><br><span class="line">                b[<span class="number">0</span>] = i;</span><br><span class="line">                b[<span class="number">1</span>] = a[target-nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充一些与哈希表有关的操作："><a href="#补充一些与哈希表有关的操作：" class="headerlink" title="补充一些与哈希表有关的操作："></a>补充一些与哈希表有关的操作：</h2><h3 id="初始化和迭代："><a href="#初始化和迭代：" class="headerlink" title="初始化和迭代："></a>初始化和迭代：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Mymap::const_iterator it = c1.<span class="built_in">begin</span>(); it != c1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">output:</span><br><span class="line">[a,<span class="number">1</span>],[b,<span class="number">2</span>],[c,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="函数clear："><a href="#函数clear：" class="headerlink" title="函数clear："></a>函数clear：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">c1.<span class="built_in">clear</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size == &quot;</span> &lt;&lt; c1.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;empty() == &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; c1.<span class="built_in">empty</span>() &lt;&lt; std::endl; output:</span><br><span class="line">size == <span class="number">0</span> empty（）== <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="函数count（查找与指定元素匹配的数目）："><a href="#函数count（查找与指定元素匹配的数目）：" class="headerlink" title="函数count（查找与指定元素匹配的数目）："></a>函数count（查找与指定元素匹配的数目）：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;count(&#x27;A&#x27;) == &quot;</span> &lt;&lt; c1.<span class="built_in">count</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;count(&#x27;b&#x27;) == &quot;</span> &lt;&lt; c1.<span class="built_in">count</span>(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; std::endl; output:</span><br><span class="line">count（<span class="string">&#x27;A&#x27;</span>）== <span class="number">0</span> count（<span class="string">&#x27;b&#x27;</span>）== <span class="number">1</span></span><br></pre></td></tr></table></figure><p>函数find（查找指定元素）返回false和true。</p><p>还有各种各样的函数功能，记不了那么多了。</p><h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p>其实哈希表在数据结构中已经学过了，哈希函数是从关键字集合到地址集合的<mark class="hl-label pink">映像</mark>  。哈希函数其实是一个压缩映像，那么这种情况就不可避免的产生冲突，那么在建造哈希表时不仅要设定一个好的哈希函数，还要设定一种处理冲突的方法。</p><p>这道题就没有处理冲突的方法，因为它设置了一个和数组个数一样大的地址空间。这道题就是用到了哈希表查找的复杂度为1，并没有用到压缩存储的思想，更没有用到处理冲突的方法。常见的<mark class="hl-label pink">哈希函数</mark> 在数据结构中已经学习过了：直接定址法、除留余数法。常见的<mark class="hl-label pink">处理冲突方法</mark>  :开放定址法。具体先不管，挺容易懂得，代码实现就不一定了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++、算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用局域网实现iphone和windows文件互传||不再使用qq微信传文件</title>
      <link href="/2022/05/15/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/iphone%E5%92%8Cwindows%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E4%BC%A0/%E4%BD%BF%E7%94%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%9E%E7%8E%B0iphone%E5%92%8Cwindows%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/"/>
      <url>/2022/05/15/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/iphone%E5%92%8Cwindows%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E4%BC%A0/%E4%BD%BF%E7%94%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%9E%E7%8E%B0iphone%E5%92%8Cwindows%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>遇到的bug：</p><h1 id="内容不可用无法显示文件夹内容"><a href="#内容不可用无法显示文件夹内容" class="headerlink" title="内容不可用无法显示文件夹内容"></a>内容不可用无法显示文件夹内容</h1><p>出错原因是啥不知道</p><p>解决办法：删除链接的服务器然后重新连接。</p><p>共享文件夹方法：</p><h6 id="1、在-Windows-电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。"><a href="#1、在-Windows-电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。" class="headerlink" title="1、在 Windows 电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。"></a>1、在 Windows 电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。</h6><p><img src="https://pic4.zhimg.com/80/v2-712d2769bf193c7a3b92f5639ba6d2d7_720w.jpg" alt="img"></p><h6 id="2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」"><a href="#2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」" class="headerlink" title="2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」"></a>2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」</h6><p><img src="https://pic1.zhimg.com/80/v2-669f23527c738dd93f23f6bb82967568_720w.jpg" alt="img"></p><p>3、在新打开的「权限」窗口中选中 「Everyone」，在「Everyone」下方勾选「完全控制」选项。</p><p><img src="https://pic4.zhimg.com/80/v2-131545f3e481709230b2b2d74fc8a2a7_720w.jpg" alt="img"></p><p>4、回到最开始的「属性」窗口，点击「共享」，在弹出的「网络访问」窗口，选择「Everyone」后，点击「添加」。</p><p><img src="https://pic4.zhimg.com/80/v2-2e4f68e3b5d0a93cd4923305520b2aef_720w.jpg" alt="img"></p><p>5、添加了 Everyone 用户后，将文件夹的权限改为「读取/写入」，点击右下角的「共享」。</p><p><img src="https://pic1.zhimg.com/80/v2-eadec0f44566d1b5490613e2661df6a8_720w.jpg" alt="img"></p><p>6、查看自己的ipv4地址。用手机文件app连接到该ip，输入用户名和密码，即可共享此文件。<img src="https://pic1.zhimg.com/80/v2-3909bf6dd6e6fece8e77c2ede991eba0_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-707141eb32295cc607880e44095636f4_720w.jpg" alt="img"></p><p>注意：名称：29133密码：luohao123…</p>]]></content>
      
      
      <categories>
          
          <category> 电脑使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
