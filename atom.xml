<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骆小黑</title>
  
  <subtitle>阿妮亚</subtitle>
  <link href="https://blog.luoxiaohei.co/atom.xml" rel="self"/>
  
  <link href="https://blog.luoxiaohei.co/"/>
  <updated>2023-04-21T09:53:55.583Z</updated>
  <id>https://blog.luoxiaohei.co/</id>
  
  <author>
    <name>骆小黑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下epoll_BS服务器开发</title>
    <link href="https://blog.luoxiaohei.co/2023/04/20/Linux/%E9%83%A8%E7%BD%B2epoll_BS/"/>
    <id>https://blog.luoxiaohei.co/2023/04/20/Linux/%E9%83%A8%E7%BD%B2epoll_BS/</id>
    <published>2023-04-20T12:52:55.000Z</published>
    <updated>2023-04-21T09:53:55.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部署epoll-BS"><a href="#部署epoll-BS" class="headerlink" title="部署epoll_BS"></a>部署epoll_BS</h1><p>项目地址：<a href="https://github.com/jack8luo/epoll_BS">jack8luo/epoll_BS: linux下的一个基于epoll多路IO转发的本地文件传输服务器。没有做压力测试，没有使用线程池。 (github.com)</a></p><h2 id="远程操作服务器SSH："><a href="#远程操作服务器SSH：" class="headerlink" title="远程操作服务器SSH："></a>远程操作服务器SSH：</h2><p>下载一个连接服务器的软件——securecrx可以远程操作服务器。        需要在服务器上安装ssh服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开机自动启动ssh命令</span><br><span class="line">sudo systemctl enable ssh</span><br><span class="line"> </span><br><span class="line"># 关闭ssh开机自动启动命令</span><br><span class="line">sudo systemctl disable ssh</span><br><span class="line"> </span><br><span class="line"># 单次开启ssh</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line"> </span><br><span class="line"># 单次关闭ssh</span><br><span class="line">sudo systemctl stop ssh</span><br><span class="line"> </span><br><span class="line"># 设置好后重启系统</span><br><span class="line">reboot</span><br><span class="line"> </span><br><span class="line">#查看ssh是否启动，看到Active: active (running)即表示成功</span><br><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure><h2 id="远程复制服务器文件FTP"><a href="#远程复制服务器文件FTP" class="headerlink" title="远程复制服务器文件FTP"></a>远程复制服务器文件FTP</h2><p>使用 FileZilla 工具互传<br>FileZilla是一款免费的工具，是基于 FTP 协议进行文件互传的，在传输过程中我们的ubuntu是作为服务器， FileZilla 工具则是作为客户端。</p><p>2.1 ubuntu安装 FTP服务<br>在ubuntu终端下输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><p>安装完之后检查 /etc/vsftpd.conf 配置文件</p><p>输入如下命令打开配置文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi  /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>然后检查下图 28 和 31 行的内容是否有被注释掉，如果前面有 “#” 号注释起来的话，就去掉即可。</p><p>修改完之后，重启FTP服务，如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure><p>2.2 windows安装和配置FileZilla<br>FileZilla 客户端下载和安装</p><p>FileZilla工具可以去官网下载即可，<a href="https://www.filezilla.cn/download">https://www.filezilla.cn/download</a></p><p>我们要安装的是客户端，选择对应版本的客户端下载，然后一路 next 安装即可。</p><p>FileZilla 软件配置和连接ubuntu</p><p>打开 FileZilla 软件，然后选择：文件 -&gt; 站点管理器 -&gt; 点击新增站点，然后配置连接参数，如下图：</p><p>点击连接之后，就可以看到ubuntu下的文件了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/325c85dc4a7b438cbd55469772cc863f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbHVvYmVpaGFp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>我们要把windows的文件拷贝到ubuntu中，直接在左侧把windows下的目录文件拖到右侧ubuntu中指定的目录即可。</p><h2 id="push代码中遇到的问题"><a href="#push代码中遇到的问题" class="headerlink" title="push代码中遇到的问题"></a>push代码中遇到的问题</h2><p><a href="https://blog.csdn.net/gongdamrgao/article/details/115032436">关于git的问题：error: src refspec main does not match any_TripleGold.的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;部署epoll-BS&quot;&gt;&lt;a href=&quot;#部署epoll-BS&quot; class=&quot;headerlink&quot; title=&quot;部署epoll_BS&quot;&gt;&lt;/a&gt;部署epoll_BS&lt;/h1&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/jack8</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux线程Day9</title>
    <link href="https://blog.luoxiaohei.co/2023/04/06/Linux/Linux%E7%BA%BF%E7%A8%8BDay9/"/>
    <id>https://blog.luoxiaohei.co/2023/04/06/Linux/Linux%E7%BA%BF%E7%A8%8BDay9/</id>
    <published>2023-04-06T12:52:55.000Z</published>
    <updated>2023-04-06T13:10:24.095Z</updated>
    
    <content type="html"><![CDATA[<p>守护进程：</p><pre><code>daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。不受用户登录注销影响。通常采用以d结尾的命名方式。</code></pre><p>守护进程创建步骤：</p><pre><code>1. fork子进程，让父进程终止。2. 子进程调用 setsid() 创建新会话3. 通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。4. 通常根据需要，重设umask文件权限掩码，影响新文件的创建权限。  022 -- 755    0345 --- 432   r---wx-w-   4225. 通常根据需要，关闭/重定向 文件描述符6. 守护进程 业务逻辑。while（）</code></pre><p>=============================================================</p><p>线程概念：</p><pre><code>进程：有独立的 进程地址空间。有独立的pcb。    分配资源的最小单位。线程：有独立的pcb。没有独立的进程地址空间。    最小单位的执行。ps -Lf 进程id     ---&gt; 线程号。LWP  --》cpu 执行的最小单位。</code></pre><p>线程共享：</p><pre><code>独享 栈空间（内核栈、用户栈）共享 ./text./data ./rodataa ./bsss heap  ---&gt; 共享【全局变量】（errno）</code></pre><p>线程控制原语：</p><pre><code>pthread_t pthread_self(void);    获取线程id。 线程id是在进程地址空间内部，用来标识线程身份的id号。    返回值：本线程id检查出错返回：  线程中。    fprintf(stderr, &quot;xxx error: %s\n&quot;, strerror(ret));int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg); 创建子线程。    参1：传出参数，表新创建的子线程 id    参2：线程属性。传NULL表使用默认属性。    参3：子线程回调函数。创建成功，ptherad_create函数返回时，该函数会被自动调用。    参4：参3的参数。没有的话，传NULL    返回值：成功：0        失败：errno循环创建N个子线程：    for （i = 0； i &lt; 5; i++）        pthread_create(&amp;tid, NULL, tfn, (void *)i);   // 将 int 类型 i， 强转成 void *， 传参。    void pthread_exit(void *retval);  退出当前线程。    retval：退出值。 无退出值时，NULL    exit();    退出当前进程。    return: 返回到调用者那里去。    pthread_exit(): 退出当前线程。int pthread_join(pthread_t thread, void **retval);    阻塞 回收线程。    thread: 待回收的线程id    retval：传出参数。 回收的那个线程的退出值。        线程异常借助，值为 -1。    返回值：成功：0        失败：errnoint pthread_detach(pthread_t thread);        设置线程分离    thread: 待分离的线程id</code></pre><p>​<br>        返回值：成功：0</p><pre><code>        失败：errno    int pthread_cancel(pthread_t thread);        杀死一个线程。  需要到达取消点（保存点）    thread: 待杀死的线程id    返回值：成功：0        失败：errno    如果，子线程没有到达取消点， 那么 pthread_cancel 无效。    我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();    成功被 pthread_cancel() 杀死的线程，返回 -1.使用pthead_join 回收。线程控制原语                    进程控制原语pthread_create()                fork();pthread_self()                    getpid();pthread_exit()                    exit();         / return pthread_join()                    wait()/waitpid()pthread_cancel()                kill()pthread_detach()</code></pre><p>线程属性：</p><pre><code>设置分离属性。pthread_attr_t attr      创建一个线程属性结构体变量pthread_attr_init(&amp;attr);    初始化线程属性pthread_attr_setdetachstate(&amp;attr,  PTHREAD_CREATE_DETACHED);        设置线程属性为 分离态pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程pthread_attr_destroy(&amp;attr);    销毁线程属性</code></pre><p>不要在程序中同时用线程和信号。</p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;守护进程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。

不受用户登录注销影响。通常采用以d结尾的命名方式。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;守护进程创建步骤：&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux信号Day8</title>
    <link href="https://blog.luoxiaohei.co/2023/04/05/Linux/Linux%E4%BF%A1%E5%8F%B7Day8/"/>
    <id>https://blog.luoxiaohei.co/2023/04/05/Linux/Linux%E4%BF%A1%E5%8F%B7Day8/</id>
    <published>2023-04-05T12:52:55.000Z</published>
    <updated>2023-04-06T08:41:28.774Z</updated>
    
    <content type="html"><![CDATA[<p>信号共性：</p><pre><code>简单、不能携带大量信息、满足条件才发送。</code></pre><p>信号的特质：</p><pre><code>信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。所有信号的产生及处理全部都是由【内核】完成的。</code></pre><p>信号相关的概念：</p><blockquote><p>产生信号：</p><pre><code> 1. 按键产生 2. 系统调用产生 3. 软件条件产生 4. 硬件异常产生 5. 命令产生</code></pre><p>概念：<br>    未决：产生与递达之间状态。  </p><p>​    递达：产生并且送达到进程。直接被内核处理掉。</p><p>​    信号处理方式： 执行默认处理动作、忽略、捕捉（自定义）</p><p>​    阻塞信号集（信号屏蔽字）： 本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。</p><p>​    未决信号集：本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。</p></blockquote><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230406101059515.png" alt="阻塞和未决"></p><p>kill库函数 kill（pid_t ，int ）：给某个进程发送一个信号</p><p>kill命令 和 kill函数：</p><pre><code>int kill（pid_t pid, int signum）参数：    pid:     &gt; 0:发送信号给指定进程        = 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。        &lt; -1: 取绝对值，发送信号给该绝对值所对应的进程组的所有组员。        = -1：发送信号给，有权限发送的所有进程。    signum：待发送的信号返回值：    成功： 0    失败： -1 errno</code></pre><p>alarm 函数：使用自然计时法。</p><pre><code>定时发送SIGALRM给当前进程。unsigned int alarm(unsigned int seconds);    seconds：定时秒数    返回值：上次定时剩余时间。        无错误现象。    alarm（0）； 取消闹钟。time 命令 ： 查看程序执行时间。   实际时间 = 用户时间 + 内核时间 + 等待时间。  --》 优化瓶颈 IO</code></pre><p>setitimer函数：</p><pre><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);参数：    which：    ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM        ITIMER_VIRTUAL: 采用用户空间计时  ---&gt; SIGVTALRM        ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF    new_value：定时秒数               类型：struct itimerval &#123;                           struct timeval &#123;                               time_t      tv_sec;         /* seconds */                               suseconds_t tv_usec;        /* microseconds */                       &#125;it_interval;---&gt; 周期定时秒数                            struct timeval &#123;                               time_t      tv_sec;                                        suseconds_t tv_usec;                               &#125;it_value;  ---&gt; 第一次定时秒数                      &#125;;    old_value：传出参数，上次定时剩余时间。    e.g.        struct itimerval new_t;            struct itimerval old_t;            new_t.it_interval.tv_sec = 0;        new_t.it_interval.tv_usec = 0;        new_t.it_value.tv_sec = 1;        new_t.it_value.tv_usec = 0;        int ret = setitimer(&amp;new_t, &amp;old_t);  定时1秒返回值：    成功： 0    失败： -1 errno</code></pre><p>其他几个发信号函数：</p><pre><code>int raise(int sig);void abort(void);</code></pre><p>信号集操作函数：内核不允许操作未决信号集，但是可以操作阻塞信号集影响未决信号集</p><pre><code>sigset_t set;  自定义信号集。sigemptyset(sigset_t *set);    清空信号集sigfillset(sigset_t *set);    全部置1sigaddset(sigset_t *set, int signum);    将一个信号添加到集合中sigdelset(sigset_t *set, int signum);    将一个信号从集合中移除sigismember（const sigset_t *set，int signum); 判断一个信号是否在集合中。 在--》1， 不在--》0</code></pre><p>设置信号屏蔽字和解除屏蔽：</p><pre><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    how:    SIG_BLOCK:    设置阻塞        SIG_UNBLOCK:    取消阻塞        SIG_SETMASK:    用自定义set替换mask。    set：    自定义set    oldset：旧有的 mask。</code></pre><p>查看未决信号集：</p><pre><code>int sigpending(sigset_t *set);    set： 传出的 未决信号集。</code></pre><p>【信号捕捉】：</p><pre><code>signal();【sigaction();】 重点！！！</code></pre><p>​        </p><p>信号捕捉特性：</p><pre><code>1. 捕捉函数执行期间，信号屏蔽字 由 mask --&gt; sa_mask , 捕捉函数执行结束。 恢复回mask2. 捕捉函数执行期间，本信号自动被屏蔽(sa_flgs = 0).3. 捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</code></pre><p>借助信号完成 子进程回收。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;信号共性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;简单、不能携带大量信息、满足条件才发送。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;信号的特质：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程Day7</title>
    <link href="https://blog.luoxiaohei.co/2023/04/04/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day7/"/>
    <id>https://blog.luoxiaohei.co/2023/04/04/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day7/</id>
    <published>2023-04-04T12:52:55.000Z</published>
    <updated>2023-04-05T08:34:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l"><a href="#pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l" class="headerlink" title="pipe管道： 用于有血缘关系的进程间通信。  ps aux | grep         ls | wc -l"></a>pipe管道： 用于有血缘关系的进程间通信。  ps aux | grep         ls | wc -l</h2><pre><code>父子进程间通信：兄弟进程间通信：</code></pre><h2 id="fifo管道：可以用于无血缘关系的进程间通信。"><a href="#fifo管道：可以用于无血缘关系的进程间通信。" class="headerlink" title="fifo管道：可以用于无血缘关系的进程间通信。"></a>fifo管道：可以用于无血缘关系的进程间通信。</h2><pre><code>命名管道：  mkfifo 无血缘关系进程间通信：    读端，open fifo O_RDONLY    写端，open fifo O_WRONLY</code></pre><h2 id="文件实现进程间通信-很早以前的东西，过时了-："><a href="#文件实现进程间通信-很早以前的东西，过时了-：" class="headerlink" title="文件实现进程间通信(很早以前的东西，过时了)："></a>文件实现进程间通信(很早以前的东西，过时了)：</h2><p><strong>打开的文件是内核中的一块缓冲区</strong>。<strong>多个</strong>无血缘关系的进程，可以<strong>同时</strong>访问该文件。</p><h2 id="★共享内存映射"><a href="#★共享内存映射" class="headerlink" title="★共享内存映射:"></a>★共享内存映射:</h2><p>void <em>mmap(void </em>addr, size_t length, int prot, int flags, int fd, off_t offset);        创建共享内存映射</p><blockquote><p>参数：<br>    addr：     指定映射区的首地址。通常传NULL，表示让系统自动分配</p><p>​    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</p><p>​    prot：    共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p><p>​    flags：    标注共享内存的共享属性。MAP_SHARED：会<strong>同步内存到磁盘上</strong>、MAP_PRIVATE</p><p>​    fd:    用于创建共享内存映射区的那个文件的 文件描述符。</p><p>​    offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</p><p>返回值：</p><p>​    成功：映射区的首地址。</p><p>​    失败：MAP_FAILED 宏实质是：(void*(-1))， errno</p></blockquote><p>int munmap(void *addr, size_t length);        释放映射区。</p><pre><code>addr：mmap 的返回值length：大小</code></pre><h2 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a>使用注意事项：</h2><blockquote><ol><li><p>用于创建映射区的文件大小为 0，实际指定非0大小创建映射区，出 “总线错误”。</p></li><li><p>用于创建映射区的文件大小为 0，实际制定0大小创建映射区， 出 “无效参数”。</p></li><li><p>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</p></li><li><p>创建映射区，需要read权限。当访问权限指定为 “共享”MAP_SHARED时， mmap的读写权限，应该 &lt;=文件的open权限。    只写不行。 私有MAP_PRIVATE可以改，见第10点。</p></li><li><p>文件描述符fd，在mmap创建映射区完成即可关闭。后续访问文件，用 地址访问。</p></li><li><p>offset 必须是 4096的整数倍。（MMU 映射的最小单位 4k ）</p></li><li><p>对申请的映射区内存，不能越界访问。 </p></li><li><p>munmap用于释放的 地址，必须是mmap申请返回的地址。</p></li><li><p>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</p></li><li><p>映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。</p></li></ol></blockquote><p>mmap函数的保险调用方式：</p><pre><code>1. fd = open（&quot;文件名&quot;， O_RDWR）;2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</code></pre><p>父子进程使用 mmap 进程间通信：</p><pre><code>父进程 先 创建映射区。 open（ O_RDWR） mmap( MAP_SHARED );指定 MAP_SHARED 权限fork() 创建子进程。一个进程读， 另外一个进程写。</code></pre><p>无血缘关系进程间 mmap 通信：                  【会写】</p><pre><code>两个进程 打开同一个文件，创建映射区。指定flags 为 MAP_SHARED。一个进程写入，另外一个进程读出。【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。                fifo：数据只能一次读取。</code></pre><p>匿名映射：只能用于 血缘关系进程间通信。</p><pre><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></pre><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l&quot;&gt;&lt;a href=&quot;#pipe管道：-用于有血缘关系的进程间通信。-ps-aux-grep-ls-wc-l&quot; class=&quot;headerlink&quot; title=&quot;pipe管道： </summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
    <id>https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</id>
    <published>2023-04-03T18:44:50.000Z</published>
    <updated>2023-04-25T11:52:18.214Z</updated>
    
    <content type="html"><![CDATA[<h4 id="209-长度最小的子数组（滑动窗口）"><a href="#209-长度最小的子数组（滑动窗口）" class="headerlink" title="209. 长度最小的子数组（滑动窗口）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>（滑动窗口）</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        cout&lt;&lt;INT_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; j-i+<span class="number">1</span>)</span><br><span class="line">                    min = j-i+<span class="number">1</span>;</span><br><span class="line">                temp -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == nums.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口，当不好判断移动的条件时，可以借助map判断 i 到 j 数组中是否种类为两种，使用函数判断种类是否大于2的话，复杂度就起来了。所以只能用map</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            ++cnt[fruits[right]];</span><br><span class="line">            <span class="keyword">while</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;<span class="comment">//left移动至erase一个</span></span><br><span class="line">                <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[left]);</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-1"><a href="#类似题目-1" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        //移动窗口</span><br><span class="line">        map&lt;char,int&gt;  hash;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int m = t.size();</span><br><span class="line">        for(char ch : t) hash[ch]--;</span><br><span class="line"></span><br><span class="line">        int min = INT_MAX;</span><br><span class="line">        int start;</span><br><span class="line">        for (int i = 0,j = 0, cnt = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 双指针移动 */</span><br><span class="line">            hash[s[i]]++;</span><br><span class="line">            if(hash[s[i]] &lt;= 0) cnt++;//s[i]是t中元素</span><br><span class="line">            while(cnt == m &amp;&amp; hash[s[j]] &gt; 0) hash[s[j++]]--;//j右移</span><br><span class="line">            if(cnt == m &amp;&amp; min &gt; i - j + 1)&#123;</span><br><span class="line">                min = i - j + 1;</span><br><span class="line">                start = j;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        if(min == INT_MAX) //若没有覆盖子串</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        return s.substr(start,min);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>滑动窗口通常要判断左移右移的边界条件，通常用map进行判断</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;209-长度最小的子数组（滑动窗口）&quot;&gt;&lt;a href=&quot;#209-长度最小的子数组（滑动窗口）&quot; class=&quot;headerlink&quot; title=&quot;209. 长度最小的子数组（滑动窗口）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/pr</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>双指针总结</title>
    <link href="https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/"/>
    <id>https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/</id>
    <published>2023-04-03T18:44:50.000Z</published>
    <updated>2023-04-15T09:28:56.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>这里使用双指针是因为我们暴力求解问题时，需要循环遍历两遍数组。</p><p>所以在这里可以<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>暴力过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif" alt="27.移除元素-暴力解法"></p><p>双指针过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>使用双指针，指针i指向想要结果的数组尾。j指针用于判断我们i和j元素是否相等时进行以下操作：1、i=j，i不动，j++；2、i！=j，i++，j++。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-1"><a href="#类似题目-1" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h4><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>不借用其他数组，原地实现很容易就想到双指针。</p><p>双指针i，j<strong>同向</strong>且<strong>同时</strong>跑，如果i元素=0，j就找个不为零的数和i替换，最后结束判断是j跑到了数组尾部。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i,j;i,j&lt;nums.<span class="built_in">size</span>();i++,j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j] == <span class="number">0</span> &amp;&amp; j &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-2"><a href="#类似题目-2" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="844-比较含退格的字符串（快慢指针）"><a href="#844-比较含退格的字符串（快慢指针）" class="headerlink" title="844. 比较含退格的字符串（快慢指针）"></a><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a>（快慢指针）</h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;ac&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;&quot;。</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>因为学会了双指针，结果在这道题倒了。</p><p>这道题使用双指针的<strong>快慢指针</strong>，low指向字符串的有效字符尾部，fast遍历字符串就可以。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function">string <span class="title">result</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span> ;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(fast;fast&lt;a.<span class="built_in">length</span>();fast++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[fast] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; low != <span class="number">0</span>)</span><br><span class="line">                    low--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[fast] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    a[low++] = a[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">substr</span>(<span class="number">0</span>,low);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">result</span>(s) == <span class="built_in">result</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类似题目-3"><a href="#类似题目-3" class="headerlink" title="类似题目"></a>类似题目</h2><h4 id="977-有序数组的平方（首尾指针）"><a href="#977-有序数组的平方（首尾指针）" class="headerlink" title="977. 有序数组的平方（首尾指针）"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>（首尾指针）</h4><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>认真观察知道数组最左边和最右边的数一定有最大的一个数。可以在首尾设置两个指针，这样比较首尾值的大小，就可以依次确定最大的数。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> pos = j;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]*nums[i] &lt;= nums[j]*nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[pos--] = nums[j]*nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]*nums[i] &gt; nums[j]*nums[j])&#123;</span><br><span class="line">                nums1[pos--] = nums[i]*nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>1、双指针有首尾指针和快慢指针</p><p>2、</p><p>if 、else if 中有比如上面的</p><p>if(a[fast] == ‘#’ &amp;&amp; low != 0)<br>                    low—;<br>else if(a[fast] != ‘#’)<br>                    a[low++] = a[fast];</p><p>a[fast] == ‘#’</p><p>a[fast] != ‘#’</p><p><strong>这两个互斥的，可以考虑换一个顺序：</strong></p><p>if(a[fast] != ‘#’)</p><p>​          a[low++] = a[fast];</p><p>else if(low &gt; 0)</p><p>​          low—;</p><p>这样代码更容易理解一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;27-移除元素&quot;&gt;&lt;a href=&quot;#27-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27. 移除元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-element/&quot;&gt;27. 移除元素&lt;</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://blog.luoxiaohei.co/2023/04/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2023-04-03T18:30:30.000Z</published>
    <updated>2023-04-04T14:04:02.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Q:看到log（n）就能想到二分查找，但是二分查找里面怎么找到第一个重复元素呢？</p><p>A:我们之前总结过：可以查找到一个元素的最左最右元素，因此，我们只需要查找这个元素的最左元素，再去查找这个元素数值+1的最左元素位置-1即可得到这个元素的最右元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;<span class="comment">//空数组直接返回</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">search</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找要仔细判断。</p><h2 id="扩展：是否可以用最左最右元素找呢"><a href="#扩展：是否可以用最左最右元素找呢" class="headerlink" title="扩展：是否可以用最左最右元素找呢?"></a>扩展：是否可以用最左最右元素找呢?</h2><p>明显是可以的，但是遇到个问题：</p><p>1、找最右元素的时候，需要判断数组越界的情况。（因为r=nums.size()  这是有可能访问到nums【r】的）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//空数组直接返回</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">searchl</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">searchr</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchl</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> lside;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">               &#123; r = mid;</span><br><span class="line">               lside=mid;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="type">int</span> lside;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) <span class="comment">// 因为l已经累加了，如果l等于r的情况不能进行判断，那么l=r-1 且 两个数都是target时，mid只会=l，lside也是，我们要的结果是右边的，即r</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;=nums.<span class="built_in">size</span>()) <span class="comment">//杜绝数组越界的情况</span></span><br><span class="line">                <span class="keyword">return</span> lside;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">                lside = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程通信Day6</title>
    <link href="https://blog.luoxiaohei.co/2023/04/03/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day6/"/>
    <id>https://blog.luoxiaohei.co/2023/04/03/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1Day6/</id>
    <published>2023-04-03T12:52:55.000Z</published>
    <updated>2023-04-04T13:28:20.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h1><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程 : 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为 init进程，称为 init 进程领养孤儿进程。<br>【 orphan.c 】杀死孤儿进程  kill -9 pid</p><p>僵尸进程<br>僵尸进程: 进程终止 ，父进程 尚未 回收 子进程 残留 资源（ PCB ）存放于内核中 变成僵尸 Zombie 进程 。</p><p>【zoom.c】</p><p><strong>特别注意</strong>，僵尸进程是不能使用kill 命令清除掉的。因为 kill 命令只是用来终止进程的，<br>而僵尸进程已经终止。只能杀死父进程让僵尸进程变为孤儿进程，再由init进程领养，init发现他是僵尸就会自动回收进程。</p><h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>回收子进程退出资源， <strong>阻塞回收任意一个</strong>。</p><pre><code>pid_t wait(int *status)参数：（传出） 回收进程的状态。返回值：成功： 回收进程的pid    失败： -1， errno</code></pre><p>wait 函数可以回收子进程终止信息 。 该函数有三个功能<br>①阻塞等待子进程退出<br>②回收子进程残留资源<br>③获取子进程结束状态 退出原因 。<br>pid_t wait(int *status); 成功：清理掉的子进程 ID ；失败 1 ( 没有子进程）</p><h2 id="waitpid函数：-指定某一个进程进行回收。可以设置非阻塞。-waitpid-1-amp-status-0-wait-amp-status"><a href="#waitpid函数：-指定某一个进程进行回收。可以设置非阻塞。-waitpid-1-amp-status-0-wait-amp-status" class="headerlink" title="waitpid函数：    指定某一个进程进行回收。可以设置非阻塞。            waitpid(-1, &amp;status, 0) == wait(&amp;status);"></a>waitpid函数：    指定某一个进程进行回收。可以设置非阻塞。            waitpid(-1, &amp;status, 0) == wait(&amp;status);</h2><blockquote><p>pid_t waitpid(pid_t pid, int *status, int options)</p><p>参数：<br>    pid：指定回收某一个子进程pid</p><p>​        &gt; 0: 待回收的子进程pid</p><p>​        -1：任意子进程</p><p>​        0：同组的子进程。</p><p>​    status：（传出） 回收进程的状态。</p><p>​    options：WNOHANG 指定回收方式为，非阻塞。</p><p>返回值：</p><p>​    &gt; 0 : 表成功回收的子进程 pid</p><p>​    0 : 函数调用时， 参3 指定了WNOHANG， 并且，没有子进程结束。</p><p>​    -1: 失败。errno</p></blockquote><p>进程退出，只是内存地址空间释放，精准一点就是用户内存地址释放，<strong>内核pcb残留</strong>，所以才需要回收。</p><p>总结：</p><blockquote><p>wait、waitpid    一次调用，回收一个子进程。</p><p>​        想回收多个。while </p></blockquote><h2 id="进程间通信的常用方式，特征："><a href="#进程间通信的常用方式，特征：" class="headerlink" title="进程间通信的常用方式，特征："></a>进程间通信的常用方式，特征：</h2><blockquote><p>管道：简单</p><p>信号：开销小</p><p>mmap映射：非血缘关系进程间</p><p>socket（本地套接字）：稳定</p></blockquote><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>实现原理： 内核借助环形队列机制，使用内核缓冲区实现（4K）。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E7%AE%A1%E9%81%93%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="管道原理图"></p><blockquote><p>特质；    </p><ol><li><p>伪文件 （实质就是内存的一片空间）</p><ol><li>管道中的数据只能一次读取。</li><li>数据在管道中，只能单向流动。</li></ol></li></ol><p>局限性：</p><ol><li>自己写，不能自己读。</li><li><p>数据不可以反复读。</p></li><li><p>半双工通信。</p></li><li><p>血缘关系进程间可用。</p></li></ol></blockquote><h2 id="pipe函数：-创建，并打开管道。"><a href="#pipe函数：-创建，并打开管道。" class="headerlink" title="pipe函数：    创建，并打开管道。"></a>pipe函数：    创建，并打开管道。</h2><blockquote><p>int pipe(int fd[2]);</p><p>参数：    fd[0]: 读端。</p><p>​    fd[1]: 写端。</p><p>返回值： 成功： 0</p><p>​     失败： -1 errno</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="管道通信"></p></blockquote><p>管道的读写行为：</p><blockquote><p>读管道：</p><pre><code>1. 管道有数据，read返回实际读到的字节数。1. 管道无数据：    ​    1）无写端，read返回0 （类似读到文件尾）​    2）有写端，read阻塞等待。</code></pre><p>写管道：</p><pre><code>1. 无读端， 异常终止。 （SIGPIPE导致的）1. 有读端：    ​    1） 管道已满， 阻塞等待​    2） 管道未满， 返回写出的字节个数。</code></pre><p>优点：简单，相比信号，套接字实现进程间通信，简单很多。<br>缺点： 1. 只能单向通信，双向通信需建立 两个管道。</p><ol><li>只能用于<strong>父子、兄弟进程 有共同祖先</strong> 间通信。该问题后来使用 fifo 有名管道解决。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回收子进程&quot;&gt;&lt;a href=&quot;#回收子进程&quot; class=&quot;headerlink&quot; title=&quot;回收子进程&quot;&gt;&lt;/a&gt;回收子进程&lt;/h1&gt;&lt;h2 id=&quot;孤儿进程&quot;&gt;&lt;a href=&quot;#孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;孤儿进程&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>windows下安装C++编译环境</title>
    <link href="https://blog.luoxiaohei.co/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/windows%E4%B8%8B%E5%AE%89%E8%A3%85C++%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.luoxiaohei.co/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/windows%E4%B8%8B%E5%AE%89%E8%A3%85C++%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2023-04-02T18:30:30.000Z</published>
    <updated>2023-04-03T11:49:02.004Z</updated>
    
    <content type="html"><![CDATA[<p>之前也安装过，但是并没有多明白，现在才知道，学习就是要知道为什么才能知道怎么做。</p><p>1、根据vscode推荐的MSYS2</p><p><em>MSYS2是一个工具和库的集合，为您提供了一个易于使用的环境，用于构建、安装和运行本机Windows软件。</em></p><p>使用这个软件，可以方便管理我们的环境。</p><p>2、使用MSYS2安装Mingw-w64</p><p>安装Mingw-w64工具链（pacman -S —needed base-devel mingw-w64-x86_64-toolchain）。在MSYS2终端中运行pacman命令。<strong>接受默认设置以安装工具链组中的所有成员</strong>。</p><p>3、检查环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line">gdb --version</span><br></pre></td></tr></table></figure><p>4、安装VS代码的<strong>C/C++扩展</strong></p><p>C++是一种已编译的语言，这意味着程序的源代码必须经过翻译（编译）才能在计算机上运行。VSCode首先是一个编辑器，它依赖于命令行工具来完成大部分开发工作流程。C/C++扩展不包括C++编译器或调试器。您需要安装这些工具或使用计算机上已安装的工具。（<strong>意思就是要本地有C++的环境</strong>）</p><ul><li>C++ compiler pre-installed</li><li>C++ debugger pre-installed</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前也安装过，但是并没有多明白，现在才知道，学习就是要知道为什么才能知道怎么做。&lt;/p&gt;
&lt;p&gt;1、根据vscode推荐的MSYS2&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MSYS2是一个工具和库的集合，为您提供了一个易于使用的环境，用于构建、安装和运行本机Windows软件。&lt;/em&gt;&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="https://blog.luoxiaohei.co/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>搜索插入位置</title>
    <link href="https://blog.luoxiaohei.co/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://blog.luoxiaohei.co/2023/04/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2023-04-02T18:30:30.000Z</published>
    <updated>2023-04-04T06:08:19.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>long（n），二分查找。但是要搞清楚返回的位置</p><p>对于左闭右开的区间：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效</span></span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        ??????</span><br><span class="line">        <span class="comment">// 分别处理如下四种情况</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之前  [0, -1]</span></span><br><span class="line">        <span class="comment">// 目标值等于数组中某一个元素  return middle;</span></span><br><span class="line">        <span class="comment">// 目标值插入数组中的位置 [left, right]，return  right + 1</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1</span></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n; <span class="comment">// 定义target在左闭右开的区间里，[left, right)  target</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在 [middle+1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值的情况，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别处理如下四种情况</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之前 [0,0)</span></span><br><span class="line">        <span class="comment">// 目标值等于数组中某一个元素 return middle</span></span><br><span class="line">        <span class="comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里肯定有很多人犯迷糊，为什么左闭右闭就返回right+1。而左闭右开就返回right？？？？</p><p>鄙人认为：</p><p>左闭右闭二分查找下，最后的结果肯定是【right，left】，而要插入的target在right+1,也就是left的位置。</p><p>相反，左闭右开二分查找下，最后的结果肯定是【left，right】，而且<strong>left==right</strong>，而要插入的target在left,也就是right的位置。</p><p><strong>可以这样理解记忆：</strong></p><p>左闭右开相当于多了一个元素进去，最后要查找过程中left和right肯定在它本该在的元素上。</p><p>左闭右闭就是本来的元素排序，最后结果【right，left】，right在小于targrt位置上，left在大于target上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;35-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-搜索插入位置&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="c++" scheme="https://blog.luoxiaohei.co/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程Day5</title>
    <link href="https://blog.luoxiaohei.co/2023/04/02/Linux/Linux%E8%BF%9B%E7%A8%8BDay5/"/>
    <id>https://blog.luoxiaohei.co/2023/04/02/Linux/Linux%E8%BF%9B%E7%A8%8BDay5/</id>
    <published>2023-04-02T12:52:55.000Z</published>
    <updated>2023-04-03T09:03:31.107Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230402100505828.png" alt="内存管理单元MMU"></p><blockquote><p>fork函数：</p><p>pid_t fork(void)</p><p>创建子进程。父子进程各自返回。父进程返回子进程pid。 子进程返回 0.</p><p>getpid();getppid();</p><p>循环创建N个子进程模型。 每个子进程标识自己的身份。<br><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230402102858975.png" alt="循环fork"></p></blockquote><p>父子进程相同：</p><blockquote><p>刚fork后。 data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p></blockquote><p>父子进程不同：</p><blockquote><p>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p></blockquote><p>父子进程共享：</p><blockquote><p><strong>读时共享、写时复制</strong>。———————— 不共享全局变量。</p><p>父子进程共享：1. 文件描述符 2. mmap映射区。</p></blockquote><p>父子进程调式</p><blockquote><p>set follow-fork-mode child 命令设置 gdb 在 fork 之后跟踪子进程。<br>set follow-fork-mode parent 设置跟踪父进程。</p></blockquote><h2 id="execl函数族"><a href="#execl函数族" class="headerlink" title="execl函数族"></a>execl函数族</h2><p>将当前进程的.text 、 .data 替换为所要加载的程序的 .text 、 .data ，然后让进程从新的 .text<br>第一条指令开始执行，但进程 ID 不变，<strong>换核不换壳。</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/exec%E5%87%BD%E6%95%B0.png" alt="exec函数"></p><blockquote><p>int execl(const char <em>path, const char </em>arg, …);<br>int execlp(const char <em>file, const char </em>arg, …);</p><p>execl和execlp的区别就在于execl指定的是执行路径，execlp指定环境变量中的函数名：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230403154604154.png" alt="execl和execlp"></p></blockquote><p>l( 命令行参数列表<br>p( 搜素 file 时使用 path 变量<br>v( 使用命令行参数数组<br>e( 使用环境变量数组 不使用进程原有的环境变量，设置新加载程序运</p><p>小练习：练习：将当前系统中的进程信息，打印到文件中。 exec_ps.c</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8luo/picture/main/image-20230402100505828.png&quot; alt=&quot;内存管理单元MMU&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fork函</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件IO-Day4</title>
    <link href="https://blog.luoxiaohei.co/2023/04/01/Linux/Linux%E6%96%87%E4%BB%B6IO-Day4/"/>
    <id>https://blog.luoxiaohei.co/2023/04/01/Linux/Linux%E6%96%87%E4%BB%B6IO-Day4/</id>
    <published>2023-04-01T12:52:55.000Z</published>
    <updated>2023-04-04T13:25:43.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统调用（内核提供的函数| 内核=操作系统=系统的核心代码）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331193102158.png" alt="系统调用"></p></blockquote><h2 id="open函数："><a href="#open函数：" class="headerlink" title="open函数："></a>open函数：</h2><blockquote><p>int open(char *pathname, int flags)    #include <unistd.h></p><p>参数：<br>    pathname: 欲打开的文件路径名</p><p>​    flags：文件打开方式：    #include <fcntl.h></p><p>​        O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ….</p><p>返回值：<br>    成功： 打开文件所得到对应的 文件描述符（整数）</p><p>​    失败： -1， 设置errno    </p><p>int open(char *pathname, int flags， mode_t mode)        123  775    </p><p>参数：<br>    pathname: 欲打开的文件路径名</p><p>​    flags：文件打开方式：    O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ….</p><p>​    mode: 参数3使用的<strong>前提</strong>， 参2指定了 O_CREAT。    取值8进制数，用来描述文件的 访问权限。 rwx    0664 </p><p>​        创建文件最终权限 = mode &amp; ~umask （<strong>umask是默认文件权限取反</strong>）</p><p>返回值：<br>    成功： 打开文件所得到对应的 文件描述符（整数）</p><p>​    失败： -1， 设置errno    </p></blockquote><h2 id="close函数："><a href="#close函数：" class="headerlink" title="close函数："></a>close函数：</h2><pre><code>int close(int fd);</code></pre><h2 id="错误处理函数：-与-errno-相关。"><a href="#错误处理函数：-与-errno-相关。" class="headerlink" title="错误处理函数：        与 errno 相关。"></a>错误处理函数：        与 errno 相关。</h2><pre><code>printf(&quot;xxx error: %d\n&quot;, errno);char *strerror(int errnum);    printf(&quot;xxx error: %s\n&quot;, strerror(errno));void perror(const char *s);    perror(&quot;open error&quot;);</code></pre><hr><h2 id="read函数："><a href="#read函数：" class="headerlink" title="read函数："></a>read函数：</h2><blockquote><p>ssize_t read(int fd, void *buf, size_t count);</p><p>参数：<br>    fd：文件描述符</p><p>​    buf：存数据的缓冲区</p><p>​    count：缓冲区大小</p><p>返回值：</p><p>​    0：读到文件末尾。</p><p>​    成功；    &gt; 0 读到的字节数。</p><p>​    失败：    -1， 设置 errno</p><p>​    -1： 并且 errno = EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以<strong>非阻塞方式</strong>读一个设备文件（网络文件），并且文件无数据。</p></blockquote><h2 id="write函数："><a href="#write函数：" class="headerlink" title="write函数："></a><strong>write函数：</strong></h2><pre><code>ssize_t write(int fd, const void *buf, size_t count);参数：    fd：文件描述符    buf：待写出数据的缓冲区    count：数据大小返回值：    成功；    写入的字节数。    失败：    -1， 设置 errno</code></pre><h2 id="系统调用和库函数的比较"><a href="#系统调用和库函数的比较" class="headerlink" title="系统调用和库函数的比较"></a>系统调用和库函数的比较</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401111355517.png" alt="系统调用和库函数"></p><p><strong>误区</strong>：系统调用比库函数效率高。</p><p><strong>前提条件</strong>：假如分别用库函数fputc一次写一个字节，和用系统调用一次写一个字节。<strong>结果</strong>：使用库函数会快一些，因为库函数有自己的缓冲区，当缓冲区满再切换到内核区。而系统调用，每次都切换内核区。</p><p><strong>使用环境</strong>：系统调用立刻写入<strong>内核区</strong>，库函数等缓冲区满再写入<strong>内核区</strong>。</p><hr><h2 id="文件描述符："><a href="#文件描述符：" class="headerlink" title="文件描述符："></a>文件描述符：</h2><blockquote><p>PCB进程控制块：本质 <strong>结构体</strong>。</p><p>成员：文件描述符表。</p><p>文件描述符：0/1/2/3/4。。。。/1023     表中可用的最小的。</p><p>0 - STDIN_FILENO</p><p>1 - STDOUT_FILENO</p><p>2 - STDERR_FILENO</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401112552458.png" alt="PCB进程控制块"></p></blockquote><h2 id="阻塞、非阻塞：-是设备文件、网络文件的属性。"><a href="#阻塞、非阻塞：-是设备文件、网络文件的属性。" class="headerlink" title="阻塞、非阻塞：  是设备文件、网络文件的属性。"></a>阻塞、非阻塞：  是<strong>设备文件</strong>、<strong>网络文件</strong>的属性。</h2><blockquote><p>产生阻塞的场景： 读<strong>设备文件</strong>。读网络文件。（读常规文件无阻塞概念：<strong>总有读完的时候</strong>）</p><p>/dev/tty — <strong>终端文件</strong>。</p><p>open(“/dev/tty”, O_RDWR|O_NONBLOCK)    —- 设置 /dev/tty 非阻塞状态。(默认为阻塞状态)</p><p>eg（在file_IO_test下）：</p><p>case1:block_readtty.c | 阻塞读终端</p><p>case2:nonblock_readtty.c | 非阻塞读终端</p><p>case3:nonblock_timeout.c | 非阻塞读终端和等待超时 </p></blockquote><h2 id="fcntl："><a href="#fcntl：" class="headerlink" title="fcntl："></a><strong>fcntl：</strong></h2><p>描述：获取文件状态和设置文件状态</p><p>​    int (int fd, int cmd, …)</p><blockquote><p>int flgs = fcntl(fd,  F_GETFL);</p><p>返回的int类型flgs的位图：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/fcntl%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt="fcntl设置文件属性"></p><p>flgs |= O_NONBLOCK</p><p>fcntl(fd,  F_SETFL, flgs);</p><p>获取文件状态： F_GETFL</p><p>设置文件状态： F_SETFL</p></blockquote><h2 id="lseek函数："><a href="#lseek函数：" class="headerlink" title="lseek函数："></a>lseek函数：</h2><p>描述：设置读写文件偏移量</p><blockquote><p>off_t lseek(int fd, off_t offset, int whence);</p><p>参数：<br>    fd：文件描述符</p><p>​    offset： 偏移量</p><p>​    whence：起始偏移位置： SEEK_SET/SEEK_CUR/SEEK_END</p><p>返回值：</p><p>​    成功：较起始位置偏移量 = <strong>offset+whence</strong></p><p>​    失败：-1 errno</p><p><strong>应用场景：</strong>    </p><blockquote><ol><li><p><strong>文件的“读”、“写”使用同一偏移位置。</strong></p></li><li><p>使用lseek获取文件大小</p></li><li><p>1）使用lseek拓展文件大小：要想使文件大小真正拓展，<strong>必须引起IO操作</strong>：int ret = write(fd, “a”, 1);</p></li></ol><p>2）使用 truncate 函数，直接拓展文件。    int ret = truncate(“dict.cp”, 250);</p></blockquote></blockquote><h3 id="传入参数："><a href="#传入参数：" class="headerlink" title="传入参数："></a>传入参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>同常有const关键字修饰。</p></li><li><p>指针指向有效区域， 在函数内部做读操作。</p></li></ol></blockquote><h3 id="传出参数："><a href="#传出参数：" class="headerlink" title="传出参数："></a>传出参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>在函数调用之前，指针指向的空间可以无意义，但必须有效。</p></li><li><p>在函数内部，做写操作。</p></li><li><p>函数调用结束后，充当函数返回值。</p></li></ol></blockquote><h3 id="传入传出参数："><a href="#传入传出参数：" class="headerlink" title="传入传出参数："></a>传入传出参数：</h3><blockquote><ol><li><p>指针作为函数参数。</p></li><li><p>在函数调用之前，指针指向的空间有实际意义。</p></li><li><p>在函数内部，先做读操作，后做写操作。</p></li><li><p>函数调用结束后，<strong>充当</strong>函数返回值。比如int aaa(int <em>p, struct stat </em>p2, strcut student *p3);函数参数都可以充当函数返回值。</p></li></ol></blockquote><h2 id="目录项和Inode"><a href="#目录项和Inode" class="headerlink" title="目录项和Inode"></a>目录项和Inode</h2><p>一个文件对应一个FCB，FCB就是目录项。多个FCB组成一个目录。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230401135720597.png" alt="目录项和Inode"></p><h2 id="stat-lstat-函数："><a href="#stat-lstat-函数：" class="headerlink" title="stat/lstat 函数："></a>stat/lstat 函数：</h2><p>描述：查看文件信息</p><blockquote><p>int stat(const char <em>path, struct stat </em>buf);</p><p>参数：<br>    path： 文件路径</p><p>​    buf：（传出参数） 存放文件属性。</p><p>返回值：</p><p>​    成功： 0</p><p>​    失败： -1 errno</p><p>获取文件大小： buf.st_size</p><p>获取文件类型： buf.st_mode</p><p>获取文件权限： buf.st_mode</p><p>符号穿透：stat会。lstat不会。</p><p>符号穿透：指我创建的软链接指向哪个文件，在stat查看文件类型时，会显示那个文件的信息而不是软连接文件的信息。 </p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>使用stat获取文件类型或者权限时，参考下面位图</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%BD%8D%E5%9B%BE.png" alt="文件权限位图"></p></blockquote><h2 id="link-unlink"><a href="#link-unlink" class="headerlink" title="link/unlink:"></a>link/unlink:</h2><blockquote><p>描述：link就是创建一个FCB，unlink就是删除一个FCB（文件目录项）</p><p>unlink需要注意的是：尽管unlink了文件，但要等到<strong>所有</strong>打开该文件的进程关闭了该文件，系统才会挑时间将文件释放。俗话就是还没删掉inode，等打开文件进程关闭才等时机删。</p></blockquote><p>隐式回收。</p><blockquote><p>当进程结束运行时，系统会自动关闭内存空间。</p><p>一个进程的文件描述符表最多也就能打开1024个文件，如果是服务器一直不关掉进程，系统就不会隐式回收。<strong>这就是我们说要及时free的原因。</strong></p></blockquote><h2 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h2><p>描述：查看符号链接文件本身的内容。</p><h2 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h2><p>描述：重命名文件。</p><hr><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h2><p>根据传入的目录名打开一个目录（库函数）</p><h2 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h2><p>关闭打开的目录（库函数）</p><h2 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h2><p>读取目录（库函数）</p><hr><p>dup 和 dup2：</p><blockquote><p>int dup(int oldfd);        文件描述符复制。</p><p>​    oldfd: 已有文件描述符</p><p>​    返回：新文件描述符。</p><p>int dup2(int oldfd, int newfd); 文件描述符复制。重定向。</p><p>将oldfd文件描述符拷贝给newfd，所以它们指向同一个文件。</p></blockquote><p>fcntl 函数实现 dup：</p><blockquote><p>int fcntl(int fd, int cmd, ….)</p><p>cmd: F_DUPFD</p><p>参3:      被占用的，返回最小可用的文件描述符。</p><p>​    未被占用的， 返回=该值的文件描述符。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统调用（内核提供的函数| 内核=操作系统=系统的核心代码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331193102</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java学习路线</title>
    <link href="https://blog.luoxiaohei.co/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://blog.luoxiaohei.co/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2023-03-31T12:52:55.000Z</published>
    <updated>2023-03-31T06:57:05.787Z</updated>
    
    <content type="html"><![CDATA[<p>个人推荐一个java框架路线。</p><p> 1、首先了解一下javaweb（servlet）</p><p> 2、入门ssm </p><p>3、了解springboot </p><p>4、了解常见组件springcloud或者dubbo&amp;;zk </p><p>5、中间件等 redis和消息队列  </p><p>6、上手项目，在项目中巩固技术栈 </p><p>更多java面试干货和实战项目推荐，可以关注我的公众号：代码界的小白，希望对你有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人推荐一个java框架路线。&lt;/p&gt;
&lt;p&gt; 1、首先了解一下javaweb（servlet）&lt;/p&gt;
&lt;p&gt; 2、入门ssm &lt;/p&gt;
&lt;p&gt;3、了解springboot &lt;/p&gt;
&lt;p&gt;4、了解常见组件springcloud或者dubbo&amp;amp;;zk &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.luoxiaohei.co/categories/Java/"/>
    
    
    <category term="Java" scheme="https://blog.luoxiaohei.co/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day3</title>
    <link href="https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/"/>
    <id>https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/</id>
    <published>2023-03-31T12:52:55.000Z</published>
    <updated>2023-04-01T02:54:48.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>gdb调试工具：   大前提：程序是你自己写的。  —-逻辑错误</p><p>基础指令：<br>    -g：使用该参数编译可以执行文件，得到调试表。</p><pre><code>gdb ./a.outlist： list 1  列出源码。根据源码指定 行号设置断点。b：    b 20    在20行位置设置断点。run/r:    运行程序n/next: 下一条指令（会越过函数）s/step: 下一条指令（会进入函数） |  进入系统函数会找不到文件，使用until+行号回到调试点 | 或者finish结束函数调用p/print：p i  查看变量的值。continue：继续执行断点后续指令。finish：结束当前函数调用。 quit：退出gdb当前调试。</code></pre><p>其他指令：</p><pre><code>run：使用run查找段错误出现位置。set args： 设置main函数命令行参数 （在 start、run 之前）run 字串1 字串2 ...: 设置main函数命令行参数info b: 查看断点信息表b 20 if i = 5：    设置条件断点。ptype：查看变量类型。display：设置跟踪变量undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</code></pre><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt：列出当前程序正存活着的栈帧。</span><br><span class="line"></span><br><span class="line">frame： 根据栈帧编号，切换栈帧。</span><br></pre></td></tr></table></figure><p>切换栈帧即可访问函数调用栈帧中的数据</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331112614337.png" alt="栈帧"></p></blockquote><hr><blockquote><p>makefile： 管理项目。</p><blockquote><p>命名：makefile     Makefile  —- make 命令</p><p>1 个规则：</p><p>​    目标：依赖条件<br>​    （一个tab缩进）命令</p><pre><code> 1. **目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标** 2. **依赖条件如果不存在，找寻新的规则去产生依赖条件。**</code></pre><p>（make会把makefile的第一行规则作为终极目标）</p><p>ALL：指定 makefile 的终极目标。</p><p><strong>小细节</strong>：为什么要把makefile写的复杂？</p><p>例如：我修改了一个add的源码，而导致我所有的源文件都要跟着编译一遍，这是非常耗时的。如果写成如下的样式，make会根据<strong>目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标</strong>原则，只执行<code>gcc -v add.c -o hello.o 和 gcc hello.o add.o sub.o div1.o -o a.out.</code></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331164549575.png" alt="image-20230331164549575"></p><p>2 个函数：</p><p>​    src = $(wildcard ./*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。  src = add.c sub.c div1.c </p><p>​    obj = $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj = add.o sub.o div1.o</p><p>clean:    (没有依赖)</p><pre><code>make clean -n | -n表示提示不执行-rm -rf $(obj) a.out    “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</code></pre><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331172250751.png" alt="使用2个函数"></p><p>3 个自动变量：</p><p>​    $@: 在规则的<strong>命令中</strong>，表示<strong>规则中的目标</strong>。</p><p>​    $^: 在规则的<strong>命令中</strong>，表示<strong>所有依赖条件</strong>。</p><p>​    $&lt;: 在规则的<strong>命令中，</strong>表示<strong>第一个依赖条件</strong>。如果将该变量应用在<strong>模式规则</strong>中，它可将依赖条件列表中的依赖<strong>依次</strong>取出，套用模式规则。</p><p>模式规则：</p><p>​    %.o:%.c<br>​       gcc -c $&lt; -o %@</p></blockquote><p>使用这么多函数和自动变量的原因是<strong>方便扩展</strong></p><p><strong>不需要修改makefile</strong>即可扩展程序功能函数。</p><blockquote><p>静态模式规则：（指定模式规则下使用的obj）（obj可以有多个，可有obj函数的特性看出）</p><p>​    $(obj):%.o:%.c<br>​       gcc -c $&lt; -o %@    </p><p>伪目标：（不管重名与否都执行）</p><p>​    .PHONY: clean ALL</p><p>参数：<br>    -n：模拟执行make、make clean 命令。</p><p>​    -f：指定文件执行 make 命令。                make -f filename  clean          (xxx.mk通常是makefile文件)</p></blockquote></blockquote><pre><code>作业：编写一个 makefile 可以将其所在目录下的所有独立 .c 文件编译生成同名可执行文件。</code></pre><p>tips：makefile中的%和*的区别：</p><p>%在*的基础上，多了一个匹配的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day3&quot;&gt;&lt;a href=&quot;#Day3&quot; class=&quot;headerlink&quot; title=&quot;Day3&quot;&gt;&lt;/a&gt;Day3&lt;/h1&gt;&lt;p&gt;gdb调试工具：   大前提：程序是你自己写的。  —-逻辑错误&lt;/p&gt;
&lt;p&gt;基础指令：&lt;br&gt;    -g：使用该参数编</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Xmind激活亲测有效（23/3/30）</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-30T13:43:08.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xmind激活亲测有效（23-3-30）"><a href="#Xmind激活亲测有效（23-3-30）" class="headerlink" title="Xmind激活亲测有效（23/3/30）"></a>Xmind激活亲测有效（23/3/30）</h1><p>下载资源</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330095543117.png" alt="image-20230330095543117"></p><p>双击安装包，程序自动安装在C:\Program Files\XMind下</p><p>替换</p><p>C:\Program Files\XMind\resources下的app.asar,打开xmind即可激活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xmind激活亲测有效（23-3-30）&quot;&gt;&lt;a href=&quot;#Xmind激活亲测有效（23-3-30）&quot; class=&quot;headerlink&quot; title=&quot;Xmind激活亲测有效（23/3/30）&quot;&gt;&lt;/a&gt;Xmind激活亲测有效（23/3/30）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="XMmid" scheme="https://blog.luoxiaohei.co/categories/XMmid/"/>
    
    
    <category term="XMind" scheme="https://blog.luoxiaohei.co/tags/XMind/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day2</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-31T10:13:28.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>vim的三种工作模式</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330114045599.png" alt=""></p><p>vim的快捷键</p><blockquote><p>跳转到指定行：</p><pre><code> 1. 88G （命令模式） 2. :88  (末行模式)</code></pre><p>跳转文件首：</p><p>​    gg （命令模式）</p><p>跳转文件尾：</p><p>​    G（命令模式）</p><p>自动格式化程序：</p><p>​    gg=G（命令模式）</p><p>大括号对应：</p><p>​    % （命令模式）</p><p>光标移至行首：</p><p>​    0 （命令模式）执行结束，工作模式不变。</p><p>光标移至行尾：</p><p>​    $ （命令模式）执行结束，工作模式不变。</p><p>删除单个字符：</p><p>​    x （命令模式）执行结束，工作模式不变。</p><p>替换单个字符：</p><p>​    将待替换的字符用光标选中， r （命令模式），再按欲替换的字符</p><p>删除一个单词：</p><p>​    dw（命令模式）光标置于单词的首字母进行操作。</p><p>删除光标至行尾：</p><p>​    D 或者 d$（命令模式）</p><p>删除光标至行首：</p><p>​    d0 （命令模式）</p><p>删除指定区域：</p><p>​    按 V （命令模式）切换为 “可视模式”，使用 hjkl挪移光标来选中待删除区域。  按 d 删除该区域数据。</p><p>剪切指定1行：</p><p>​    在光标所在行，按 dd （命令模式）</p><p>剪切指定N行：</p><p>​    在光标所待删除首行，按 Ndd （命令模式）</p><p>复制一行：</p><p>​    yy</p><p>粘贴：<br>    p：向后、P：向前。</p><p>查找：</p><pre><code> 1. 找 设想 内容：命令模式下， 按 “/” 输入欲搜索关键字，回车。使用 n 检索下一个。 2. 找 看到的内容：命令模式下，将光标置于单词任意一个字符上，按 “*”/ “#” </code></pre><p>单行替换：</p><p>​    将光标置于待替换行上， 进入末行模式，输入 :s /原数据/新数据</p><p>通篇替换：</p><p>​    末行模式， :%s /原数据/新数据/g   g:不加，只替换每行首个。   </p><p>指定行的替换：</p><p>​    末行模式， :起始行号，终止行号s /原数据/新数据/g   g:不加，只替换每行首个。</p><p>​        :29,35s /printf/println/g</p><p>撤销、反撤销：</p><p>​    u、ctrl+r（命令模式）</p><p>分屏：（末行模式）<br>    sp：横屏分。 Ctrl+ww 切换。</p><p>​    vsp：竖屏分。Ctrl+ww 切换。</p><p>跳转至 man 手册：</p><p>​    将光标置于待查看函数单词上，使用 K（命令模式）跳转。 指定卷， nK</p><p>查看宏定义：</p><p>​    将光标置于待查看宏定义单词上，使用 [d 查看定义语句。（命令模式）</p><p>在末行模式执行shell命令：</p><p>​    :!命令        :! ls -l<br>​    :! gcc hello.c -o hello100  | !./hello100</p><p>​    <strong>gcc hello.c -o hello = gcc -c hello.c -o hello.o + gcc hello.o -o a.out</strong></p><p>​    :! g++ hello.cpp | !./a.out</p></blockquote><hr><p>gcc编译：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/gcc%E7%BC%96%E8%AF%914%E6%AD%A5%E9%AA%A4.png" alt="gcc编译4步骤"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4步骤： 预处理、编译、汇编、连接。</span><br><span class="line"></span><br><span class="line">-I：指定头文件所在目录位置。</span><br><span class="line"></span><br><span class="line">-c：只做预处理、编译、汇编。得到 二进制 文件！！！</span><br><span class="line"></span><br><span class="line">-g：编译时添加调试语句。 主要支持 gdb 调试。</span><br><span class="line"></span><br><span class="line">-Wall： 显示所有警告信息。</span><br><span class="line"></span><br><span class="line">-D：向程序中“动态”注册宏定义。   ifdef ... #define NAME VALUE</span><br><span class="line"></span><br><span class="line">-l: 指定动态库名</span><br><span class="line"></span><br><span class="line">-L: 指定动态库路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.png" alt="动态库和静态库"></p><blockquote><blockquote><p>静态库制作及使用步骤：</p><p><strong>（-o 取名）</strong></p><pre><code>1. 将 .c 生成 .o 文件​    gcc -c add.c -o add.o2. 使用 ar 工具制作静态库    ar rcs  lib库名.a  add.o sub.o div.o3. 编译静态库到可执行文件中：    gcc test.c lib库名.a -o a.out</code></pre><p>头文件守卫：<strong>防止头文件被重复包含</strong> </p><p> implicit declaration<strong>隐式声明</strong>，这是c语言自己会声明的东西，只会做int add（int ,int）之类的声明，如果库里面有类似viod就会报错。<br>解决办法：自己在源代码中声明函数，为了复用性，我们通常用下面的头文件守卫：</p><pre><code>#ifndef _HEAD_H_#define _HEAD_H_......#endif</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后在.c中引入.h</span><br><span class="line">项目发布：</span><br><span class="line">gcc test.c ./lib/libmylib.a -o a.out -I ./inc</span><br></pre></td></tr></table></figure><p>动态库制作及使用：</p></blockquote><ol><li>将 .c 生成 .o 文件， （<strong>生成与位置无关的代码 -fPIC</strong>）</li></ol><p>​    gcc -c add.c -o add.o -fPIC         （<strong>在动态库函数后生成PIC，程序运行时再链接</strong>）</p><ol><li><p>使用 gcc -shared 制作动态库</p><p> gcc -shared -o lib库名.so    add.o sub.o div.o</p></li><li><p>编译可执行程序时，指定所使用的动态库。  -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。</p><p> gcc test.c -o a.out -lmymath -L./lib -I./inc</p></li><li><p>运行可以执行程序 ./a.out <strong>出错</strong>！！！！ —- ldd a.out —&gt; “not found” （<strong>ldd 查看程序链接信息</strong>）</p><p> error while loading shared libraries: libxxx.so: cannot open shared object file: No such file or directory</p><p> 原因：</p><pre><code> 链接器：    工作于链接阶段， 工作时需要 -l 和 -L （**执行数据段合并和地址回填**）| </code></pre><p> ​    动态链接器：    工作于程序运行阶段，工作时需要提供动态库所在固定目录位置。</p><p> 解决方式：</p><p> ​    【1】 通过环境变量：  export LD_LIBRARY_PATH=动态库路径</p><p> ​        ./a.out 成功！！！  （临时生效， 终端重启环境变量失效）改变的是进程的环境变量</p><p> ​    【2】 永久生效： 写入 终端配置文件。  .bashrc  建议使用绝对路径。eg:/home/luo/file/dynamicLab/lib</p><p> ​                1.vi ~/.bashrc</p><p> ​                2.写入 export LD_LIBRARY_PATH=动态库路径  保存</p><p> 3）. .bashrc/  source .bashrc / 重启 终端  —-&gt; 让修改后的.bashrc生效</p><p> 4）./a.out 成功！！！ </p><p> 【3】 拷贝自定义动态库 到 /lib (标准C库所在目录位置)</p><p> 【4】 配置文件法</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）sudo vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">2）写入 动态库绝对路径  保存</span><br><span class="line"></span><br><span class="line">3）sudo ldconfig -v  使配置文件生效。</span><br><span class="line"></span><br><span class="line">4）./a.out 成功！！！--- 使用 ldd  a.out 查看程序链接情况</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>数据段合并</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331103821681.png" alt="数据段合并"></p><p>其他：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi显示readonly</span><br><span class="line">退出两个办法</span><br><span class="line">1：wq！</span><br><span class="line">2：w !sudo tee %</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-2&quot;&gt;&lt;a href=&quot;#Day-2&quot; class=&quot;headerlink&quot; title=&quot;Day 2&quot;&gt;&lt;/a&gt;Day 2&lt;/h1&gt;&lt;p&gt;vim的三种工作模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu22.04 中Drag and drop is not supported问题</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-30T12:07:03.891Z</published>
    <updated>2023-03-30T12:41:31.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu22-04-中Drag-and-drop-is-not-supported问题"><a href="#Ubuntu22-04-中Drag-and-drop-is-not-supported问题" class="headerlink" title="Ubuntu22.04 中Drag and drop is not supported问题"></a>Ubuntu22.04 中Drag and drop is not supported问题</h1><p>解决方法<br>先在terminal中安装这两个程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-prefs</span><br><span class="line">sudo apt install nemo</span><br></pre></td></tr></table></figure><p>左下角的application中选择extension， 将Desktop icons NG 选项关闭</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330202439439.png" alt="image-20230330202439439"></p><p>左下角的application中选择startup application preference， 添加如下命令</p><p><img src="https://img-blog.csdnimg.cn/1df319278b124816a90579738f0c6995.png" alt="img"></p><p>将程序重启后即可在host和vm间进行拖动传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot;&gt;&lt;a href=&quot;#Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot; class=&quot;headerlink&quot; title=&quot;Ub</summary>
      
    
    
    
    
    <category term="Ubuntu22.04" scheme="https://blog.luoxiaohei.co/tags/Ubuntu22-04/"/>
    
  </entry>
  
  <entry>
    <title>hexo：更换电脑，如何继续写博客</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-03-30T08:40:50.000Z</published>
    <updated>2023-03-30T11:08:11.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo：更换电脑，如何继续写博客"><a href="#hexo：更换电脑，如何继续写博客" class="headerlink" title="hexo：更换电脑，如何继续写博客"></a>hexo：更换电脑，如何继续写博客</h1><details green><summary> 哔哔 </summary>              <div class='content'>              <p>先提一句：</p><p>如果想要在百度收录，需要在百度站长验证一下，最后卡在验证环境如下：明显是访问不到外网。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330190044308.png" alt="image-20230330190044308"></p>              </div>            </details><p>1.将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>将这些目录放到一个目录下，如：hexo／</p><p>2.在你的新电脑上首先配置hexo环境：安装Node.js<br>3.安装hexo，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>4.安装好之后，进入hexo／目录<br>5.模块安装，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>6.部署，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;a href=&quot;#hexo：更换电脑，如何继续写博客&quot; class=&quot;headerlink&quot; title=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;/a&gt;hexo：更换电脑，如何继续写博客&lt;/h1&gt;&lt;details gree</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://blog.luoxiaohei.co/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day1</title>
    <link href="https://blog.luoxiaohei.co/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/"/>
    <id>https://blog.luoxiaohei.co/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/</id>
    <published>2023-03-29T12:52:55.000Z</published>
    <updated>2023-03-31T11:59:44.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>学习了一些命令，这些命令记住常用的，备份难记的。</p><p>常用的比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径中，cd ..、cd .、 cd、 cd - 的使用。</span><br><span class="line">./ 本级目录 ../上一级目录</span><br><span class="line"></span><br><span class="line">删除文件rm</span><br><span class="line">rm -rf 递归强制删除</span><br><span class="line">mv 文件重命名|移动文件</span><br><span class="line">mv和cp的区别</span><br><span class="line">1、功能上的区别</span><br><span class="line">mv：用户可以使用该命令为文件或目录重命名或将文件由一个目录移入另一个目录中（该文件从原来的文件夹中消失）。</span><br><span class="line"></span><br><span class="line">cp: 该命令的功能是将给出的文件或目录拷贝到另一文件或目录中（该文件仍保存在原文件夹中）。</span><br><span class="line"></span><br><span class="line">2、从inode角度来区分</span><br><span class="line">mv：会将存储于indoe索引节点上的文件元信息也移动到新文件中。</span><br><span class="line"></span><br><span class="line">cp : 只会复制文件数据，不会复制inode索引节点上的文件元信息。</span><br><span class="line"></span><br><span class="line">创建用户sudo adduser 新用户名--- useradd</span><br><span class="line">删除用户sudo deluser 用户名</span><br><span class="line">find找文件</span><br><span class="line">ln创建软链接和硬链接的方式和属性</span><br><span class="line">chmod修改权限的两种方式</span><br><span class="line">grep查找文件内容</span><br><span class="line">压缩文件tar、rar、zip等命令---gzip and bzip with tar:因为gzip和bzip不能打包文件夹多个文件。</span><br><span class="line">tar zcvf filename file1 file2</span><br><span class="line">z:gzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">tar jcvf filename file1 file2</span><br><span class="line">z:bzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">解压</span><br><span class="line">tar zxvf filename</span><br><span class="line">tar jxvf filename</span><br><span class="line"></span><br><span class="line">rar a -r filename file</span><br><span class="line">unrar x filename</span><br><span class="line"></span><br><span class="line">zip -r filename file</span><br><span class="line">unzip filename</span><br><span class="line"></span><br><span class="line">安装软件卸载软件的方法。</span><br><span class="line">sudo aptitude show softname 查看软件安装信息</span><br></pre></td></tr></table></figure><p>文件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件。</span><br></pre></td></tr></table></figure><p>系统目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin：存放二进制可执行文件</span><br><span class="line">boot：存放开机启动程序</span><br><span class="line">dev：存放设备文件： 字符设备、块设备</span><br><span class="line">home：存放普通用户</span><br><span class="line">etc：用户信息和系统配置文件 passwd、group</span><br><span class="line">lib：库文件：libc.so.6</span><br><span class="line">root：管理员宿主目录（家目录）</span><br><span class="line">usr：用户资源管理目录 unix software resource</span><br></pre></td></tr></table></figure><p>简单的快捷键</p><p>tab显示提示、ctrl-a、ctrl-e、ctrl-u、ctrl-Alt-t。</p><p>细节的内容还请再看一遍视频讲解和讲义。</p><hr><p>学习完后写的五子棋游戏服务器，匹配游戏，断线重连，连接mysql数据库，欢迎大家一起学习 <a href="https://github.com/ChenVv-hong/Gobang">https://github.com/ChenVv-hong/Gobang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h1&gt;&lt;p&gt;学习了一些命令，这些命令记住常用的，备份难记的。&lt;/p&gt;
&lt;p&gt;常用的比如&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git操作手册（给实验室同学）</title>
    <link href="https://blog.luoxiaohei.co/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/"/>
    <id>https://blog.luoxiaohei.co/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/</id>
    <published>2023-02-03T13:42:06.000Z</published>
    <updated>2023-03-30T11:12:11.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><p>1、安装GIT</p><p><a href="https://blog.csdn.net/adminsir0/article/details/126355313">(3条消息) git安装教程</a>（一直next就行）</p><p>2、注册远程仓库账号</p><p>打开<a href="https://github.com/">GitHub</a>，注册自己账号</p><p>不翻墙的话，注册<a href="https://gitee.com/">Gitee</a>（这个文档展示gitee）</p><p>3、本地创建任意文件夹，鼠标右键选择git bush</p><p>4、配置用户，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>5、生成SSH密钥        </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>进入C:\Users\Administrator.ssh目录下，查看生成的SSH密钥，</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181525633.jpeg" alt="img" style="zoom:50%;" /></p><p>复制id_ras.pub里面的字符串，在gitee设置中的SSH公钥中添加密钥。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181527256.png" alt="image-20221218152744139"></p><p>6、创建一个文件，在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>7、命令行输入：git init </p><p>8、命令行输入：git add .</p><p>9、命令行输入：git commit -m “123”</p><p>10、命令行输入：git remote add origin <strong>url</strong>  |  url选择你的远程仓库，比如<strong>gitee</strong>创建完仓库后，会有这个地址，我们选择SSH链接就行。</p><p>例如：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181520074.png" alt="image-20221218152045988"></p><p>11、命令行输入：git push -u origin “master”</p><p>显示成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作手册&quot;&gt;&lt;a href=&quot;#操作手册&quot; class=&quot;headerlink&quot; title=&quot;操作手册&quot;&gt;&lt;/a&gt;操作手册&lt;/h2&gt;&lt;p&gt;1、安装GIT&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/adminsir0/articl</summary>
      
    
    
    
    
    <category term="git" scheme="https://blog.luoxiaohei.co/tags/git/"/>
    
  </entry>
  
</feed>
