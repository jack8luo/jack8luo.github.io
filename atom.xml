<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骆小黑</title>
  
  <subtitle>阿妮亚</subtitle>
  <link href="https://blog.luoxiaohei.co/atom.xml" rel="self"/>
  
  <link href="https://blog.luoxiaohei.co/"/>
  <updated>2023-03-31T06:57:05.787Z</updated>
  <id>https://blog.luoxiaohei.co/</id>
  
  <author>
    <name>骆小黑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习路线</title>
    <link href="https://blog.luoxiaohei.co/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://blog.luoxiaohei.co/2023/03/31/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2023-03-31T12:52:55.000Z</published>
    <updated>2023-03-31T06:57:05.787Z</updated>
    
    <content type="html"><![CDATA[<p>个人推荐一个java框架路线。</p><p> 1、首先了解一下javaweb（servlet）</p><p> 2、入门ssm </p><p>3、了解springboot </p><p>4、了解常见组件springcloud或者dubbo&amp;;zk </p><p>5、中间件等 redis和消息队列  </p><p>6、上手项目，在项目中巩固技术栈 </p><p>更多java面试干货和实战项目推荐，可以关注我的公众号：代码界的小白，希望对你有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人推荐一个java框架路线。&lt;/p&gt;
&lt;p&gt; 1、首先了解一下javaweb（servlet）&lt;/p&gt;
&lt;p&gt; 2、入门ssm &lt;/p&gt;
&lt;p&gt;3、了解springboot &lt;/p&gt;
&lt;p&gt;4、了解常见组件springcloud或者dubbo&amp;amp;;zk &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.luoxiaohei.co/categories/Java/"/>
    
    
    <category term="Java" scheme="https://blog.luoxiaohei.co/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件IO-Day3</title>
    <link href="https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E6%96%87%E4%BB%B6IO-Day3/"/>
    <id>https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E6%96%87%E4%BB%B6IO-Day3/</id>
    <published>2023-03-31T12:52:55.000Z</published>
    <updated>2023-03-31T12:12:05.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统调用（内核提供的函数| 内核=操作系统=系统的核心代码）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331193102158.png" alt="image-20230331193102158"></p></blockquote><p>open函数：</p><pre><code>int open(char *pathname, int flags)    #include &lt;unistd.h&gt;参数：    pathname: 欲打开的文件路径名    flags：文件打开方式：    #include &lt;fcntl.h&gt;        O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....返回值：    成功： 打开文件所得到对应的 文件描述符（整数）    失败： -1， 设置errno    int open(char *pathname, int flags， mode_t mode)        123  775    参数：    pathname: 欲打开的文件路径名    flags：文件打开方式：    O_RDONLY|O_WRONLY|O_RDWR    O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....    mode: 参数3使用的前提， 参2指定了 O_CREAT。    取值8进制数，用来描述文件的 访问权限。 rwx    0664        创建文件最终权限 = mode &amp; ~umask （umask是默认文件权限取反）返回值：    成功： 打开文件所得到对应的 文件描述符（整数）    失败： -1， 设置errno    </code></pre><p>close函数：</p><pre><code>int close(int fd);</code></pre><p>错误处理函数：        与 errno 相关。</p><pre><code>printf(&quot;xxx error: %d\n&quot;, errno);char *strerror(int errnum);    printf(&quot;xxx error: %s\n&quot;, strerror(errno));void perror(const char *s);    perror(&quot;open error&quot;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统调用（内核提供的函数| 内核=操作系统=系统的核心代码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331193102</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day3</title>
    <link href="https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/"/>
    <id>https://blog.luoxiaohei.co/2023/03/31/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay3/</id>
    <published>2023-03-31T12:52:55.000Z</published>
    <updated>2023-03-31T12:00:57.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>gdb调试工具：   大前提：程序是你自己写的。  —-逻辑错误</p><p>基础指令：<br>    -g：使用该参数编译可以执行文件，得到调试表。</p><pre><code>gdb ./a.outlist： list 1  列出源码。根据源码指定 行号设置断点。b：    b 20    在20行位置设置断点。run/r:    运行程序n/next: 下一条指令（会越过函数）s/step: 下一条指令（会进入函数） |  进入系统函数会找不到文件，使用until+行号回到调试点 | 或者finish结束函数调用p/print：p i  查看变量的值。continue：继续执行断点后续指令。finish：结束当前函数调用。 quit：退出gdb当前调试。</code></pre><p>其他指令：</p><pre><code>run：使用run查找段错误出现位置。set args： 设置main函数命令行参数 （在 start、run 之前）run 字串1 字串2 ...: 设置main函数命令行参数info b: 查看断点信息表b 20 if i = 5：    设置条件断点。ptype：查看变量类型。display：设置跟踪变量undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</code></pre><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt：列出当前程序正存活着的栈帧。</span><br><span class="line"></span><br><span class="line">frame： 根据栈帧编号，切换栈帧。</span><br></pre></td></tr></table></figure><p>切换栈帧即可访问函数调用栈帧中的数据</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331112614337.png" alt="栈帧"></p></blockquote><hr><blockquote><p>makefile： 管理项目。</p><blockquote><p>命名：makefile     Makefile  —- make 命令</p><p>1 个规则：</p><p>​    目标：依赖条件<br>​    （一个tab缩进）命令</p><pre><code> 1. **目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标** 2. **依赖条件如果不存在，找寻新的规则去产生依赖条件。**</code></pre><p>（make会把makefile的第一行规则作为终极目标）</p><p>ALL：指定 makefile 的终极目标。</p><p><strong>小细节</strong>：为什么要把makefile写的复杂？</p><p>例如：我修改了一个add的源码，而导致我所有的源文件都要跟着编译一遍，这是非常耗时的。如果写成如下的样式，make会根据<strong>目标的时间必须晚于依赖条件的时间，否则，更新目标并继续更新总目标</strong>原则，只执行<code>gcc -v add.c -o hello.o 和 gcc hello.o add.o sub.o div1.o -o a.out.</code></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331164549575.png" alt="image-20230331164549575"></p><p>2 个函数：</p><p>​    src = $(wildcard ./*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。  src = add.c sub.c div1.c </p><p>​    obj = $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj = add.o sub.o div1.o</p><p>clean:    (没有依赖)</p><pre><code>make clean -n | -n表示提示不执行-rm -rf $(obj) a.out    “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</code></pre><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331172250751.png" alt="使用2个函数"></p><p>3 个自动变量：</p><p>​    $@: 在规则的<strong>命令中</strong>，表示<strong>规则中的目标</strong>。</p><p>​    $^: 在规则的<strong>命令中</strong>，表示<strong>所有依赖条件</strong>。</p><p>​    $&lt;: 在规则的<strong>命令中，</strong>表示<strong>第一个依赖条件</strong>。如果将该变量应用在<strong>模式规则</strong>中，它可将依赖条件列表中的依赖<strong>依次</strong>取出，套用模式规则。</p><p>模式规则：</p><p>​    %.o:%.c<br>​       gcc -c $&lt; -o %@</p></blockquote><p>使用这么多函数和自动变量的原因是<strong>方便扩展</strong></p><p><strong>不需要修改makefile</strong>即可扩展程序功能函数。</p><blockquote><p>静态模式规则：（指定模式规则下使用的obj）（obj可以有多个，可有obj函数的特性看出）</p><p>​    $(obj):%.o:%.c<br>​       gcc -c $&lt; -o %@    </p><p>伪目标：（不管重名与否都执行）</p><p>​    .PHONY: clean ALL</p><p>参数：<br>    -n：模拟执行make、make clean 命令。</p><p>​    -f：指定文件执行 make 命令。                make -f filename            (xxx.mk是makefile文件)</p></blockquote></blockquote><pre><code>作业：编写一个 makefile 可以将其所在目录下的所有独立 .c 文件编译生成同名可执行文件。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day3&quot;&gt;&lt;a href=&quot;#Day3&quot; class=&quot;headerlink&quot; title=&quot;Day3&quot;&gt;&lt;/a&gt;Day3&lt;/h1&gt;&lt;p&gt;gdb调试工具：   大前提：程序是你自己写的。  —-逻辑错误&lt;/p&gt;
&lt;p&gt;基础指令：&lt;br&gt;    -g：使用该参数编</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Xmind激活亲测有效（23/3/30）</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/%E6%97%A5%E5%B8%B8/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-30T13:43:08.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xmind激活亲测有效（23-3-30）"><a href="#Xmind激活亲测有效（23-3-30）" class="headerlink" title="Xmind激活亲测有效（23/3/30）"></a>Xmind激活亲测有效（23/3/30）</h1><p>下载资源</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330095543117.png" alt="image-20230330095543117"></p><p>双击安装包，程序自动安装在C:\Program Files\XMind下</p><p>替换</p><p>C:\Program Files\XMind\resources下的app.asar,打开xmind即可激活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xmind激活亲测有效（23-3-30）&quot;&gt;&lt;a href=&quot;#Xmind激活亲测有效（23-3-30）&quot; class=&quot;headerlink&quot; title=&quot;Xmind激活亲测有效（23/3/30）&quot;&gt;&lt;/a&gt;Xmind激活亲测有效（23/3/30）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="XMmid" scheme="https://blog.luoxiaohei.co/categories/XMmid/"/>
    
    
    <category term="XMind" scheme="https://blog.luoxiaohei.co/tags/XMind/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day2</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-31T10:13:28.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>vim的三种工作模式</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330114045599.png" alt=""></p><p>vim的快捷键</p><blockquote><p>跳转到指定行：</p><pre><code> 1. 88G （命令模式） 2. :88  (末行模式)</code></pre><p>跳转文件首：</p><p>​    gg （命令模式）</p><p>跳转文件尾：</p><p>​    G（命令模式）</p><p>自动格式化程序：</p><p>​    gg=G（命令模式）</p><p>大括号对应：</p><p>​    % （命令模式）</p><p>光标移至行首：</p><p>​    0 （命令模式）执行结束，工作模式不变。</p><p>光标移至行尾：</p><p>​    $ （命令模式）执行结束，工作模式不变。</p><p>删除单个字符：</p><p>​    x （命令模式）执行结束，工作模式不变。</p><p>替换单个字符：</p><p>​    将待替换的字符用光标选中， r （命令模式），再按欲替换的字符</p><p>删除一个单词：</p><p>​    dw（命令模式）光标置于单词的首字母进行操作。</p><p>删除光标至行尾：</p><p>​    D 或者 d$（命令模式）</p><p>删除光标至行首：</p><p>​    d0 （命令模式）</p><p>删除指定区域：</p><p>​    按 V （命令模式）切换为 “可视模式”，使用 hjkl挪移光标来选中待删除区域。  按 d 删除该区域数据。</p><p>剪切指定1行：</p><p>​    在光标所在行，按 dd （命令模式）</p><p>剪切指定N行：</p><p>​    在光标所待删除首行，按 Ndd （命令模式）</p><p>复制一行：</p><p>​    yy</p><p>粘贴：<br>    p：向后、P：向前。</p><p>查找：</p><pre><code> 1. 找 设想 内容：命令模式下， 按 “/” 输入欲搜索关键字，回车。使用 n 检索下一个。 2. 找 看到的内容：命令模式下，将光标置于单词任意一个字符上，按 “*”/ “#” </code></pre><p>单行替换：</p><p>​    将光标置于待替换行上， 进入末行模式，输入 :s /原数据/新数据</p><p>通篇替换：</p><p>​    末行模式， :%s /原数据/新数据/g   g:不加，只替换每行首个。   </p><p>指定行的替换：</p><p>​    末行模式， :起始行号，终止行号s /原数据/新数据/g   g:不加，只替换每行首个。</p><p>​        :29,35s /printf/println/g</p><p>撤销、反撤销：</p><p>​    u、ctrl+r（命令模式）</p><p>分屏：（末行模式）<br>    sp：横屏分。 Ctrl+ww 切换。</p><p>​    vsp：竖屏分。Ctrl+ww 切换。</p><p>跳转至 man 手册：</p><p>​    将光标置于待查看函数单词上，使用 K（命令模式）跳转。 指定卷， nK</p><p>查看宏定义：</p><p>​    将光标置于待查看宏定义单词上，使用 [d 查看定义语句。（命令模式）</p><p>在末行模式执行shell命令：</p><p>​    :!命令        :! ls -l<br>​    :! gcc hello.c -o hello100  | !./hello100</p><p>​    <strong>gcc hello.c -o hello = gcc -c hello.c -o hello.o + gcc hello.o -o a.out</strong></p><p>​    :! g++ hello.cpp | !./a.out</p></blockquote><hr><p>gcc编译：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/gcc%E7%BC%96%E8%AF%914%E6%AD%A5%E9%AA%A4.png" alt="gcc编译4步骤"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4步骤： 预处理、编译、汇编、连接。</span><br><span class="line"></span><br><span class="line">-I：指定头文件所在目录位置。</span><br><span class="line"></span><br><span class="line">-c：只做预处理、编译、汇编。得到 二进制 文件！！！</span><br><span class="line"></span><br><span class="line">-g：编译时添加调试语句。 主要支持 gdb 调试。</span><br><span class="line"></span><br><span class="line">-Wall： 显示所有警告信息。</span><br><span class="line"></span><br><span class="line">-D：向程序中“动态”注册宏定义。   ifdef ... #define NAME VALUE</span><br><span class="line"></span><br><span class="line">-l: 指定动态库名</span><br><span class="line"></span><br><span class="line">-L: 指定动态库路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.png" alt="动态库和静态库"></p><blockquote><blockquote><p>静态库制作及使用步骤：</p><p><strong>（-o 取名）</strong></p><pre><code>1. 将 .c 生成 .o 文件​    gcc -c add.c -o add.o2. 使用 ar 工具制作静态库    ar rcs  lib库名.a  add.o sub.o div.o3. 编译静态库到可执行文件中：    gcc test.c lib库名.a -o a.out</code></pre><p>头文件守卫：<strong>防止头文件被重复包含</strong> </p><p> implicit declaration<strong>隐式声明</strong>，这是c语言自己会声明的东西，只会做int add（int ,int）之类的声明，如果库里面有类似viod就会报错。<br>解决办法：自己在源代码中声明函数，为了复用性，我们通常用下面的头文件守卫：</p><pre><code>#ifndef _HEAD_H_#define _HEAD_H_......#endif</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后在.c中引入.h</span><br><span class="line">项目发布：</span><br><span class="line">gcc test.c ./lib/libmylib.a -o a.out -I ./inc</span><br></pre></td></tr></table></figure><p>动态库制作及使用：</p></blockquote><ol><li>将 .c 生成 .o 文件， （<strong>生成与位置无关的代码 -fPIC</strong>）</li></ol><p>​    gcc -c add.c -o add.o -fPIC         （<strong>在动态库函数后生成PIC，程序运行时再链接</strong>）</p><ol><li><p>使用 gcc -shared 制作动态库</p><p> gcc -shared -o lib库名.so    add.o sub.o div.o</p></li><li><p>编译可执行程序时，指定所使用的动态库。  -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。</p><p> gcc test.c -o a.out -lmymath -L./lib -I./inc</p></li><li><p>运行可以执行程序 ./a.out <strong>出错</strong>！！！！ —- ldd a.out —&gt; “not found” （<strong>ldd 查看程序链接信息</strong>）</p><p> error while loading shared libraries: libxxx.so: cannot open shared object file: No such file or directory</p><p> 原因：</p><pre><code> 链接器：    工作于链接阶段， 工作时需要 -l 和 -L （**执行数据段合并和地址回填**）| </code></pre><p> ​    动态链接器：    工作于程序运行阶段，工作时需要提供动态库所在固定目录位置。</p><p> 解决方式：</p><p> ​    【1】 通过环境变量：  export LD_LIBRARY_PATH=动态库路径</p><p> ​        ./a.out 成功！！！  （临时生效， 终端重启环境变量失效）改变的是进程的环境变量</p><p> ​    【2】 永久生效： 写入 终端配置文件。  .bashrc  建议使用绝对路径。eg:/home/luo/file/dynamicLab/lib</p><p> ​                1.vi ~/.bashrc</p><p> ​                2.写入 export LD_LIBRARY_PATH=动态库路径  保存</p><p> 3）. .bashrc/  source .bashrc / 重启 终端  —-&gt; 让修改后的.bashrc生效</p><p> 4）./a.out 成功！！！ </p><p> 【3】 拷贝自定义动态库 到 /lib (标准C库所在目录位置)</p><p> 【4】 配置文件法</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）sudo vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">2）写入 动态库绝对路径  保存</span><br><span class="line"></span><br><span class="line">3）sudo ldconfig -v  使配置文件生效。</span><br><span class="line"></span><br><span class="line">4）./a.out 成功！！！--- 使用 ldd  a.out 查看程序链接情况</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>数据段合并</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230331103821681.png" alt="数据段合并"></p><p>其他：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi显示readonly</span><br><span class="line">退出两个办法</span><br><span class="line">1：wq！</span><br><span class="line">2：w !sudo tee %</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-2&quot;&gt;&lt;a href=&quot;#Day-2&quot; class=&quot;headerlink&quot; title=&quot;Day 2&quot;&gt;&lt;/a&gt;Day 2&lt;/h1&gt;&lt;p&gt;vim的三种工作模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu22.04 中Drag and drop is not supported问题</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-30T12:07:03.891Z</published>
    <updated>2023-03-30T12:41:31.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu22-04-中Drag-and-drop-is-not-supported问题"><a href="#Ubuntu22-04-中Drag-and-drop-is-not-supported问题" class="headerlink" title="Ubuntu22.04 中Drag and drop is not supported问题"></a>Ubuntu22.04 中Drag and drop is not supported问题</h1><p>解决方法<br>先在terminal中安装这两个程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-prefs</span><br><span class="line">sudo apt install nemo</span><br></pre></td></tr></table></figure><p>左下角的application中选择extension， 将Desktop icons NG 选项关闭</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330202439439.png" alt="image-20230330202439439"></p><p>左下角的application中选择startup application preference， 添加如下命令</p><p><img src="https://img-blog.csdnimg.cn/1df319278b124816a90579738f0c6995.png" alt="img"></p><p>将程序重启后即可在host和vm间进行拖动传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot;&gt;&lt;a href=&quot;#Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot; class=&quot;headerlink&quot; title=&quot;Ub</summary>
      
    
    
    
    
    <category term="Ubuntu22.04" scheme="https://blog.luoxiaohei.co/tags/Ubuntu22-04/"/>
    
  </entry>
  
  <entry>
    <title>hexo：更换电脑，如何继续写博客</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/hexo/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-03-30T08:40:50.000Z</published>
    <updated>2023-03-30T11:08:11.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo：更换电脑，如何继续写博客"><a href="#hexo：更换电脑，如何继续写博客" class="headerlink" title="hexo：更换电脑，如何继续写博客"></a>hexo：更换电脑，如何继续写博客</h1><details green><summary> 哔哔 </summary>              <div class='content'>              <p>先提一句：</p><p>如果想要在百度收录，需要在百度站长验证一下，最后卡在验证环境如下：明显是访问不到外网。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330190044308.png" alt="image-20230330190044308"></p>              </div>            </details><p>1.将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>将这些目录放到一个目录下，如：hexo／</p><p>2.在你的新电脑上首先配置hexo环境：安装Node.js<br>3.安装hexo，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>4.安装好之后，进入hexo／目录<br>5.模块安装，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>6.部署，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;a href=&quot;#hexo：更换电脑，如何继续写博客&quot; class=&quot;headerlink&quot; title=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;/a&gt;hexo：更换电脑，如何继续写博客&lt;/h1&gt;&lt;details gree</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://blog.luoxiaohei.co/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day1</title>
    <link href="https://blog.luoxiaohei.co/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/"/>
    <id>https://blog.luoxiaohei.co/2023/03/29/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/</id>
    <published>2023-03-29T12:52:55.000Z</published>
    <updated>2023-03-31T11:59:44.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>学习了一些命令，这些命令记住常用的，备份难记的。</p><p>常用的比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径中，cd ..、cd .、 cd、 cd - 的使用。</span><br><span class="line">./ 本级目录 ../上一级目录</span><br><span class="line"></span><br><span class="line">删除文件rm</span><br><span class="line">rm -rf 递归强制删除</span><br><span class="line">mv 文件重命名|移动文件</span><br><span class="line">mv和cp的区别</span><br><span class="line">1、功能上的区别</span><br><span class="line">mv：用户可以使用该命令为文件或目录重命名或将文件由一个目录移入另一个目录中（该文件从原来的文件夹中消失）。</span><br><span class="line"></span><br><span class="line">cp: 该命令的功能是将给出的文件或目录拷贝到另一文件或目录中（该文件仍保存在原文件夹中）。</span><br><span class="line"></span><br><span class="line">2、从inode角度来区分</span><br><span class="line">mv：会将存储于indoe索引节点上的文件元信息也移动到新文件中。</span><br><span class="line"></span><br><span class="line">cp : 只会复制文件数据，不会复制inode索引节点上的文件元信息。</span><br><span class="line"></span><br><span class="line">创建用户sudo adduser 新用户名--- useradd</span><br><span class="line">删除用户sudo deluser 用户名</span><br><span class="line">find找文件</span><br><span class="line">ln创建软链接和硬链接的方式和属性</span><br><span class="line">chmod修改权限的两种方式</span><br><span class="line">grep查找文件内容</span><br><span class="line">压缩文件tar、rar、zip等命令---gzip and bzip with tar:因为gzip和bzip不能打包文件夹多个文件。</span><br><span class="line">tar zcvf filename file1 file2</span><br><span class="line">z:gzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">tar jcvf filename file1 file2</span><br><span class="line">z:bzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">解压</span><br><span class="line">tar zxvf filename</span><br><span class="line">tar jxvf filename</span><br><span class="line"></span><br><span class="line">rar a -r filename file</span><br><span class="line">unrar x filename</span><br><span class="line"></span><br><span class="line">zip -r filename file</span><br><span class="line">unzip filename</span><br><span class="line"></span><br><span class="line">安装软件卸载软件的方法。</span><br><span class="line">sudo aptitude show softname 查看软件安装信息</span><br></pre></td></tr></table></figure><p>文件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件。</span><br></pre></td></tr></table></figure><p>系统目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin：存放二进制可执行文件</span><br><span class="line">boot：存放开机启动程序</span><br><span class="line">dev：存放设备文件： 字符设备、块设备</span><br><span class="line">home：存放普通用户</span><br><span class="line">etc：用户信息和系统配置文件 passwd、group</span><br><span class="line">lib：库文件：libc.so.6</span><br><span class="line">root：管理员宿主目录（家目录）</span><br><span class="line">usr：用户资源管理目录 unix software resource</span><br></pre></td></tr></table></figure><p>简单的快捷键</p><p>tab显示提示、ctrl-a、ctrl-e、ctrl-u、ctrl-Alt-t。</p><p>细节的内容还请再看一遍视频讲解和讲义。</p><hr><p>学习完后写的五子棋游戏服务器，匹配游戏，断线重连，连接mysql数据库，欢迎大家一起学习 <a href="https://github.com/ChenVv-hong/Gobang">https://github.com/ChenVv-hong/Gobang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h1&gt;&lt;p&gt;学习了一些命令，这些命令记住常用的，备份难记的。&lt;/p&gt;
&lt;p&gt;常用的比如&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git操作手册（给实验室同学）</title>
    <link href="https://blog.luoxiaohei.co/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/"/>
    <id>https://blog.luoxiaohei.co/2023/02/03/hexo/1%E3%80%81%E5%AE%89%E8%A3%85GIT/</id>
    <published>2023-02-03T13:42:06.000Z</published>
    <updated>2023-03-30T11:12:11.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><p>1、安装GIT</p><p><a href="https://blog.csdn.net/adminsir0/article/details/126355313">(3条消息) git安装教程</a>（一直next就行）</p><p>2、注册远程仓库账号</p><p>打开<a href="https://github.com/">GitHub</a>，注册自己账号</p><p>不翻墙的话，注册<a href="https://gitee.com/">Gitee</a>（这个文档展示gitee）</p><p>3、本地创建任意文件夹，鼠标右键选择git bush</p><p>4、配置用户，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>5、生成SSH密钥        </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>进入C:\Users\Administrator.ssh目录下，查看生成的SSH密钥，</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181525633.jpeg" alt="img" style="zoom:50%;" /></p><p>复制id_ras.pub里面的字符串，在gitee设置中的SSH公钥中添加密钥。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181527256.png" alt="image-20221218152744139"></p><p>6、创建一个文件，在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>7、命令行输入：git init </p><p>8、命令行输入：git add .</p><p>9、命令行输入：git commit -m “123”</p><p>10、命令行输入：git remote add origin <strong>url</strong>  |  url选择你的远程仓库，比如<strong>gitee</strong>创建完仓库后，会有这个地址，我们选择SSH链接就行。</p><p>例如：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181520074.png" alt="image-20221218152045988"></p><p>11、命令行输入：git push -u origin “master”</p><p>显示成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作手册&quot;&gt;&lt;a href=&quot;#操作手册&quot; class=&quot;headerlink&quot; title=&quot;操作手册&quot;&gt;&lt;/a&gt;操作手册&lt;/h2&gt;&lt;p&gt;1、安装GIT&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/adminsir0/articl</summary>
      
    
    
    
    
    <category term="git" scheme="https://blog.luoxiaohei.co/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="https://blog.luoxiaohei.co/2022/12/16/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/12/16/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2022-12-16T07:04:14.000Z</published>
    <updated>2022-12-16T15:09:48.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212162305580.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是一道简单的动态规划问题，为什么我最开始的时候没有想到呢？最开始想到的是遍历每一种情况，求其最小值但是遍历不了每一种情况。因为没有经过系统的练习。</p><p>动态规划问题都需要有个中间数组dp。通常用于解决最大最小问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();<span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码还是需要经过系统的学习才行，下次学习的时候尽量把一个专题的东西学完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-path-sum/&quot;&gt;64. </summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同路径</title>
    <link href="https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2022-12-11T18:27:22.000Z</published>
    <updated>2022-12-16T13:54:50.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212121030018.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>这是一个高中的排列组合的一个数学题。</p><script type="math/tex; mode=display">C_{m+n-2}^{m-1}=\left(\begin{array}{c}m+n-2 \\m-1\end{array}\right)=\frac{(m+n-2)(m+n-3) \cdots n}{(m-1) !}=\frac{(m+n-2) !}{(m-1) !(n-1) !}</script><p>用算法实现这个等式就可以了。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>dfs递归暴力求解，具体实现还不熟练，直接贴代码，（超时）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h5><p>动态规划，每个答案都是前面两个答案的综总和。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划和dfs需要系统的学习，不然真的太模糊了。。。</p><p>就比如爬梯子这道题。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>动态规划方程就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2];</span><br></pre></td></tr></table></figure><p>需要注意的是：这种动态规划都可以用递归来做，但是递归的空间复杂度太高了， 通常是会超时的。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/unique-paths/&quot;&gt;62. 不同路径&lt;/a</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>56. 合并区间</title>
    <link href="https://blog.luoxiaohei.co/2022/12/11/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://blog.luoxiaohei.co/2022/12/11/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2022-12-10T19:34:20.000Z</published>
    <updated>2022-12-11T04:17:03.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开始我是想直接遍历，依次比较两个数组是否合并，能合并就push到目标二维向量res中，这样操作就导致最多只有两个数组能合并，忽略了三个及以上的数组合并的情况，所以最好的做法就是先把第一个数组push到res中，再逐个遍历对比intervals中的数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//为什么不能放在pubilc中？</span></span><br><span class="line"><span class="comment">// 重载的排序函数不能放在 public 下，这是因为重载的排序函数本质上是一个类内部的函数，它的主要作用是为类的对象提供排序功能。而 public 下的函数是可以在类的内部和外部访问的，因此不能将重载的排序函数放在 public 下。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),compare1);</span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; intervals.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(res[j][<span class="number">0</span>]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(res[j][<span class="number">1</span>],intervals[i][<span class="number">1</span>]));</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>通过chatGPT它帮我优化了一下代码。</p><p>使用了拉姆达表达式，更熟练的使用向量vector，很精彩</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">// Use a deque to store the merged intervals</span></span><br><span class="line">        deque&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort the intervals by their start time</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the first interval to the deque</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate through the remaining intervals</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// If the end time of the last interval in the deque is greater than</span></span><br><span class="line">            <span class="comment">// or equal to the start time of the current interval, merge them</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp = &#123; res.<span class="built_in">back</span>()[<span class="number">0</span>], <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]) &#125;;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise, just add the current interval to the deque</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the merged intervals as a vector</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码前，先想好思路，不然改代码会改得头大，也会阻塞我们的思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;56-合并区间&quot;&gt;&lt;a href=&quot;#56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;56. 合并区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-intervals/&quot;&gt;56. 合并区间</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2022-12-09T22:32:45.000Z</published>
    <updated>2022-12-10T06:41:12.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>目前想到两种方法，一种是贪心，就是一直走下去，看我最远能走多远，如果最远的距离大于数组长度，则必可达。</p><p>还有一种是找规律，我们可以发现，如果数组非0，那么必可达终点，所以我们只需要查看0的元素是否可以跳过去。逆向遍历，遇到0，再逆向遍历看看有没有元素能跳过这个0，如果不能则不可达，如果能继续逆向遍历到达终点，那么就是可达。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">// 判断我从开始位置能到的最远距离与数组的长度做对比，最远位置比数组长度长，则能到达。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlength = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=maxlength)</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength , i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找规律</span></span><br><span class="line"><span class="comment">// 发现如果数组元素都大于0，则必可达。</span></span><br><span class="line"><span class="comment">// 只需要判断元素中=0的元素之前是否有元素可以跳过这个0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+nums[j] &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和动态规划回溯（dfs）是重点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;55-跳跃游戏&quot;&gt;&lt;a href=&quot;#55-跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;55. 跳跃游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/jump-game/&quot;&gt;55. 跳跃游戏&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="C++、算法" scheme="https://blog.luoxiaohei.co/tags/C-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git工作流</title>
    <link href="https://blog.luoxiaohei.co/2022/12/05/hexo/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://blog.luoxiaohei.co/2022/12/05/hexo/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2022-12-05T08:40:50.000Z</published>
    <updated>2022-12-10T07:18:52.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git工作流："><a href="#git工作流：" class="headerlink" title="git工作流："></a>git工作流：</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041100978.png" alt="image-20221204110021821"></p><p>出现的问题：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041409760.png" alt="image-20221204140937710"></p><p>遇到这种情况说明，是因为虽然使用的是git push命令，但是本质还是http。（github在21年为了安全，取消账号密码身份验证（http就需要账号密码登录验证），而使用令牌(Token)的身份验证）</p><p>我们来验证是否可以连接github显示没有问题。发现连接是没有问题的。</p><p>这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041401785.png" alt="image-20221204140109692"></p><p>原因&amp;解决<br>虽然是用 git 命令push，但本质上仍然是 https，所以不允许提交。<br>使用 git remote -v 查看现在的远程 url 地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/jack8luo/-.git (fetch)</span><br><span class="line">originhttps://github.com/jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>使用下面的改 url 链接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:jack8luo/-.git   </span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                                                 </span><br><span class="line">origingit@github.com:jack8luo/-.git (fetch)</span><br><span class="line">origingit@github.com:jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>已经改为 ssh 了。现在可以正常 push 了。</p><p>测试：github不与shell交互，这个shell指的就是我们的命令行窗口了。发现使用git的工具bash也出现http连接出错。</p><p>或许也可以尝试重新配置ssh密钥连接一下试试。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041434804.png" alt="img"></p><p>windows下创建文件使用echo ” text “ &gt; 1.txt</p><p>linux使用touch 1.txt</p><p>在windows下使用touch需安装touch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install touch-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遇见：</p><h2 id="spwan-failed问题"><a href="#spwan-failed问题" class="headerlink" title="spwan failed问题"></a>spwan failed问题</h2><h3 id="可以考虑连接手机热点解决，也可以修改自己的端口：443"><a href="#可以考虑连接手机热点解决，也可以修改自己的端口：443" class="headerlink" title="可以考虑连接手机热点解决，也可以修改自己的端口：443."></a>可以考虑连接手机热点解决，也可以修改自己的端口：443.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Push failed</span><br><span class="line">Kex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22</span><br><span class="line">Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>一般情况下是以上错误都是因为挂着VPN导致端口冲突</p><p>目前遇到两类情况，解决办法如下。</p><p>1 网络本身无vpn，使用ShadowsocksR等工具科学上网<br>退出ShadowsocksR即可<br>缺点：访问github会变慢，毕竟把vpn关掉了。如果开vpn本身就是为了更快速的访问github，那这样的操作就很费劲，每次和远程仓库交互都要关掉vpn，搞完再打开，推荐2.1。<br>2 网络本身挂载vpn，如openwrt上安装了ShadowsocksR<br>解决办法有两种（推荐第一种）<br>2.1 修改项目目录中隐藏文件夹 .git 内的 config 文件<br>将 Project/.git/config 文件中ssh格式的url，修改为github仓库中https格式的url。如：</p><p>url = <a href="https://github.com/username/SpringBootWebTest.git">https://github.com/username/SpringBootWebTest.git</a></p><p>因为开着vpn，代理端口走22；同时git的ssh一般也使用22端口，这样造成冲突；而git的https一般使用443端口，不会产生冲突。</p><p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用https可以很好地绕开安全限制使用git；但是对于ssh来说，企业防火墙很可能没打开22端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git工作流：&quot;&gt;&lt;a href=&quot;#git工作流：&quot; class=&quot;headerlink&quot; title=&quot;git工作流：&quot;&gt;&lt;/a&gt;git工作流：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8l</summary>
      
    
    
    
    
    <category term="Git" scheme="https://blog.luoxiaohei.co/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-12-01T04:25:51.000Z</published>
    <updated>2022-12-08T04:43:54.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027984.png" alt="image-20221201202701906"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027198.png" alt="image-20221201202722150"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>顺时针旋转90°==先水平旋转，再主对角线旋转</p><p>这就类似于把一步旋转操作拆分成了两步操作，从而化简了算法的复杂性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="type">int</span> j = matrix.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][k],matrix[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>就是简单一数学题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/rotate-image/&quot;&gt;48. 旋转图像&lt;/a</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://blog.luoxiaohei.co/2022/11/30/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://blog.luoxiaohei.co/2022/11/30/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-11-29T19:16:56.000Z</published>
    <updated>2022-11-30T03:26:36.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>全排列的问题做过很多次，但是这次还是没写出来，在这里总结一下。</p><p>全排列就是深度搜索dfs，也叫做回溯算法，相同的题目还有<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>。回溯深搜都是暴力算法，不同于遍历，深搜可以更有效地暴力。</p>              </div>            </details><p>在这里介绍一下c++的next_permutation(nums.begin(), nums.end())函数。这个函数返回的是bool，在函数执行中会将nums的下一次排列换成nums。</p><p>比如这道题的解法一就用到了这个函数</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似的题可以看<a href="https://blog.luoxiaohei.co/2022/10/17/31. 下一个排列/">力扣hot100—031 下一个排列 | 骆小黑 (luoxiaohei.co)</a></p><hr><h2 id="暴力回溯"><a href="#暴力回溯" class="headerlink" title="暴力回溯"></a>暴力回溯</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;bool&gt; tag;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tag.resize(n, false);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (temp.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!tag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                tag[i] = true;</span><br><span class="line">                dfs(nums);</span><br><span class="line">                temp.pop_back();//递归完一个结果123之后清理temp和tag</span><br><span class="line">                tag[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似题可以看<a href="https://blog.luoxiaohei.co/2022/11/27/ 组合总和/">组合总和 | 骆小黑 (luoxiaohei.co)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油！未来可期！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全排列&quot; class=&quot;headerlink&quot; title=&quot;46. 全排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/&quot;&gt;46. 全排列&lt;/a&gt;&lt;/h</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>二分查找之找到=target的第一个数和最后一个数</title>
    <link href="https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/</id>
    <published>2022-11-27T18:44:50.000Z</published>
    <updated>2023-03-31T12:53:55.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>​        最近做了很多二分查找的算法题，这里来整理一下学到了什么。</p><p>​        做到有关二分查找的题目</p><p>​    -     <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>​    -     <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>​    -     <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>              </div>            </details><p>针对34题总结了一下二分查找的一些细节。</p><p>普通的二分查找很简单。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[mid] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; index)</span><br><span class="line">   index = mid;</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; val)</span><br><span class="line">right = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &lt; val)</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到-target的第一个数"><a href="#找到-target的第一个数" class="headerlink" title="找到=target的第一个数"></a>找到=target的第一个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的第一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找到-target的最后一个数"><a href="#找到-target的最后一个数" class="headerlink" title="找到=target的最后一个数"></a>找到=target的最后一个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的最后一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="comment">// 因为l已经累加了，如果l等于r的情况不能进行判断，那么l=r-1 且 两个数都是target时，mid只会=l，lside也是，我们要的结果是右边的，即r</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>好啦，我要去打怪兽了，掰掰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找总结&quot;&gt;&lt;a href=&quot;#二分查找总结&quot; class=&quot;headerlink&quot; title=&quot;二分查找总结&quot;&gt;&lt;/a&gt;二分查找总结&lt;/h2&gt;&lt;details pink&gt;&lt;summary&gt; 哔哔 &lt;/summary&gt;
              &lt;div </summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>组合总和</title>
    <link href="https://blog.luoxiaohei.co/2022/11/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/11/27/%E6%97%A5%E5%B8%B8%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2022-11-27T05:18:48.000Z</published>
    <updated>2022-11-27T13:25:22.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p>candidates 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这个题目和背包问题是一样的，采用的dfs的回溯算法。有张图就能很好理解了。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211272122380.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = candidates.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rside;</span><br><span class="line">        <span class="comment">// 先二分查找小于等于target值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                rside = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            rside = r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, <span class="number">0</span>, rside);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;combine, <span class="type">int</span> idx,<span class="type">int</span> rside)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; rside)  <span class="comment">//剪枝，当idx&gt;target时，就不用继续执行了。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, idx + <span class="number">1</span>,rside);</span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) <span class="comment">//剪枝 target是传参量</span></span><br><span class="line">        &#123; <span class="comment">// stop untifin dfs</span></span><br><span class="line">            combine.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], combine, idx,rside);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c = a.<span class="built_in">combinationSum</span>(b, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rowV : c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;el : rowV)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打印二维vector</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVecofVec1</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowV : res) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; el : rowV) &#123;</span><br><span class="line">      cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort采用的是什么排序？</p><p><strong>sort函数的底层用到的是内省式排序以及插入排序</strong>,内省排序首先从快速排序开始,当递归深度超过一定深度(深度为排序元素数量的对数值)后转为堆排序</p><p>回溯算法不剪枝就是暴力枚举，也可以理解为枚举没办法的办法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://blog.luoxiaohei.co/2022/11/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://blog.luoxiaohei.co/2022/11/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2022-11-25T18:30:30.000Z</published>
    <updated>2023-03-31T12:55:24.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到log（n）就能想到二分查找，但是二分查找里面怎么找到第一个重复元素呢？</p><p>答案就是在二分查找中选择<strong>nums[mid] &gt;= target</strong>,不在==target时return，最后就能退到第一个target。</p><p>还有就是||运算符 是不会全部执行的。如果我们想要判断查到的元素是否为target时，<strong>nums[mid] == target</strong>。 但是我们的mid可能越界时。我们可以先判断是否越位之后再判断是否相等，比如 <strong>if(l == nums.size()||nums[l] != target)</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">search</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找要仔细判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-11-24T19:28:31.000Z</published>
    <updated>2022-11-25T08:11:48.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组 <strong>nums</strong> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 <strong>旋转</strong>，使数组变为 <strong>[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]</strong>（下标 <strong>从 0 开始</strong> 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><p>like this</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251152114.png" alt="img"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span>&#123;  <span class="comment">//二分查找升级版</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) <span class="comment">// 有=</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[mid])</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">search</span>(b,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：二分查找，快排之类的都是很重要的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;整数数组 &lt;strong&gt;nums&lt;/strong&gt; 按升序排列，数组中的值 互不相同 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
</feed>
