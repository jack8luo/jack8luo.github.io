<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骆小黑</title>
  
  <subtitle>阿妮亚</subtitle>
  <link href="https://blog.luoxiaohei.co/atom.xml" rel="self"/>
  
  <link href="https://blog.luoxiaohei.co/"/>
  <updated>2023-03-30T13:42:41.516Z</updated>
  <id>https://blog.luoxiaohei.co/</id>
  
  <author>
    <name>骆小黑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程Day2</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%202/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-30T13:42:41.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>vim的三种工作模式</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330114045599.png" alt=""></p><p>vim的快捷键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">跳转到指定行：</span><br><span class="line"></span><br><span class="line">1. 88G （命令模式）</span><br><span class="line"></span><br><span class="line">2. :88  (末行模式)</span><br><span class="line"></span><br><span class="line">跳转文件首：</span><br><span class="line"></span><br><span class="line">gg （命令模式）</span><br><span class="line"></span><br><span class="line">跳转文件尾：</span><br><span class="line"></span><br><span class="line">G（命令模式）</span><br><span class="line"></span><br><span class="line">自动格式化程序：</span><br><span class="line"></span><br><span class="line">gg=G（命令模式）</span><br><span class="line"></span><br><span class="line">大括号对应：</span><br><span class="line"></span><br><span class="line">% （命令模式）</span><br><span class="line"></span><br><span class="line">光标移至行首：</span><br><span class="line"></span><br><span class="line">0 （命令模式）执行结束，工作模式不变。</span><br><span class="line"></span><br><span class="line">光标移至行尾：</span><br><span class="line"></span><br><span class="line">$ （命令模式）执行结束，工作模式不变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除单个字符：</span><br><span class="line"></span><br><span class="line">x （命令模式）执行结束，工作模式不变。</span><br><span class="line"></span><br><span class="line">替换单个字符：</span><br><span class="line"></span><br><span class="line">将待替换的字符用光标选中， r （命令模式），再按欲替换的字符</span><br><span class="line"></span><br><span class="line">删除一个单词：</span><br><span class="line"></span><br><span class="line">dw（命令模式）光标置于单词的首字母进行操作。</span><br><span class="line"></span><br><span class="line">删除光标至行尾：</span><br><span class="line"></span><br><span class="line">D 或者 d$（命令模式）</span><br><span class="line"></span><br><span class="line">删除光标至行首：</span><br><span class="line"></span><br><span class="line">d0 （命令模式）</span><br><span class="line"></span><br><span class="line">删除指定区域：</span><br><span class="line"></span><br><span class="line">按 V （命令模式）切换为 “可视模式”，使用 hjkl挪移光标来选中待删除区域。  按 d 删除该区域数据。</span><br><span class="line"></span><br><span class="line">删除指定1行：</span><br><span class="line"></span><br><span class="line">在光标所在行，按 dd （命令模式）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除指定N行：</span><br><span class="line"></span><br><span class="line">在光标所待删除首行，按 Ndd （命令模式）</span><br><span class="line"></span><br><span class="line">复制一行：</span><br><span class="line"></span><br><span class="line">yy</span><br><span class="line"></span><br><span class="line">粘贴：</span><br><span class="line">p：向后、P：向前。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查找：</span><br><span class="line">1. 找 设想 内容：</span><br><span class="line"></span><br><span class="line">命令模式下， 按 “/” 输入欲搜索关键字，回车。使用 n 检索下一个。</span><br><span class="line"></span><br><span class="line">2. 找 看到的内容：</span><br><span class="line"></span><br><span class="line">命令模式下，将光标置于单词任意一个字符上，按 “*”/ “#” </span><br><span class="line"></span><br><span class="line">单行替换：</span><br><span class="line"></span><br><span class="line">将光标置于待替换行上， 进入末行模式，输入 :s /原数据/新数据</span><br><span class="line"></span><br><span class="line">通篇替换：</span><br><span class="line"></span><br><span class="line">末行模式， :%s /原数据/新数据/g   g:不加，只替换每行首个。   </span><br><span class="line"></span><br><span class="line">指定行的替换：</span><br><span class="line"></span><br><span class="line">末行模式， :起始行号，终止行号s /原数据/新数据/g   g:不加，只替换每行首个。</span><br><span class="line"></span><br><span class="line">:29,35s /printf/println/g</span><br><span class="line"></span><br><span class="line">撤销、反撤销：</span><br><span class="line"></span><br><span class="line">u、ctrl+r（命令模式）</span><br><span class="line"></span><br><span class="line">分屏：（末行模式）</span><br><span class="line">sp：横屏分。 Ctrl+ww 切换。</span><br><span class="line"></span><br><span class="line">vsp：竖屏分。Ctrl+ww 切换。</span><br><span class="line"></span><br><span class="line">跳转至 man 手册：</span><br><span class="line"></span><br><span class="line">将光标置于待查看函数单词上，使用 K（命令模式）跳转。 指定卷， nK</span><br><span class="line"></span><br><span class="line">查看宏定义：</span><br><span class="line"></span><br><span class="line">将光标置于待查看宏定义单词上，使用 [d 查看定义语句。（命令模式）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在末行模式执行shell命令：</span><br><span class="line"></span><br><span class="line">:!命令:! ls -l </span><br><span class="line">:! gcc hello.c -o hello100  | !./hello100</span><br><span class="line">:! g++ hello.cpp | !./a.out</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>gcc编译：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/gcc%E7%BC%96%E8%AF%914%E6%AD%A5%E9%AA%A4.png" alt="gcc编译4步骤"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4步骤： 预处理、编译、汇编、连接。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-I：指定头文件所在目录位置。</span><br><span class="line"></span><br><span class="line">-c：只做预处理、编译、汇编。得到 二进制 文件！！！</span><br><span class="line"></span><br><span class="line">-g：编译时添加调试语句。 主要支持 gdb 调试。</span><br><span class="line"></span><br><span class="line">-Wall： 显示所有警告信息。</span><br><span class="line"></span><br><span class="line">-D：向程序中“动态”注册宏定义。   ifdef ... #define NAME VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.png" alt="动态库和静态库"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态库制作及使用步骤：</span><br><span class="line"></span><br><span class="line">1. 将 .c 生成 .o 文件</span><br><span class="line"></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line">2. 使用 ar 工具制作静态库</span><br><span class="line"></span><br><span class="line">ar rcs  lib库名.a  add.o sub.o div.o</span><br><span class="line"></span><br><span class="line">3. 编译静态库到可执行文件中：</span><br><span class="line"></span><br><span class="line">gcc test.c lib库名.a -o a.out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头文件守卫：防止头文件被重复包含 | implicit declaration隐式声明，这是c语言自己会声明的东西，只会做int add（int ,int）之类的声明，如果库里面有类似viod就会报错。</span><br><span class="line">解决办法：自己在源代码中声明函数，为了复用性，我们通常用下面的头文件守卫：</span><br><span class="line"></span><br><span class="line">#ifndef _HEAD_H_</span><br><span class="line"></span><br><span class="line">#define _HEAD_H_</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">然后在.c中引入.h</span><br><span class="line">项目发布：</span><br><span class="line">gcc test.c ./lib/libmylib.a -o a.out -I ./inc</span><br></pre></td></tr></table></figure><p>其他：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi显示readonly</span><br><span class="line">退出两个办法</span><br><span class="line">1：wq！</span><br><span class="line">2：w !sudo tee %</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-2&quot;&gt;&lt;a href=&quot;#Day-2&quot; class=&quot;headerlink&quot; title=&quot;Day 2&quot;&gt;&lt;/a&gt;Day 2&lt;/h1&gt;&lt;p&gt;vim的三种工作模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Xmind激活亲测有效（23/3/30）</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Xmind%E6%BF%80%E6%B4%BB%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8823330%EF%BC%89/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-30T13:43:08.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xmind激活亲测有效（23-3-30）"><a href="#Xmind激活亲测有效（23-3-30）" class="headerlink" title="Xmind激活亲测有效（23/3/30）"></a>Xmind激活亲测有效（23/3/30）</h1><p>下载资源</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330095543117.png" alt="image-20230330095543117"></p><p>双击安装包，程序自动安装在C:\Program Files\XMind下</p><p>替换</p><p>C:\Program Files\XMind\resources下的app.asar,打开xmind即可激活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Xmind激活亲测有效（23-3-30）&quot;&gt;&lt;a href=&quot;#Xmind激活亲测有效（23-3-30）&quot; class=&quot;headerlink&quot; title=&quot;Xmind激活亲测有效（23/3/30）&quot;&gt;&lt;/a&gt;Xmind激活亲测有效（23/3/30）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="XMmid" scheme="https://blog.luoxiaohei.co/categories/XMmid/"/>
    
    
    <category term="XMind" scheme="https://blog.luoxiaohei.co/tags/XMind/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程Day1</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8BDay%201/</id>
    <published>2023-03-30T12:52:55.000Z</published>
    <updated>2023-03-30T13:42:23.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>学习了一些命令，这些命令记住常用的，备份难记的。</p><p>常用的比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径中，cd ..、cd .、 cd、 cd - 的使用。</span><br><span class="line">mv 文件重命名|移动文件</span><br><span class="line">创建用户sudo adduser 新用户名--- useradd</span><br><span class="line">删除用户sudo deluser 用户名</span><br><span class="line">find找文件</span><br><span class="line">ln创建软链接和硬链接的方式和属性</span><br><span class="line">chmod修改权限的两种方式</span><br><span class="line">grep查找文件内容</span><br><span class="line">压缩文件tar、rar、zip等命令---gzip and bzip with tar:因为gzip和bzip不能打包文件夹多个文件。</span><br><span class="line">tar zcvf filename file1 file2</span><br><span class="line">z:gzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">tar jcvf filename file1 file2</span><br><span class="line">z:bzip方式、c:创建、v:显示压缩、f：名字</span><br><span class="line">解压</span><br><span class="line">tar zxvf filename</span><br><span class="line">tar jxvf filename</span><br><span class="line"></span><br><span class="line">rar a -r filename file</span><br><span class="line">unrar x filename</span><br><span class="line"></span><br><span class="line">zip -r filename file</span><br><span class="line">unzip filename</span><br><span class="line"></span><br><span class="line">安装软件卸载软件的方法。</span><br><span class="line">sudo aptitude show softname 查看软件安装信息</span><br></pre></td></tr></table></figure><p>文件类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d</span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件。</span><br></pre></td></tr></table></figure><p>系统目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin：存放二进制可执行文件</span><br><span class="line">boot：存放开机启动程序</span><br><span class="line">dev：存放设备文件： 字符设备、块设备</span><br><span class="line">home：存放普通用户</span><br><span class="line">etc：用户信息和系统配置文件 passwd、group</span><br><span class="line">lib：库文件：libc.so.6</span><br><span class="line">root：管理员宿主目录（家目录）</span><br><span class="line">usr：用户资源管理目录 unix software resource</span><br></pre></td></tr></table></figure><p>简单的快捷键</p><p>tab显示提示、ctrl-a、ctrl-e、ctrl-u、ctrl-Alt-t。</p><p>细节的内容还请再看一遍视频讲解和讲义。</p><hr><p>学习完后写的五子棋游戏服务器，匹配游戏，断线重连，连接mysql数据库，欢迎大家一起学习 <a href="https://github.com/ChenVv-hong/Gobang">https://github.com/ChenVv-hong/Gobang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h1&gt;&lt;p&gt;学习了一些命令，这些命令记住常用的，备份难记的。&lt;/p&gt;
&lt;p&gt;常用的比如&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.luoxiaohei.co/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu22.04 中Drag and drop is not supported问题</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/Ubuntu22.04%20%E4%B8%ADDrag%20and%20drop%20is%20not%20supported%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-30T12:07:03.891Z</published>
    <updated>2023-03-30T12:41:31.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu22-04-中Drag-and-drop-is-not-supported问题"><a href="#Ubuntu22-04-中Drag-and-drop-is-not-supported问题" class="headerlink" title="Ubuntu22.04 中Drag and drop is not supported问题"></a>Ubuntu22.04 中Drag and drop is not supported问题</h1><p>解决方法<br>先在terminal中安装这两个程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-prefs</span><br><span class="line">sudo apt install nemo</span><br></pre></td></tr></table></figure><p>左下角的application中选择extension， 将Desktop icons NG 选项关闭</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330202439439.png" alt="image-20230330202439439"></p><p>左下角的application中选择startup application preference， 添加如下命令</p><p><img src="https://img-blog.csdnimg.cn/1df319278b124816a90579738f0c6995.png" alt="img"></p><p>将程序重启后即可在host和vm间进行拖动传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot;&gt;&lt;a href=&quot;#Ubuntu22-04-中Drag-and-drop-is-not-supported问题&quot; class=&quot;headerlink&quot; title=&quot;Ub</summary>
      
    
    
    
    
    <category term="Ubuntu22.04" scheme="https://blog.luoxiaohei.co/tags/Ubuntu22-04/"/>
    
  </entry>
  
  <entry>
    <title>hexo：更换电脑，如何继续写博客</title>
    <link href="https://blog.luoxiaohei.co/2023/03/30/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blog.luoxiaohei.co/2023/03/30/hexo%EF%BC%9A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-03-30T08:40:50.000Z</published>
    <updated>2023-03-30T11:02:19.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo：更换电脑，如何继续写博客"><a href="#hexo：更换电脑，如何继续写博客" class="headerlink" title="hexo：更换电脑，如何继续写博客"></a>hexo：更换电脑，如何继续写博客</h1><details green><summary> 哔哔 </summary>              <div class='content'>              <p>先提一句：</p><p>如果想要在百度收录，需要在百度站长验证一下，最后卡在验证环境如下：明显是访问不到外网。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330190044308.png" alt="image-20230330190044308"></p>              </div>            </details><p>1.将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>将这些目录放到一个目录下，如：hexo／</p><p>2.在你的新电脑上首先配置hexo环境：安装Node.js<br>3.安装hexo，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>4.安装好之后，进入hexo／目录<br>5.模块安装，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>6.部署，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;a href=&quot;#hexo：更换电脑，如何继续写博客&quot; class=&quot;headerlink&quot; title=&quot;hexo：更换电脑，如何继续写博客&quot;&gt;&lt;/a&gt;hexo：更换电脑，如何继续写博客&lt;/h1&gt;&lt;details gree</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://blog.luoxiaohei.co/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>git操作手册（给实验室同学）</title>
    <link href="https://blog.luoxiaohei.co/2023/02/03/1%E3%80%81%E5%AE%89%E8%A3%85GIT/"/>
    <id>https://blog.luoxiaohei.co/2023/02/03/1%E3%80%81%E5%AE%89%E8%A3%85GIT/</id>
    <published>2023-02-03T13:42:06.000Z</published>
    <updated>2023-03-30T11:09:36.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><p>1、安装GIT</p><p><a href="https://blog.csdn.net/adminsir0/article/details/126355313">(3条消息) git安装教程</a>（一直next就行）</p><p>2、注册远程仓库账号</p><p>打开<a href="https://github.com/">GitHub</a>，注册自己账号</p><p>不翻墙的话，注册<a href="https://gitee.com/">Gitee</a>（这个文档展示gitee）</p><p>3、本地创建任意文件夹，鼠标右键选择git bush</p><p>4、配置用户，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>5、生成SSH密钥        </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>进入C:\Users\Administrator.ssh目录下，查看生成的SSH密钥，</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181525633.jpeg" alt="img" style="zoom:50%;" /></p><p>复制id_ras.pub里面的字符串，在gitee设置中的SSH公钥中添加密钥。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181527256.png" alt="image-20221218152744139"></p><p>6、创建一个文件，在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>7、命令行输入：git init </p><p>8、命令行输入：git add .</p><p>9、命令行输入：git commit -m “123”</p><p>10、命令行输入：git remote add origin <strong>url</strong>  |  url选择你的远程仓库，比如<strong>gitee</strong>创建完仓库后，会有这个地址，我们选择SSH链接就行。</p><p>例如：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181520074.png" alt="image-20221218152045988"></p><p>11、命令行输入：git push -u origin “master”</p><p>显示成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作手册&quot;&gt;&lt;a href=&quot;#操作手册&quot; class=&quot;headerlink&quot; title=&quot;操作手册&quot;&gt;&lt;/a&gt;操作手册&lt;/h2&gt;&lt;p&gt;1、安装GIT&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/adminsir0/articl</summary>
      
    
    
    
    
    <category term="git" scheme="https://blog.luoxiaohei.co/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="https://blog.luoxiaohei.co/2022/12/16/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/12/16/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2022-12-16T07:04:14.000Z</published>
    <updated>2022-12-16T15:09:48.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212162305580.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是一道简单的动态规划问题，为什么我最开始的时候没有想到呢？最开始想到的是遍历每一种情况，求其最小值但是遍历不了每一种情况。因为没有经过系统的练习。</p><p>动态规划问题都需要有个中间数组dp。通常用于解决最大最小问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();<span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码还是需要经过系统的学习才行，下次学习的时候尽量把一个专题的东西学完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-path-sum/&quot;&gt;64. </summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同路径</title>
    <link href="https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2022-12-11T18:27:22.000Z</published>
    <updated>2022-12-16T13:54:50.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212121030018.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>这是一个高中的排列组合的一个数学题。</p><script type="math/tex; mode=display">C_{m+n-2}^{m-1}=\left(\begin{array}{c}m+n-2 \\m-1\end{array}\right)=\frac{(m+n-2)(m+n-3) \cdots n}{(m-1) !}=\frac{(m+n-2) !}{(m-1) !(n-1) !}</script><p>用算法实现这个等式就可以了。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>dfs递归暴力求解，具体实现还不熟练，直接贴代码，（超时）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h5><p>动态规划，每个答案都是前面两个答案的综总和。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划和dfs需要系统的学习，不然真的太模糊了。。。</p><p>就比如爬梯子这道题。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>动态规划方程就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2];</span><br></pre></td></tr></table></figure><p>需要注意的是：这种动态规划都可以用递归来做，但是递归的空间复杂度太高了， 通常是会超时的。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/unique-paths/&quot;&gt;62. 不同路径&lt;/a</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>56. 合并区间</title>
    <link href="https://blog.luoxiaohei.co/2022/12/11/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://blog.luoxiaohei.co/2022/12/11/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2022-12-10T19:34:20.000Z</published>
    <updated>2022-12-11T04:17:03.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开始我是想直接遍历，依次比较两个数组是否合并，能合并就push到目标二维向量res中，这样操作就导致最多只有两个数组能合并，忽略了三个及以上的数组合并的情况，所以最好的做法就是先把第一个数组push到res中，再逐个遍历对比intervals中的数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//为什么不能放在pubilc中？</span></span><br><span class="line"><span class="comment">// 重载的排序函数不能放在 public 下，这是因为重载的排序函数本质上是一个类内部的函数，它的主要作用是为类的对象提供排序功能。而 public 下的函数是可以在类的内部和外部访问的，因此不能将重载的排序函数放在 public 下。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),compare1);</span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; intervals.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(res[j][<span class="number">0</span>]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(res[j][<span class="number">1</span>],intervals[i][<span class="number">1</span>]));</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>通过chatGPT它帮我优化了一下代码。</p><p>使用了拉姆达表达式，更熟练的使用向量vector，很精彩</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">// Use a deque to store the merged intervals</span></span><br><span class="line">        deque&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort the intervals by their start time</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the first interval to the deque</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate through the remaining intervals</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// If the end time of the last interval in the deque is greater than</span></span><br><span class="line">            <span class="comment">// or equal to the start time of the current interval, merge them</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp = &#123; res.<span class="built_in">back</span>()[<span class="number">0</span>], <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]) &#125;;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise, just add the current interval to the deque</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the merged intervals as a vector</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码前，先想好思路，不然改代码会改得头大，也会阻塞我们的思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;56-合并区间&quot;&gt;&lt;a href=&quot;#56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;56. 合并区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-intervals/&quot;&gt;56. 合并区间</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2022-12-09T22:32:45.000Z</published>
    <updated>2022-12-10T06:41:12.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>目前想到两种方法，一种是贪心，就是一直走下去，看我最远能走多远，如果最远的距离大于数组长度，则必可达。</p><p>还有一种是找规律，我们可以发现，如果数组非0，那么必可达终点，所以我们只需要查看0的元素是否可以跳过去。逆向遍历，遇到0，再逆向遍历看看有没有元素能跳过这个0，如果不能则不可达，如果能继续逆向遍历到达终点，那么就是可达。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">// 判断我从开始位置能到的最远距离与数组的长度做对比，最远位置比数组长度长，则能到达。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlength = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=maxlength)</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength , i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找规律</span></span><br><span class="line"><span class="comment">// 发现如果数组元素都大于0，则必可达。</span></span><br><span class="line"><span class="comment">// 只需要判断元素中=0的元素之前是否有元素可以跳过这个0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+nums[j] &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和动态规划回溯（dfs）是重点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;55-跳跃游戏&quot;&gt;&lt;a href=&quot;#55-跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;55. 跳跃游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/jump-game/&quot;&gt;55. 跳跃游戏&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="C++、算法" scheme="https://blog.luoxiaohei.co/tags/C-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git工作流</title>
    <link href="https://blog.luoxiaohei.co/2022/12/05/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://blog.luoxiaohei.co/2022/12/05/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2022-12-05T08:40:50.000Z</published>
    <updated>2022-12-10T07:18:52.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git工作流："><a href="#git工作流：" class="headerlink" title="git工作流："></a>git工作流：</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041100978.png" alt="image-20221204110021821"></p><p>出现的问题：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041409760.png" alt="image-20221204140937710"></p><p>遇到这种情况说明，是因为虽然使用的是git push命令，但是本质还是http。（github在21年为了安全，取消账号密码身份验证（http就需要账号密码登录验证），而使用令牌(Token)的身份验证）</p><p>我们来验证是否可以连接github显示没有问题。发现连接是没有问题的。</p><p>这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041401785.png" alt="image-20221204140109692"></p><p>原因&amp;解决<br>虽然是用 git 命令push，但本质上仍然是 https，所以不允许提交。<br>使用 git remote -v 查看现在的远程 url 地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/jack8luo/-.git (fetch)</span><br><span class="line">originhttps://github.com/jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>使用下面的改 url 链接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:jack8luo/-.git   </span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                                                 </span><br><span class="line">origingit@github.com:jack8luo/-.git (fetch)</span><br><span class="line">origingit@github.com:jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>已经改为 ssh 了。现在可以正常 push 了。</p><p>测试：github不与shell交互，这个shell指的就是我们的命令行窗口了。发现使用git的工具bash也出现http连接出错。</p><p>或许也可以尝试重新配置ssh密钥连接一下试试。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041434804.png" alt="img"></p><p>windows下创建文件使用echo ” text “ &gt; 1.txt</p><p>linux使用touch 1.txt</p><p>在windows下使用touch需安装touch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install touch-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遇见：</p><h2 id="spwan-failed问题"><a href="#spwan-failed问题" class="headerlink" title="spwan failed问题"></a>spwan failed问题</h2><h3 id="可以考虑连接手机热点解决，也可以修改自己的端口：443"><a href="#可以考虑连接手机热点解决，也可以修改自己的端口：443" class="headerlink" title="可以考虑连接手机热点解决，也可以修改自己的端口：443."></a>可以考虑连接手机热点解决，也可以修改自己的端口：443.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Push failed</span><br><span class="line">Kex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22</span><br><span class="line">Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>一般情况下是以上错误都是因为挂着VPN导致端口冲突</p><p>目前遇到两类情况，解决办法如下。</p><p>1 网络本身无vpn，使用ShadowsocksR等工具科学上网<br>退出ShadowsocksR即可<br>缺点：访问github会变慢，毕竟把vpn关掉了。如果开vpn本身就是为了更快速的访问github，那这样的操作就很费劲，每次和远程仓库交互都要关掉vpn，搞完再打开，推荐2.1。<br>2 网络本身挂载vpn，如openwrt上安装了ShadowsocksR<br>解决办法有两种（推荐第一种）<br>2.1 修改项目目录中隐藏文件夹 .git 内的 config 文件<br>将 Project/.git/config 文件中ssh格式的url，修改为github仓库中https格式的url。如：</p><p>url = <a href="https://github.com/username/SpringBootWebTest.git">https://github.com/username/SpringBootWebTest.git</a></p><p>因为开着vpn，代理端口走22；同时git的ssh一般也使用22端口，这样造成冲突；而git的https一般使用443端口，不会产生冲突。</p><p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用https可以很好地绕开安全限制使用git；但是对于ssh来说，企业防火墙很可能没打开22端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git工作流：&quot;&gt;&lt;a href=&quot;#git工作流：&quot; class=&quot;headerlink&quot; title=&quot;git工作流：&quot;&gt;&lt;/a&gt;git工作流：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8l</summary>
      
    
    
    
    
    <category term="Git" scheme="https://blog.luoxiaohei.co/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-12-01T04:25:51.000Z</published>
    <updated>2022-12-08T04:43:54.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027984.png" alt="image-20221201202701906"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027198.png" alt="image-20221201202722150"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>顺时针旋转90°==先水平旋转，再主对角线旋转</p><p>这就类似于把一步旋转操作拆分成了两步操作，从而化简了算法的复杂性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="type">int</span> j = matrix.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][k],matrix[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>就是简单一数学题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/rotate-image/&quot;&gt;48. 旋转图像&lt;/a</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://blog.luoxiaohei.co/2022/11/30/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://blog.luoxiaohei.co/2022/11/30/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-11-29T19:16:56.000Z</published>
    <updated>2022-11-30T03:26:36.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>全排列的问题做过很多次，但是这次还是没写出来，在这里总结一下。</p><p>全排列就是深度搜索dfs，也叫做回溯算法，相同的题目还有<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>。回溯深搜都是暴力算法，不同于遍历，深搜可以更有效地暴力。</p>              </div>            </details><p>在这里介绍一下c++的next_permutation(nums.begin(), nums.end())函数。这个函数返回的是bool，在函数执行中会将nums的下一次排列换成nums。</p><p>比如这道题的解法一就用到了这个函数</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似的题可以看<a href="https://blog.luoxiaohei.co/2022/10/17/31. 下一个排列/">力扣hot100—031 下一个排列 | 骆小黑 (luoxiaohei.co)</a></p><hr><h2 id="暴力回溯"><a href="#暴力回溯" class="headerlink" title="暴力回溯"></a>暴力回溯</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;bool&gt; tag;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tag.resize(n, false);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (temp.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!tag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                tag[i] = true;</span><br><span class="line">                dfs(nums);</span><br><span class="line">                temp.pop_back();//递归完一个结果123之后清理temp和tag</span><br><span class="line">                tag[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似题可以看<a href="https://blog.luoxiaohei.co/2022/11/27/ 组合总和/">组合总和 | 骆小黑 (luoxiaohei.co)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油！未来可期！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全排列&quot; class=&quot;headerlink&quot; title=&quot;46. 全排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/&quot;&gt;46. 全排列&lt;/a&gt;&lt;/h</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>二分查找之找到最左最右元素</title>
    <link href="https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/</id>
    <published>2022-11-27T18:44:50.000Z</published>
    <updated>2022-11-28T03:02:02.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>​        最近做了很多二分查找的算法题，这里来整理一下学到了什么。</p><p>​        做到有关二分查找的题目</p><p>​    -     <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>​    -     <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>​    -     <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>              </div>            </details><p>针对34题总结了一下二分查找的一些细节。</p><p>普通的二分查找很简单。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[mid] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; index)</span><br><span class="line">   index = mid;</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; val)</span><br><span class="line">right = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &lt; val)</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到最左边元素"><a href="#找到最左边元素" class="headerlink" title="找到最左边元素"></a>找到最左边元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的第一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找到最右边元素"><a href="#找到最右边元素" class="headerlink" title="找到最右边元素"></a>找到最右边元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的最后一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="comment">// 因为l已经累加了，如果l等于r的情况不能进行判断，那么l=r-1 且 两个数都是target时，mid只会=l，lside也是，我们要的结果是右边的，即r</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>好啦，我要去打怪兽了，掰掰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找总结&quot;&gt;&lt;a href=&quot;#二分查找总结&quot; class=&quot;headerlink&quot; title=&quot;二分查找总结&quot;&gt;&lt;/a&gt;二分查找总结&lt;/h2&gt;&lt;details pink&gt;&lt;summary&gt; 哔哔 &lt;/summary&gt;
              &lt;div </summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>组合总和</title>
    <link href="https://blog.luoxiaohei.co/2022/11/27/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/11/27/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2022-11-27T05:18:48.000Z</published>
    <updated>2022-11-27T13:25:22.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p>candidates 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这个题目和背包问题是一样的，采用的dfs的回溯算法。有张图就能很好理解了。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211272122380.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = candidates.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rside;</span><br><span class="line">        <span class="comment">// 先二分查找小于等于target值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                rside = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            rside = r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, <span class="number">0</span>, rside);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;combine, <span class="type">int</span> idx,<span class="type">int</span> rside)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; rside)  <span class="comment">//剪枝，当idx&gt;target时，就不用继续执行了。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, idx + <span class="number">1</span>,rside);</span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) <span class="comment">//剪枝 target是传参量</span></span><br><span class="line">        &#123; <span class="comment">// stop untifin dfs</span></span><br><span class="line">            combine.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], combine, idx,rside);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c = a.<span class="built_in">combinationSum</span>(b, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rowV : c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;el : rowV)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打印二维vector</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVecofVec1</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowV : res) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; el : rowV) &#123;</span><br><span class="line">      cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort采用的是什么排序？</p><p><strong>sort函数的底层用到的是内省式排序以及插入排序</strong>,内省排序首先从快速排序开始,当递归深度超过一定深度(深度为排序元素数量的对数值)后转为堆排序</p><p>回溯算法不剪枝就是暴力枚举，也可以理解为枚举没办法的办法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://blog.luoxiaohei.co/2022/11/26/%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://blog.luoxiaohei.co/2022/11/26/%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2022-11-25T18:30:30.000Z</published>
    <updated>2022-11-26T02:48:54.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到log（n）就能想到二分查找，但是二分查找里面怎么找到第一个重复元素呢？</p><p>答案就是在二分查找中选择<strong>nums[mid] &gt;= target</strong>,不在==target时return，最后就能退到第一个target。</p><p>还有就是||运算符 是不会全部执行的。如果我们想要判断查到的元素是否为target时，<strong>nums[mid] == target</strong>。 但是我们的mid可能越界时。我们可以先判断是否越位之后再判断是否相等，比如 <strong>if(l == nums.size()||nums[l] != target)</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">search</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找要仔细判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-11-24T19:28:31.000Z</published>
    <updated>2022-11-25T08:11:48.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组 <strong>nums</strong> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 <strong>旋转</strong>，使数组变为 <strong>[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]</strong>（下标 <strong>从 0 开始</strong> 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><p>like this</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251152114.png" alt="img"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span>&#123;  <span class="comment">//二分查找升级版</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) <span class="comment">// 有=</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[mid])</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">search</span>(b,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：二分查找，快排之类的都是很重要的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;整数数组 &lt;strong&gt;nums&lt;/strong&gt; 按升序排列，数组中的值 互不相同 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="https://blog.luoxiaohei.co/2022/11/23/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://blog.luoxiaohei.co/2022/11/23/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-11-22T19:36:04.000Z</published>
    <updated>2022-11-25T03:08:56.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先会想到堆栈的符号匹配之类的算法，奈何不记得怎么写了。首先，我们试着用动态规划的思路来写，我们发现，给定一个动态规划的数组dp[]，dp中记录以每个符号结尾的最大有效数，可知以（结尾的为0，以）结尾的要分两种情况讨论即可。</p><p>1、（）型</p><p>这种情况只需要dp[i]=dp[i-2]+2即可</p><p>2、））型</p><p>这种情况需要判断一下</p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=（，则dp[i] = dp[i-1]+2</em></p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=），则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</em></p><p>这样我们也能发现，上面斜线部分有冗余部分，实则是：</p><p>如果dp[i-dp[i-1]-1]=（，则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</p><p><strong>最后就是注意数组不要越界</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span> , n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = ( i&gt;=<span class="number">2</span> ? dp[i<span class="number">-2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + ( (i-dp[i<span class="number">-1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i<span class="number">-1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="built_in">max</span>(length,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="堆实现符号匹配"><a href="#堆实现符号匹配" class="headerlink" title="堆实现符号匹配"></a>堆实现符号匹配</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>我记得是在编译原理这门课上，学习了编程实现加减乘除的算数表达式文法的正确性。找到实验代码，感叹之前学习的东西真的忘得太快啦。</p><p>如果想要快速捡起来，还是得做好收集工作啊！</p><p>展示：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251107751.png" alt="image-20221125110714653"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">                    a.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = <span class="built_in">max</span>(maxlen,i - a.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-STL-map"><a href="#C-STL-map" class="headerlink" title="C++ STL map"></a>C++ STL map</h2><p><strong>map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据**</strong>自动排序**的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><p><strong>map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</strong></p><p><strong>对于迭代器来说，</strong>可以修改实值，而不能修改key</p><p><strong>C++的标准库关联容器map是不允许有key</strong>相同的键值对存在的。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>map和vector差不多，map有自动排序的功能和定义key元素类型的特性</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给你一个只包含 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>算法作业：来回拉人</title>
    <link href="https://blog.luoxiaohei.co/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/"/>
    <id>https://blog.luoxiaohei.co/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/</id>
    <published>2022-11-15T23:43:34.000Z</published>
    <updated>2022-11-16T09:01:26.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>人和摩托最快达到目的地题目描述：有n个人和一辆摩托车，摩托车可坐2个人（包括驾驶人），他们要到离他们距离D的目的地，可以利用摩托车来回运人，每个人都会开摩托车，人的速度为v1，摩托车的速度为v2，求他们最快达到目的地的时间。</p><p>输入格式：每行4个整数(n，v1，v2，D)，整数之间有一个空格，速度单位是千米每小时，距离的单位是千米，输入直至n=0数据范围：1&lt;=n&lt;=1000000, 1&lt;=v1,v2&lt;=1000000, 1000&lt;=D&lt;=1000000</p><p>输出格式：每行一个结果，精确到秒（不到1秒的小数舍去），3个整数分别代表小时、分、秒，整数之间有一个空格，最后一行也有回车</p><p>输入样例：</p><p>1 2 4 21</p><p>2 1 7 20</p><p>0</p><p>输出样例：</p><p>5 15 0</p><p>2 51 25</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分法：车的速度比人快，那么多长的时间就是总路程/人的速度，利用二分法，找到一个合适的时间，使得在这个时间内，车和人相遇n-2次，如果大于n-2次那么这个时间长了，需要减小时间，反之增加时间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">&#123;</span><br><span class="line">    ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">        R = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到遇见次数和时间之间的等式：</p><p>n=（(v2<em>t-D)\</em>(v1+v2)*(D-v1*t))/(2*v2)</p><p>这个公式我没有推导出来，希望大佬可以交流交流。</p><h2 id="最后代码"><a href="#最后代码" class="headerlink" title="最后代码"></a>最后代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//更现代</span></span><br><span class="line"><span class="comment">// using long long = ll;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">ll n, k, D;</span><br><span class="line"><span class="comment">//check this  time can finish all the people</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v2 * t &lt; D)</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">    cnt = ((v2 * t - D) * (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(v1) + v2) * (D - v1 * t)) / (<span class="number">2</span>*v2) + <span class="number">2</span>;<span class="comment">//find out this time can cross how many people</span></span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; D;</span><br><span class="line"></span><br><span class="line">        D *= <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">        ll L = <span class="number">0</span>, R = D / v1;<span class="comment">//R :the people road time</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">                R = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出时间</span></span><br><span class="line">        cout &lt;&lt; L / <span class="number">3600</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">3600</span> / <span class="number">60</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">60</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;人和摩托最快达到目的地题目描述：有n个人和一辆摩托车，摩托车可坐2个人（包括驾驶人），他们要到离他们距离D的目的地，可以利用</summary>
      
    
    
    
    
    <category term="C++、算法" scheme="https://blog.luoxiaohei.co/tags/C-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hot 23</title>
    <link href="https://blog.luoxiaohei.co/2022/11/12/hot%2023/"/>
    <id>https://blog.luoxiaohei.co/2022/11/12/hot%2023/</id>
    <published>2022-11-11T20:01:53.000Z</published>
    <updated>2022-11-12T04:08:26.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路巨简单，难得一次都不用调试！！!循环直接搞定，什么分治大法我不懂！</p><p>用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; qu;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;ListNode&gt;&amp; lists)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (ListNode  list : lists) <span class="comment">//只是加入链表头节点</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(list == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qu.<span class="built_in">push</span>(list);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ListNode head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       ListNode cur = head;</span><br><span class="line">       <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">            ListNode nex = qu.<span class="built_in">pop</span>();</span><br><span class="line">            cur.next = nex;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//链表没到尾，队列加入尾随节点</span></span><br><span class="line">            <span class="keyword">if</span>(nex-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(nex.next);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里面涉及优先队列的思想，第一次用到优先队列，很多都不清楚。还有就是判断指针是否指向空时的判断，比如qu.push(list);//list为nullptr不能进行插入操作。</p><p>priority_queue用法详情：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">C++ priority_QUEUE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;23. 合并K个升序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-k-sorted</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
