<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骆小黑</title>
  
  <subtitle>阿妮亚</subtitle>
  <link href="https://blog.luoxiaohei.co/atom.xml" rel="self"/>
  
  <link href="https://blog.luoxiaohei.co/"/>
  <updated>2022-12-18T08:02:46.818Z</updated>
  <id>https://blog.luoxiaohei.co/</id>
  
  <author>
    <name>骆小黑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://blog.luoxiaohei.co/2022/12/18/1%E3%80%81%E5%AE%89%E8%A3%85GIT/"/>
    <id>https://blog.luoxiaohei.co/2022/12/18/1%E3%80%81%E5%AE%89%E8%A3%85GIT/</id>
    <published>2022-12-18T07:31:39.763Z</published>
    <updated>2022-12-18T08:02:46.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><p>1、安装GIT</p><p><a href="https://blog.csdn.net/adminsir0/article/details/126355313">(3条消息) git安装教程</a>（一直next就行）</p><p>2、注册远程仓库账号</p><p>打开<a href="https://github.com/">GitHub</a>，注册自己账号</p><p>不翻墙的话，注册<a href="https://gitee.com/">Gitee</a>（这个文档展示gitee）</p><p>3、本地创建任意文件夹，鼠标右键选择git bush</p><p>4、配置用户，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>5、生成SSH密钥        </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure><p>进入C:\Users\Administrator.ssh目录下，查看生成的SSH密钥，</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181525633.jpeg" alt="img" style="zoom:50%;" /></p><p>复制id_ras.pub里面的字符串，在gitee设置中的SSH公钥中添加密钥。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181527256.png" alt="image-20221218152744139"></p><p>6、创建一个文件，在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>7、命令行输入：git init </p><p>8、命令行输入：git add .</p><p>9、命令行输入：git commit -m “123”</p><p>10、命令行输入：git remote add origin <strong>url</strong>  |  url选择你的远程仓库，比如<strong>gitee</strong>创建完仓库后，会有这个地址，我们选择SSH链接就行。</p><p>例如：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212181520074.png" alt="image-20221218152045988"></p><p>11、命令行输入：git push -u origin “master”</p><p>显示成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作手册&quot;&gt;&lt;a href=&quot;#操作手册&quot; class=&quot;headerlink&quot; title=&quot;操作手册&quot;&gt;&lt;/a&gt;操作手册&lt;/h2&gt;&lt;p&gt;1、安装GIT&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/adminsir0/articl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="https://blog.luoxiaohei.co/2022/12/16/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/12/16/%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2022-12-16T07:04:14.000Z</published>
    <updated>2022-12-16T15:09:48.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212162305580.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这就是一道简单的动态规划问题，为什么我最开始的时候没有想到呢？最开始想到的是遍历每一种情况，求其最小值但是遍历不了每一种情况。因为没有经过系统的练习。</p><p>动态规划问题都需要有个中间数组dp。通常用于解决最大最小问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();<span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码还是需要经过系统的学习才行，下次学习的时候尽量把一个专题的东西学完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-path-sum/&quot;&gt;64. </summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同路径</title>
    <link href="https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>https://blog.luoxiaohei.co/2022/12/12/%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2022-12-11T18:27:22.000Z</published>
    <updated>2022-12-16T13:54:50.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212121030018.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>这是一个高中的排列组合的一个数学题。</p><script type="math/tex; mode=display">C_{m+n-2}^{m-1}=\left(\begin{array}{c}m+n-2 \\m-1\end{array}\right)=\frac{(m+n-2)(m+n-3) \cdots n}{(m-1) !}=\frac{(m+n-2) !}{(m-1) !(n-1) !}</script><p>用算法实现这个等式就可以了。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>dfs递归暴力求解，具体实现还不熟练，直接贴代码，（超时）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h5><p>动态规划，每个答案都是前面两个答案的综总和。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划和dfs需要系统的学习，不然真的太模糊了。。。</p><p>就比如爬梯子这道题。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>动态规划方程就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2];</span><br></pre></td></tr></table></figure><p>需要注意的是：这种动态规划都可以用递归来做，但是递归的空间复杂度太高了， 通常是会超时的。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. 不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/unique-paths/&quot;&gt;62. 不同路径&lt;/a</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>56. 合并区间</title>
    <link href="https://blog.luoxiaohei.co/2022/12/11/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://blog.luoxiaohei.co/2022/12/11/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2022-12-10T19:34:20.000Z</published>
    <updated>2022-12-11T04:17:03.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开始我是想直接遍历，依次比较两个数组是否合并，能合并就push到目标二维向量res中，这样操作就导致最多只有两个数组能合并，忽略了三个及以上的数组合并的情况，所以最好的做法就是先把第一个数组push到res中，再逐个遍历对比intervals中的数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//为什么不能放在pubilc中？</span></span><br><span class="line"><span class="comment">// 重载的排序函数不能放在 public 下，这是因为重载的排序函数本质上是一个类内部的函数，它的主要作用是为类的对象提供排序功能。而 public 下的函数是可以在类的内部和外部访问的，因此不能将重载的排序函数放在 public 下。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),compare1);</span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; intervals.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(res[j][<span class="number">0</span>]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(res[j][<span class="number">1</span>],intervals[i][<span class="number">1</span>]));</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>通过chatGPT它帮我优化了一下代码。</p><p>使用了拉姆达表达式，更熟练的使用向量vector，很精彩</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">// Use a deque to store the merged intervals</span></span><br><span class="line">        deque&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort the intervals by their start time</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the first interval to the deque</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate through the remaining intervals</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// If the end time of the last interval in the deque is greater than</span></span><br><span class="line">            <span class="comment">// or equal to the start time of the current interval, merge them</span></span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp = &#123; res.<span class="built_in">back</span>()[<span class="number">0</span>], <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]) &#125;;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise, just add the current interval to the deque</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the merged intervals as a vector</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    b = a.<span class="built_in">merge</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : i)</span><br><span class="line">            cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码前，先想好思路，不然改代码会改得头大，也会阻塞我们的思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;56-合并区间&quot;&gt;&lt;a href=&quot;#56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;56. 合并区间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-intervals/&quot;&gt;56. 合并区间</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/10/%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2022-12-09T22:32:45.000Z</published>
    <updated>2022-12-10T06:41:12.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>目前想到两种方法，一种是贪心，就是一直走下去，看我最远能走多远，如果最远的距离大于数组长度，则必可达。</p><p>还有一种是找规律，我们可以发现，如果数组非0，那么必可达终点，所以我们只需要查看0的元素是否可以跳过去。逆向遍历，遇到0，再逆向遍历看看有没有元素能跳过这个0，如果不能则不可达，如果能继续逆向遍历到达终点，那么就是可达。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">// 判断我从开始位置能到的最远距离与数组的长度做对比，最远位置比数组长度长，则能到达。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlength = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=maxlength)</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength , i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找规律</span></span><br><span class="line"><span class="comment">// 发现如果数组元素都大于0，则必可达。</span></span><br><span class="line"><span class="comment">// 只需要判断元素中=0的元素之前是否有元素可以跳过这个0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+nums[j] &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和动态规划回溯（dfs）是重点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;55-跳跃游戏&quot;&gt;&lt;a href=&quot;#55-跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;55. 跳跃游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/jump-game/&quot;&gt;55. 跳跃游戏&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="C++、算法" scheme="https://blog.luoxiaohei.co/tags/C-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git工作流</title>
    <link href="https://blog.luoxiaohei.co/2022/12/05/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://blog.luoxiaohei.co/2022/12/05/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2022-12-05T08:40:50.000Z</published>
    <updated>2022-12-10T07:18:52.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git工作流："><a href="#git工作流：" class="headerlink" title="git工作流："></a>git工作流：</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041100978.png" alt="image-20221204110021821"></p><p>出现的问题：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041409760.png" alt="image-20221204140937710"></p><p>遇到这种情况说明，是因为虽然使用的是git push命令，但是本质还是http。（github在21年为了安全，取消账号密码身份验证（http就需要账号密码登录验证），而使用令牌(Token)的身份验证）</p><p>我们来验证是否可以连接github显示没有问题。发现连接是没有问题的。</p><p>这句话其实一直存在，它只是想告诉你，github 不允许 shell 交互。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041401785.png" alt="image-20221204140109692"></p><p>原因&amp;解决<br>虽然是用 git 命令push，但本质上仍然是 https，所以不允许提交。<br>使用 git remote -v 查看现在的远程 url 地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">originhttps://github.com/jack8luo/-.git (fetch)</span><br><span class="line">originhttps://github.com/jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>使用下面的改 url 链接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:jack8luo/-.git   </span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v                                                 </span><br><span class="line">origingit@github.com:jack8luo/-.git (fetch)</span><br><span class="line">origingit@github.com:jack8luo/-.git (push)</span><br></pre></td></tr></table></figure><p>已经改为 ssh 了。现在可以正常 push 了。</p><p>测试：github不与shell交互，这个shell指的就是我们的命令行窗口了。发现使用git的工具bash也出现http连接出错。</p><p>或许也可以尝试重新配置ssh密钥连接一下试试。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212041434804.png" alt="img"></p><p>windows下创建文件使用echo ” text “ &gt; 1.txt</p><p>linux使用touch 1.txt</p><p>在windows下使用touch需安装touch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install touch-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遇见：</p><h2 id="spwan-failed问题"><a href="#spwan-failed问题" class="headerlink" title="spwan failed问题"></a>spwan failed问题</h2><h3 id="可以考虑连接手机热点解决，也可以修改自己的端口：443"><a href="#可以考虑连接手机热点解决，也可以修改自己的端口：443" class="headerlink" title="可以考虑连接手机热点解决，也可以修改自己的端口：443."></a>可以考虑连接手机热点解决，也可以修改自己的端口：443.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Push failed</span><br><span class="line">Kex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22</span><br><span class="line">Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>一般情况下是以上错误都是因为挂着VPN导致端口冲突</p><p>目前遇到两类情况，解决办法如下。</p><p>1 网络本身无vpn，使用ShadowsocksR等工具科学上网<br>退出ShadowsocksR即可<br>缺点：访问github会变慢，毕竟把vpn关掉了。如果开vpn本身就是为了更快速的访问github，那这样的操作就很费劲，每次和远程仓库交互都要关掉vpn，搞完再打开，推荐2.1。<br>2 网络本身挂载vpn，如openwrt上安装了ShadowsocksR<br>解决办法有两种（推荐第一种）<br>2.1 修改项目目录中隐藏文件夹 .git 内的 config 文件<br>将 Project/.git/config 文件中ssh格式的url，修改为github仓库中https格式的url。如：</p><p>url = <a href="https://github.com/username/SpringBootWebTest.git">https://github.com/username/SpringBootWebTest.git</a></p><p>因为开着vpn，代理端口走22；同时git的ssh一般也使用22端口，这样造成冲突；而git的https一般使用443端口，不会产生冲突。</p><p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用https可以很好地绕开安全限制使用git；但是对于ssh来说，企业防火墙很可能没打开22端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git工作流：&quot;&gt;&lt;a href=&quot;#git工作流：&quot; class=&quot;headerlink&quot; title=&quot;git工作流：&quot;&gt;&lt;/a&gt;git工作流：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8l</summary>
      
    
    
    
    
    <category term="Git" scheme="https://blog.luoxiaohei.co/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://blog.luoxiaohei.co/2022/12/01/%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-12-01T04:25:51.000Z</published>
    <updated>2022-12-08T04:43:54.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027984.png" alt="image-20221201202701906"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202212012027198.png" alt="image-20221201202722150"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>顺时针旋转90°==先水平旋转，再主对角线旋转</p><p>这就类似于把一步旋转操作拆分成了两步操作，从而化简了算法的复杂性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="type">int</span> j = matrix.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][k],matrix[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>就是简单一数学题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/rotate-image/&quot;&gt;48. 旋转图像&lt;/a</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://blog.luoxiaohei.co/2022/11/30/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://blog.luoxiaohei.co/2022/11/30/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-11-29T19:16:56.000Z</published>
    <updated>2022-11-30T03:26:36.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>全排列的问题做过很多次，但是这次还是没写出来，在这里总结一下。</p><p>全排列就是深度搜索dfs，也叫做回溯算法，相同的题目还有<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>。回溯深搜都是暴力算法，不同于遍历，深搜可以更有效地暴力。</p>              </div>            </details><p>在这里介绍一下c++的next_permutation(nums.begin(), nums.end())函数。这个函数返回的是bool，在函数执行中会将nums的下一次排列换成nums。</p><p>比如这道题的解法一就用到了这个函数</p><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似的题可以看<a href="https://blog.luoxiaohei.co/2022/10/17/31. 下一个排列/">力扣hot100—031 下一个排列 | 骆小黑 (luoxiaohei.co)</a></p><hr><h2 id="暴力回溯"><a href="#暴力回溯" class="headerlink" title="暴力回溯"></a>暴力回溯</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;bool&gt; tag;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tag.resize(n, false);</span><br><span class="line">        dfs(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (temp.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!tag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                tag[i] = true;</span><br><span class="line">                dfs(nums);</span><br><span class="line">                temp.pop_back();//递归完一个结果123之后清理temp和tag</span><br><span class="line">                tag[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相似题可以看<a href="https://blog.luoxiaohei.co/2022/11/27/ 组合总和/">组合总和 | 骆小黑 (luoxiaohei.co)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加油！未来可期！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全排列&quot; class=&quot;headerlink&quot; title=&quot;46. 全排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/&quot;&gt;46. 全排列&lt;/a&gt;&lt;/h</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>二分查找之找到最左最右元素</title>
    <link href="https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.luoxiaohei.co/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%89%BE%E5%88%B0%E6%9C%80%E5%B7%A6%E6%9C%80%E5%8F%B3%E5%85%83%E7%B4%A0/</id>
    <published>2022-11-27T18:44:50.000Z</published>
    <updated>2022-11-28T03:02:02.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>​        最近做了很多二分查找的算法题，这里来整理一下学到了什么。</p><p>​        做到有关二分查找的题目</p><p>​    -     <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>​    -     <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>​    -     <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>              </div>            </details><p>针对34题总结了一下二分查找的一些细节。</p><p>普通的二分查找很简单。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[mid] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; index)</span><br><span class="line">   index = mid;</span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; val)</span><br><span class="line">right = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &lt; val)</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到最左边元素"><a href="#找到最左边元素" class="headerlink" title="找到最左边元素"></a>找到最左边元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的第一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="找到最右边元素"><a href="#找到最右边元素" class="headerlink" title="找到最右边元素"></a>找到最右边元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到=target的最后一个数</span></span><br><span class="line">    <span class="type">int</span> lside;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) <span class="comment">// 因为l已经累加了，如果l等于r的情况不能进行判断，那么l=r-1 且 两个数都是target时，mid只会=l，lside也是，我们要的结果是右边的，即r</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;  <span class="comment">// 找到大于第一个大于target的数减1 即可</span></span><br><span class="line">            lside = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>好啦，我要去打怪兽了，掰掰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找总结&quot;&gt;&lt;a href=&quot;#二分查找总结&quot; class=&quot;headerlink&quot; title=&quot;二分查找总结&quot;&gt;&lt;/a&gt;二分查找总结&lt;/h2&gt;&lt;details pink&gt;&lt;summary&gt; 哔哔 &lt;/summary&gt;
              &lt;div </summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>组合总和</title>
    <link href="https://blog.luoxiaohei.co/2022/11/27/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.luoxiaohei.co/2022/11/27/%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2022-11-27T05:18:48.000Z</published>
    <updated>2022-11-27T13:25:22.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p>candidates 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这个题目和背包问题是一样的，采用的dfs的回溯算法。有张图就能很好理解了。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211272122380.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = candidates.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rside;</span><br><span class="line">        <span class="comment">// 先二分查找小于等于target值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                rside = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidates[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            rside = r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, <span class="number">0</span>, rside);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;combine, <span class="type">int</span> idx,<span class="type">int</span> rside)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; rside)  <span class="comment">//剪枝，当idx&gt;target时，就不用继续执行了。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, combine, idx + <span class="number">1</span>,rside);</span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) <span class="comment">//剪枝 target是传参量</span></span><br><span class="line">        &#123; <span class="comment">// stop untifin dfs</span></span><br><span class="line">            combine.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], combine, idx,rside);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c = a.<span class="built_in">combinationSum</span>(b, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rowV : c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;el : rowV)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打印二维vector</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVecofVec1</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rowV : res) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; el : rowV) &#123;</span><br><span class="line">      cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort采用的是什么排序？</p><p><strong>sort函数的底层用到的是内省式排序以及插入排序</strong>,内省排序首先从快速排序开始,当递归深度超过一定深度(深度为排序元素数量的对数值)后转为堆排序</p><p>回溯算法不剪枝就是暴力枚举，也可以理解为枚举没办法的办法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a href=&quot;#39-组合总和&quot; class=&quot;headerlink&quot; title=&quot;39. 组合总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://blog.luoxiaohei.co/2022/11/26/%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://blog.luoxiaohei.co/2022/11/26/%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2022-11-25T18:30:30.000Z</published>
    <updated>2022-11-26T02:48:54.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到log（n）就能想到二分查找，但是二分查找里面怎么找到第一个重复元素呢？</p><p>答案就是在二分查找中选择<strong>nums[mid] &gt;= target</strong>,不在==target时return，最后就能退到第一个target。</p><p>还有就是||运算符 是不会全部执行的。如果我们想要判断查到的元素是否为target时，<strong>nums[mid] == target</strong>。 但是我们的mid可能越界时。我们可以先判断是否越位之后再判断是否相等，比如 <strong>if(l == nums.size()||nums[l] != target)</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">search</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.<span class="built_in">size</span>()||nums[l] != target) <span class="comment">// ||运算符先检查前面，后检查后面</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找&gt;=target的第一个</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//，默认的除法是整数除法向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target) <span class="comment">//find first target</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    nums = a.<span class="built_in">searchRange</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;nums[<span class="number">0</span>]&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找要仔细判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.luoxiaohei.co/2022/11/25/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-11-24T19:28:31.000Z</published>
    <updated>2022-11-25T08:11:48.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组 <strong>nums</strong> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 <strong>旋转</strong>，使数组变为 <strong>[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]</strong>（下标 <strong>从 0 开始</strong> 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><p>like this</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251152114.png" alt="img"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span>&#123;  <span class="comment">//二分查找升级版</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) <span class="comment">// 有=</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[mid])</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">search</span>(b,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：二分查找，快排之类的都是很重要的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;整数数组 &lt;strong&gt;nums&lt;/strong&gt; 按升序排列，数组中的值 互不相同 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="https://blog.luoxiaohei.co/2022/11/23/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://blog.luoxiaohei.co/2022/11/23/%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-11-22T19:36:04.000Z</published>
    <updated>2022-11-25T03:08:56.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先会想到堆栈的符号匹配之类的算法，奈何不记得怎么写了。首先，我们试着用动态规划的思路来写，我们发现，给定一个动态规划的数组dp[]，dp中记录以每个符号结尾的最大有效数，可知以（结尾的为0，以）结尾的要分两种情况讨论即可。</p><p>1、（）型</p><p>这种情况只需要dp[i]=dp[i-2]+2即可</p><p>2、））型</p><p>这种情况需要判断一下</p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=（，则dp[i] = dp[i-1]+2</em></p><p><em>如果dp[i-dp[i-1]-1]=（且dp[i-dp[i-1]-2=），则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</em></p><p>这样我们也能发现，上面斜线部分有冗余部分，实则是：</p><p>如果dp[i-dp[i-1]-1]=（，则dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2。</p><p><strong>最后就是注意数组不要越界</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span> , n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = ( i&gt;=<span class="number">2</span> ? dp[i<span class="number">-2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span>&amp;&amp;i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + ( (i-dp[i<span class="number">-1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i<span class="number">-1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="built_in">max</span>(length,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="堆实现符号匹配"><a href="#堆实现符号匹配" class="headerlink" title="堆实现符号匹配"></a>堆实现符号匹配</h2><details pink><summary> 哔哔 </summary>              <div class='content'>              <p>我记得是在编译原理这门课上，学习了编程实现加减乘除的算数表达式文法的正确性。找到实验代码，感叹之前学习的东西真的忘得太快啦。</p><p>如果想要快速捡起来，还是得做好收集工作啊！</p><p>展示：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211251107751.png" alt="image-20221125110714653"></p>              </div>            </details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">                    a.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = <span class="built_in">max</span>(maxlen,i - a.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-STL-map"><a href="#C-STL-map" class="headerlink" title="C++ STL map"></a>C++ STL map</h2><p><strong>map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据**</strong>自动排序**的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><p><strong>map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</strong></p><p><strong>对于迭代器来说，</strong>可以修改实值，而不能修改key</p><p><strong>C++的标准库关联容器map是不允许有key</strong>相同的键值对存在的。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>map和vector差不多，map有自动排序的功能和定义key元素类型的特性</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给你一个只包含 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code</summary>
      
    
    
    
    
    <category term="算法、c++" scheme="https://blog.luoxiaohei.co/tags/%E7%AE%97%E6%B3%95%E3%80%81c/"/>
    
  </entry>
  
  <entry>
    <title>算法作业：来回拉人</title>
    <link href="https://blog.luoxiaohei.co/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/"/>
    <id>https://blog.luoxiaohei.co/2022/11/16/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%9D%A5%E5%9B%9E%E6%8B%89%E4%BA%BA/</id>
    <published>2022-11-15T23:43:34.000Z</published>
    <updated>2022-11-16T09:01:26.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>人和摩托最快达到目的地题目描述：有n个人和一辆摩托车，摩托车可坐2个人（包括驾驶人），他们要到离他们距离D的目的地，可以利用摩托车来回运人，每个人都会开摩托车，人的速度为v1，摩托车的速度为v2，求他们最快达到目的地的时间。</p><p>输入格式：每行4个整数(n，v1，v2，D)，整数之间有一个空格，速度单位是千米每小时，距离的单位是千米，输入直至n=0数据范围：1&lt;=n&lt;=1000000, 1&lt;=v1,v2&lt;=1000000, 1000&lt;=D&lt;=1000000</p><p>输出格式：每行一个结果，精确到秒（不到1秒的小数舍去），3个整数分别代表小时、分、秒，整数之间有一个空格，最后一行也有回车</p><p>输入样例：</p><p>1 2 4 21</p><p>2 1 7 20</p><p>0</p><p>输出样例：</p><p>5 15 0</p><p>2 51 25</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分法：车的速度比人快，那么多长的时间就是总路程/人的速度，利用二分法，找到一个合适的时间，使得在这个时间内，车和人相遇n-2次，如果大于n-2次那么这个时间长了，需要减小时间，反之增加时间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">&#123;</span><br><span class="line">    ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">        R = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到遇见次数和时间之间的等式：</p><p>n=（(v2<em>t-D)\</em>(v1+v2)*(D-v1*t))/(2*v2)</p><p>这个公式我没有推导出来，希望大佬可以交流交流。</p><h2 id="最后代码"><a href="#最后代码" class="headerlink" title="最后代码"></a>最后代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//更现代</span></span><br><span class="line"><span class="comment">// using long long = ll;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">ll n, k, D;</span><br><span class="line"><span class="comment">//check this  time can finish all the people</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v2 * t &lt; D)</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">    cnt = ((v2 * t - D) * (<span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(v1) + v2) * (D - v1 * t)) / (<span class="number">2</span>*v2) + <span class="number">2</span>;<span class="comment">//find out this time can cross how many people</span></span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; D;</span><br><span class="line"></span><br><span class="line">        D *= <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">        ll L = <span class="number">0</span>, R = D / v1;<span class="comment">//R :the people road time</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) <span class="comment">//until L==R//tow part find the really time</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid + <span class="number">1</span>))</span><br><span class="line">                R = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出时间</span></span><br><span class="line">        cout &lt;&lt; L / <span class="number">3600</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">3600</span> / <span class="number">60</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L % <span class="number">60</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;人和摩托最快达到目的地题目描述：有n个人和一辆摩托车，摩托车可坐2个人（包括驾驶人），他们要到离他们距离D的目的地，可以利用</summary>
      
    
    
    
    
    <category term="C++、算法" scheme="https://blog.luoxiaohei.co/tags/C-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hot 23</title>
    <link href="https://blog.luoxiaohei.co/2022/11/12/hot%2023/"/>
    <id>https://blog.luoxiaohei.co/2022/11/12/hot%2023/</id>
    <published>2022-11-11T20:01:53.000Z</published>
    <updated>2022-11-12T04:08:26.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路巨简单，难得一次都不用调试！！!循环直接搞定，什么分治大法我不懂！</p><p>用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; qu;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;ListNode&gt;&amp; lists)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (ListNode  list : lists) <span class="comment">//只是加入链表头节点</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(list == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qu.<span class="built_in">push</span>(list);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ListNode head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       ListNode cur = head;</span><br><span class="line">       <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">            ListNode nex = qu.<span class="built_in">pop</span>();</span><br><span class="line">            cur.next = nex;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//链表没到尾，队列加入尾随节点</span></span><br><span class="line">            <span class="keyword">if</span>(nex-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(nex.next);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里面涉及优先队列的思想，第一次用到优先队列，很多都不清楚。还有就是判断指针是否指向空时的判断，比如qu.push(list);//list为nullptr不能进行插入操作。</p><p>priority_queue用法详情：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">C++ priority_QUEUE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;23. 合并K个升序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-k-sorted</summary>
      
    
    
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>生活小妙招</title>
    <link href="https://blog.luoxiaohei.co/2022/11/11/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    <id>https://blog.luoxiaohei.co/2022/11/11/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%A6%99%E6%8B%9B/</id>
    <published>2022-11-11T05:05:59.000Z</published>
    <updated>2022-11-28T06:12:03.474Z</updated>
    
    <content type="html"><![CDATA[<p>windows:</p><p>在终端输入一下命令即可批量重命名文件后缀。</p><p>ren :rename。<em> 所有无后缀文件修改为</em>.jpg</p><p>ren <em> </em>.jpg</p><hr><p>2、如果英文好，不用csdn，用stackoverflow</p><p>3、自定义短语，减轻我们平时打字负担</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281100320.png" alt="image-20221128110048237"></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281101526.png" alt="image-20221128110115474"></p><p>4、github commit是提交到本地仓库</p><p>commit &amp; push是提交本地&amp;并推到本地</p><p>commit &amp; sync是提交本地&amp; 同步 —- 同步是 什么意思？</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211281201119.png" alt="image-20221128120102985"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;windows:&lt;/p&gt;
&lt;p&gt;在终端输入一下命令即可批量重命名文件后缀。&lt;/p&gt;
&lt;p&gt;ren :rename。&lt;em&gt; 所有无后缀文件修改为&lt;/em&gt;.jpg&lt;/p&gt;
&lt;p&gt;ren &lt;em&gt; &lt;/em&gt;.jpg&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2、如果英文好，不用csdn，用s</summary>
      
    
    
    
    
    <category term="生活" scheme="https://blog.luoxiaohei.co/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>terminal 美化历程</title>
    <link href="https://blog.luoxiaohei.co/2022/11/11/terminal%20%E7%BE%8E%E5%8C%96%E5%8E%86%E7%A8%8B/"/>
    <id>https://blog.luoxiaohei.co/2022/11/11/terminal%20%E7%BE%8E%E5%8C%96%E5%8E%86%E7%A8%8B/</id>
    <published>2022-11-10T18:56:12.000Z</published>
    <updated>2022-11-11T06:16:41.331Z</updated>
    
    <content type="html"><![CDATA[<details green><summary> 前言 </summary>              <div class='content'>              <p>今天呢，看见我的好室友坤坤，弄了一晚上的终端美化，看上去颇有一点意思，所以呢，我就模仿了一下，不算抄袭哈。哈哈哈。<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111135114.gif" alt=""></p><p>所以呢，今天我就来记录一下美化的步骤。</p><p>因为很多都不记得了。所以这算不上一篇合格的教程辣。<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111137459.gif" alt=""></p>              </div>            </details><p>首先呢，我们在微软software store下载的terminal。是一个黑不溜秋的黑框，很影响我们发现美的眼睛。</p><p>对比一下我们就能看出来美化后的terminal对我们眼睛非常友好了：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111416165.png" alt=""></th><th><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111112994.png" style="zoom:50%;" /></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>在software store下载terminal之后，就是安装我们的主题工具了——oh my posh，里面有很多主题：<a href="https://ohmyposh.dev/docs/themes">Themes | Oh My Posh</a></p><p>当然，官方文档都有了，这教程也是翻译翻译。官方文档：<a href="https://ohmyposh.dev/docs/installation/windows">Windows | Oh My Posh</a></p><h2 id="安装oh-my-posh"><a href="#安装oh-my-posh" class="headerlink" title="安装oh my posh"></a>安装oh my posh</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winget install JanDeDobbeleer.OhMyPosh <span class="literal">-s</span> winget</span><br></pre></td></tr></table></figure><details green><summary> 可能出现的问题 </summary>              <div class='content'>              <ul><li>如果提示无法识别winget，说明电脑系统中没有安装winget，先要去微软商店中搜索winget后下载<a href="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109110230464.png"><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202211111132478.png" alt=""></a>即可</li><li>如果出现冲突无法下载 <code>oh-my-posh</code> ，安装提示给的oh-my-posh的ID使用命令 <code>winget install --id xxxxx</code> 下载</li><li>找到配置文件，powershell中输入 <code>$Profile</code> 可以查看windows的配置文件，利用 <code>code $Profile</code> 打开文件，并且添加如下的一段代码</li></ul>              </div>            </details><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">BASH</span></span><br><span class="line"><span class="attr">oh-my-posh</span> <span class="string">init pwsh --config $env:POSH_THEMES_PATH\montys.omp.json | Invoke-Expression</span></span><br><span class="line"><span class="attr">cls</span></span><br><span class="line"><span class="comment"># Shows navigable menu of all options when hitting Tab</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key Tab -Function MenuComplete</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Autocompletion for arrow keys</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key UpArrow -Function HistorySearchBackward</span></span><br><span class="line"><span class="attr">Set-PSReadlineKeyHandler</span> <span class="string">-Key DownArrow -Function HistorySearchForward</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># auto suggestions</span></span><br><span class="line"><span class="attr">Import-Module</span> <span class="string">PSReadLine</span></span><br><span class="line"><span class="attr">Set-PSReadLineOption</span> <span class="string">-PredictionSource History</span></span><br></pre></td></tr></table></figure><p>第一行为主题的设置，其中 <code>montys.omp.json</code>为主题配置文件，可以修改（可以通过上面的那个oh-my-posh的路径查看所有主题）</p><p>后面的几行都是针对于powershell的命令行提示提示补全的功能</p><blockquote><p>遇到的问题：</p><ul><li><code>$Profile</code>目录不存在，按照提示的路径新建即可，系统也会提示你新建这个文件</li><li>主题的图标出现乱码，使用Nerd字体，去网上下载Nerd字体，这里推荐 JetBrainsMono Nerd Font Mono 字体<strong>（一定要注意，设置字体时，一定要将配置文件中的list级下的所有局部配置的字体删掉，否则字体无法生效）</strong></li></ul></blockquote><p>最后附上：<strong><a href="https://mirclea.github.io/2022/11/09/windows-config/[Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher](https://www.nerdfonts.com/font-downloads">Nerd字体下载网站</a></strong></p><details green><summary> 结语 </summary>              <div class='content'>              <p>最后呢，最近想学习linux，但是不知道使用虚拟机学习还是服务器，亦或是双系统。最后我选择的是windows下的一个子系统ubuntu。如果有缘再更。</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;details green&gt;&lt;summary&gt; 前言 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;p&gt;今天呢，看见我的好室友坤坤，弄了一晚上的终端美化，看上去颇有一点意思，所以呢，我就模仿了一下，不</summary>
      
    
    
    
    
    <category term="terminal" scheme="https://blog.luoxiaohei.co/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>算法课程</title>
    <link href="https://blog.luoxiaohei.co/2022/11/06/%E7%A9%BF%E8%BF%87%E5%87%A0%E4%B8%AA%E7%82%B9%E7%9A%84%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1/"/>
    <id>https://blog.luoxiaohei.co/2022/11/06/%E7%A9%BF%E8%BF%87%E5%87%A0%E4%B8%AA%E7%82%B9%E7%9A%84%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1/</id>
    <published>2022-11-06T05:53:55.666Z</published>
    <updated>2022-11-11T06:16:48.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="穿过几个点的线段统计"><a href="#穿过几个点的线段统计" class="headerlink" title="穿过几个点的线段统计"></a>穿过几个点的线段统计</h2><p>穿过几个点的线段统计</p><p>题目描述：平面上有N个点（N&lt;1600），有的线段会穿过多个点，请依据穿过点的个数，对线段进行统计。 </p><p>输入：每十个点一行，最后一行可能不足十个点；每行有20个整数（最后一行，可能不足），依次为第一个点的x坐标和y坐标，第二个点的x坐标和y坐标，，，等等。点的个数依据数据决定。</p><p> 输出：依据穿过点的数量升序输出：每行两个整数，点的数量k和正好穿过k个点的线段数量，最后一行也有回车。 </p><p>输入样例1：0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2</p><p> 输出样例2：</p><p>2 12</p><p>3 8 </p><p>输入样例2：</p><p>0 0 0 1 0 2 0 3 1 0 1 1 1 2 1 3 2 0 2 1</p><p>2 2 2 3 3 0 3 1 3 2 3 3 </p><p>输出样例2：</p><p>2 48</p><p>3 4</p><p>4 10</p><h2 id="思路：有一道题是求最长的线段长度，暴力即可解决，原题链接："><a href="#思路：有一道题是求最长的线段长度，暴力即可解决，原题链接：" class="headerlink" title="思路：有一道题是求最长的线段长度，暴力即可解决，原题链接："></a>思路：有一道题是求最长的线段长度，暴力即可解决，原题链接：</h2><p><a href="https://leetcode.cn/problems/max-points-on-a-line/solution/c-liang-chong-fang-fa-by-heroding-9gso/">C++ 两种方法！ - 直线上最多的点数 - 力扣（LeetCode）</a></p><p>有两种方法，一种3次方，一种二次方。</p><p>二次方方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;<span class="type">int</span> b[<span class="number">3600</span>][<span class="number">1000</span>];</span><br><span class="line">map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) b *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">1</span>; --i) c *= i;</span><br><span class="line">    <span class="keyword">return</span> a/(b*c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxPoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 点的数量不够</span></span><br><span class="line">    <span class="comment">// if(len &lt; 3) &#123;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="type">int</span> maxNum = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每两个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> dx = b[i][<span class="number">0</span>] - b[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> dy = b[i][<span class="number">1</span>] - b[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">double</span> gradient;</span><br><span class="line">                <span class="keyword">if</span>(dy==<span class="number">0</span>) </span><br><span class="line">                    gradient = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dx == <span class="number">0</span>)</span><br><span class="line">                    gradient = <span class="number">99999</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                     gradient = dy * <span class="number">1.0</span> / dx;</span><br><span class="line">                <span class="keyword">if</span>(count.<span class="built_in">count</span>(gradient)) &#123;  <span class="comment">// 经过i个点且斜率相同</span></span><br><span class="line">                    count[gradient] ++;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count[gradient] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = count.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            a[iter-&gt;second]++;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = a.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter != a.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            a[iter-&gt;first] = iter-&gt;second / iter-&gt;first;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;b[len][<span class="number">0</span>]&gt;&gt;b[len][<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">maxPoints</span>();</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">    iter = a.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != a.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details red><summary> 哔哔 </summary>              <div class='content'>              <p>开始用暴力解法，一直出现timeout错误，借用map达到了O（n^2）.</p>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;穿过几个点的线段统计&quot;&gt;&lt;a href=&quot;#穿过几个点的线段统计&quot; class=&quot;headerlink&quot; title=&quot;穿过几个点的线段统计&quot;&gt;&lt;/a&gt;穿过几个点的线段统计&lt;/h2&gt;&lt;p&gt;穿过几个点的线段统计&lt;/p&gt;
&lt;p&gt;题目描述：平面上有N个点（N&amp;lt;16</summary>
      
    
    
    
    <category term="算法题" scheme="https://blog.luoxiaohei.co/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>QT_TCP通信</title>
    <link href="https://blog.luoxiaohei.co/2022/10/27/2022-10-27-QT_TCP%E9%80%9A%E4%BF%A1/"/>
    <id>https://blog.luoxiaohei.co/2022/10/27/2022-10-27-QT_TCP%E9%80%9A%E4%BF%A1/</id>
    <published>2022-10-27T10:30:19.000Z</published>
    <updated>2022-10-27T05:36:39.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT-TCP通信过程"><a href="#QT-TCP通信过程" class="headerlink" title="QT_TCP通信过程"></a>QT_TCP通信过程</h1><p>之前我们在计网中，也就是这篇文章：</p><p>介绍了TCP套接字编程，客户端可以输入小写字符给服务器转成大写字符再送回。</p><p>今天，学习了一个QT的TCP通信的例子，关于QT-network方面的知识，记录一下。</p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210271329175.gif" alt="TCP"></p><p>先介绍一下TCP的连接过程</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210271320243.png" alt="03_QtTCP通信过程"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serverwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_serverwidget.h&quot;</span></span></span><br><span class="line">ServerWidget::<span class="built_in">ServerWidget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ServerWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    tcpServer = <span class="literal">NULL</span>;</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    监听套接字,指定父对象</span></span><br><span class="line">    tcpServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tcpServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;服务器端口8888&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有连接建立就会触发newconnection信号</span></span><br><span class="line">    <span class="built_in">connect</span>(tcpServer, QTcpServer::newConnection,[=]()&#123;</span><br><span class="line">        <span class="comment">//取出建立好链接的套接字</span></span><br><span class="line">        tcpSocket = tcpServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对方的ip和端口</span></span><br><span class="line">        QString ip = tcpSocket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">        qint16 port = tcpSocket-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        QString temp = <span class="built_in">QString</span>(<span class="string">&quot;[%1:%2]:成功链接&quot;</span>).<span class="built_in">arg</span>(ip).<span class="built_in">arg</span>(port);</span><br><span class="line">        <span class="comment">//将数据显示在textEditRead上面</span></span><br><span class="line">        ui-&gt;textEditRead-&gt;<span class="built_in">setText</span>(temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//tcpSocket在创建后才能用</span></span><br><span class="line">        <span class="comment">//如果数据传送成功，对方的通信套接字会触发readyRead</span></span><br><span class="line">        <span class="built_in">connect</span>(tcpSocket,QTcpSocket::readyRead,[=]()&#123;</span><br><span class="line">            <span class="comment">//从通信套接字取出内容</span></span><br><span class="line">            QByteArray array = tcpSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">            ui-&gt;textEditRead-&gt;<span class="built_in">append</span>(array);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerWidget::~<span class="built_in">ServerWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerWidget::on_pushButtonSent_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//获取内容</span></span><br><span class="line">    QString str = ui-&gt;textEditWrite-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    <span class="comment">//给对方发送数据</span></span><br><span class="line">    tcpSocket-&gt;<span class="built_in">write</span>(str.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerWidget::on_pushButtonClose_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//主动断开链接</span></span><br><span class="line">    tcpSocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    tcpSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clientwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_clientwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"></span><br><span class="line">ClientWidget::<span class="built_in">ClientWidget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ClientWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    tcpsocket = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;客户端&quot;</span>);</span><br><span class="line"><span class="comment">//    初始化socket并指定父对象</span></span><br><span class="line">    tcpsocket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tcpsocket, QTcpSocket::connected,[=]()&#123;</span><br><span class="line">        ui-&gt;textBrowserRead-&gt;<span class="built_in">setText</span>(<span class="string">&quot;成功连接!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//如果数据传送成功，对方的通信套接字会触发readyRead</span></span><br><span class="line">    <span class="built_in">connect</span>(tcpsocket,QTcpSocket::readyRead,[=]()&#123;</span><br><span class="line">        <span class="comment">//获取对方发送的内容</span></span><br><span class="line">        QByteArray array = tcpsocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="comment">//放入编辑区</span></span><br><span class="line">        ui-&gt;textBrowserRead-&gt;<span class="built_in">append</span>(array);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClientWidget::~<span class="built_in">ClientWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_pushButtonConnect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取服务器IP和端口</span></span><br><span class="line">    QString ip = ui-&gt;lineEditIp-&gt;<span class="built_in">text</span>();</span><br><span class="line">    qint16 port = ui-&gt;lineEditPort-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主动和服务器链接</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip),port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_close_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//主动断开与客户端链接</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    tcpsocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    tcpsocket == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientWidget::on_send_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpsocket == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//获取内容</span></span><br><span class="line">    QString str = ui-&gt;textBrowserWrite-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    tcpsocket-&gt;<span class="built_in">write</span>(str.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>当然还有ui的设计，这里不做解释。如果你想复现,</p><p>还是找我要源码吧<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=768213856&amp;site=qq&amp;menu=yes">http://wpa.qq.com/msgrd?v=3&amp;uin=768213856&amp;site=qq&amp;menu=yes</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT-TCP通信过程&quot;&gt;&lt;a href=&quot;#QT-TCP通信过程&quot; class=&quot;headerlink&quot; title=&quot;QT_TCP通信过程&quot;&gt;&lt;/a&gt;QT_TCP通信过程&lt;/h1&gt;&lt;p&gt;之前我们在计网中，也就是这篇文章：&lt;/p&gt;
&lt;p&gt;介绍了TCP套接字编程，客</summary>
      
    
    
    
    <category term="QT" scheme="https://blog.luoxiaohei.co/categories/QT/"/>
    
    
    <category term="QT" scheme="https://blog.luoxiaohei.co/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--031 下一个排列</title>
    <link href="https://blog.luoxiaohei.co/2022/10/17/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://blog.luoxiaohei.co/2022/10/17/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2022-10-17T04:34:09.918Z</published>
    <updated>2022-11-30T03:28:20.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="1-调用STL的函数"><a href="#1-调用STL的函数" class="headerlink" title="#1 调用STL的函数"></a>#1 调用STL的函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// STL功能和题目描述一致</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-手动实现-时间复杂度O-n-空间复杂度O-1"><a href="#2-手动实现-时间复杂度O-n-空间复杂度O-1" class="headerlink" title="#2 手动实现 时间复杂度O(n),空间复杂度O(1)"></a>#2 手动实现 时间复杂度O(n),空间复杂度O(1)</h2><ul><li>从后往前找到第一个【相邻升序对】，即A[i]&lt;A[i+1]。此时A[i+1,end)为降序。</li><li>在区间[i+1,end)中，从后往前找到第一个大于A[i]的元素A[j]</li><li>交换A[i]和A[j]，此时A[i+1,end)一定还是降序，因为A[j]是从右侧起第一个大于A[i]的值</li><li>反转A[i+1,end)，变成升序</li></ul><p>应用场景：可兼容处理含有重复元素的全排列问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; -- i) &#123; <span class="comment">// 从后往前找到第一个相邻升序对</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 无相邻升序对，必定为非递减序列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= i+<span class="number">1</span>; -- j) &#123; <span class="comment">// 从后往前[i+1,end)找第一个大于a[i+1]的值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i],nums[j]); <span class="comment">// 交换二者</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>()); <span class="comment">// 反转[i+1,end)，变成升序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;31-下一个排列&quot;&gt;&lt;a href=&quot;#31-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31. 下一个排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/next-permutation/&quot;&gt;31. </summary>
      
    
    
    
    <category term="算法题" scheme="https://blog.luoxiaohei.co/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://blog.luoxiaohei.co/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
